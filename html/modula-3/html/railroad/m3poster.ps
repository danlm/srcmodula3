%!PS-Adobe-3.0
%% Copyright (C) 1989, Digital Equipment Corporation
%% All rights reserved.
%% See the file COPYRIGHT for a full description.
%%
%%Title:         m3poster.txt
%%Creator:       Bill Kalsow
%%CreationDate:  Fri Oct 23 13:21:27 1987 by kalsow
%%EditDate:      Last modified on Thu Mar  7 17:39:30 PST 1996 by heydon
%%EditDate:           modified on Fri Oct  4 23:00:48 1991 by kalsow
%%EditDate:           modified on Fri Nov  3 16:32:18 1989 by muller
%%Pages:         1
%%EndComments

%%BeginProlog
%%
%%  a Modula-3 poster
%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%  Select the 11x17 page size if possible

statusdict /11x17tray known
 {statusdict begin 11x17tray end}
 {50 0 translate
  11 17 div dup scale
  0 0 moveto 792 0 lineto
  792 1224 lineto 0 1224 lineto closepath clip} ifelse

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% railroad primitives

/SCALE   7.4  def % sizing parameter
/XSHRINK 0.92 def % x fudge factor
/YSHRINK 0.95 def % y fudge factor
%%
%% Copyright (C) 1989, Digital Equipment Corporation
%% All rights reserved.
%% See the file COPYRIGHT for a full description.
%%
%%Title:         railroad.h
%%Creator:       Bill Kalsow
%%CreationDate:  Fri Oct 23 13:21:27 1987 by kalsow
%%EditDate:      Last modified on Fri Nov  3 16:32:12 1989 by muller
%%EditDate:           modified on Thu Oct 12 08:19:31 1989 by kalsow
%%
%%  experimental Postscript operators for railroad diagrams
%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% misc. operators to make Postscript programming more tolerable

/min { 2 copy gt { exch } if pop } def
/max { 2 copy lt { exch } if pop } def
/stringlen { stringwidth pop } def
/defEnumeration { 0 exch { 1 index def 1 add } forall pop } def
/inches { 72 mul } def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Sizing & font parameters for the picture

/DASHLen   SCALE 0.4 mul def
/DDASHLen  DASHLen dup add def
/HDASHLen  DASHLen 2 div def

/BOXHgt   SCALE 1.2 mul def
/BOXStep  BOXHgt 2 div def

/TERMFont
  /Helvetica-Bold findfont
  SCALE scalefont
  def % TERMFont

/NONTERMFont
  /Times-Italic findfont
  SCALE scalefont
  def % NONTERMFont

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%  drawing primitives

/Hook1 {
    currentpoint        % x y
    DASHLen sub         % x y-D
    DASHLen 90 0 arcn   % x y-D D 90 0 arcn
  } def % Hook1

/Hook2 {
    currentpoint            % x y
    exch DASHLen add exch   % x+D y
    DASHLen 180 270 arc     % x+D y D 180 270 arc
  } def % Hook2

/Hook3 {
    currentpoint        % x y
    DASHLen add         % x y+D
    DASHLen 270 0 arc   % x y+D D 270 0 arc
  } def % Hook3

/Hook4 {
    currentpoint            % x y
    exch DASHLen add exch   % x+D y
    DASHLen 180 90 arcn     % x+D y D 180 90 arcn
  } def % Hook4

/Hook5 {
    currentpoint            % x y
    DASHLen add             % x y+D
    DASHLen 270 180 arcn    % x y+D D 270 180 arcn
  } def % Hook6

/Hook6 {
    currentpoint            % x y
    exch DASHLen sub exch   % x-D y
    DASHLen 0 270 arcn      % x-D y D 0 270 arcn
  } def % Hook6

/Arrow {
    gsave
      currentpoint
      newpath
        moveto
	0.86602 DASHLen mul neg HDASHLen rlineto
	0 DASHLen neg rlineto
	closepath
      fill
    grestore
  } def % Arrow

/BackArrow {
    gsave
      currentpoint
      newpath
        moveto
	0.86602 DASHLen mul HDASHLen rlineto
	0 DASHLen neg rlineto
	closepath
      fill
    grestore
  } def % BackArrow

/DASH {
   newpath moveto DASHLen 0 rlineto stroke
  } def % DASH

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%  frames - a record of values with access functions

/CurrentFrame [ 0 0 0 0 0 0 0 0 0 0 0 ] def

[ /METHODS /INFO /BODY
  /INITIALX /INITIALY
  /FINALX /FINALY
  /NORTH /SOUTH /EAST /WEST ] defEnumeration

/methods   { CurrentFrame METHODS get } def
/methods!  { CurrentFrame exch METHODS exch put } def
/info      { CurrentFrame INFO get } def
/info!     { CurrentFrame exch INFO exch put } def
/body      { CurrentFrame BODY get } def
/body!     { CurrentFrame exch BODY exch put } def
/initialX  { CurrentFrame INITIALX get } def
/initialX! { CurrentFrame exch INITIALX exch put } def
/initialY  { CurrentFrame INITIALY get } def
/initialY! { CurrentFrame exch INITIALY exch put } def
/finalX    { CurrentFrame FINALX get } def
/finalX!   { CurrentFrame exch FINALX exch put } def
/finalY    { CurrentFrame FINALY get } def
/finalY!   { CurrentFrame exch FINALY exch put } def
/north     { CurrentFrame NORTH get } def
/north!    { CurrentFrame exch NORTH exch put } def
/south     { CurrentFrame SOUTH get } def
/south!    { CurrentFrame exch SOUTH exch put } def
/east      { CurrentFrame EAST get } def
/east!     { CurrentFrame exch EAST exch put } def
/west      { CurrentFrame WEST get } def
/west!     { CurrentFrame exch WEST exch put } def

/ENTER: { % exchange top-of-stack and CurrentFrame
    CurrentFrame exch /CurrentFrame exch def
  } def % ENTER:

/:EXIT { % exchange top-of-stack and CurrentFrame
    CurrentFrame exch /CurrentFrame exch def
  } def % :EXIT

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%  object methods:  each object type must provide these methods

[ /TOPVIEW /SIZE /DRAW ] defEnumeration

% TopView: returns the label and body associated with an object

/TopView {                      % self
    ENTER:                      % parent-frame
      methods TOPVIEW get       % parent-frame topview-method
      cvx exec                  % parent-frame
    :EXIT                       % self
  } def % TopView

%  Compute-Size:  computes the bounding box and final (x,y) of the frame
%     on the stack assuming the frame's initial position is (0,0).

/Compute-Size {                 % self
    ENTER:                      % parent-frame
      methods SIZE get          % parent-frame size-method
      cvx exec                  % parent-frame
    :EXIT                       % self
  } def % Compute-Size


%  Draw: given (x, y, frame),  draw frame at (x,y).

/Draw {                         % x y self
    ENTER:                      % x y parent-frame
      3 1 roll                  % parent-frame x y
      initialY!                 % parent-frame x
      initialX!                 % parent-frame
      methods DRAW get          % parent-frame draw-method
      cvx exec                  % parent-frame
    :EXIT                       % self
    pop                         %
  } def % Draw

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%  Sequences

/SEQ-View {
  } def % SEQ-View

/SEQ-Size {
    0 finalX!
    0 finalY!
    body {
      Compute-Size
      dup NORTH  get finalY add north max north!
      dup SOUTH  get finalY add south min south!
      dup WEST   get finalX add west  max west!
      dup EAST   get finalX add east  min east!
      dup FINALX get finalX add           finalX!
          FINALY get finalY add           finalY!
    } forall
  } def % SEQ-Size

/SEQ-Draw {
    initialX initialY % make save copies
    body {                          % f
      dup                           % f f
      initialX initialY 3 -1 roll   % f x y f
      Draw                          % f
      dup FINALX get initialX add   % f f.finalX+initialX
      initialX!                     % f
      FINALY get initialY add       % f.finalY+initialY
      initialY!                     % 
    } forall
    initialY! initialX! % restore the initial copies
  } def % SEQ-Draw

% method list

/SEQ-Methods [ /SEQ-View /SEQ-Size /SEQ-Draw ] def

%  SEQ: body body ... :SEQ

/SEQ:      { [ SEQ-Methods 0 [ } def
/:SEQ      { ] 0 0 0 0 0 0 0 0 ] } def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%  Terminal symbols

/TERM-View {
    TERMFont setfont
    info show
  } def % TERM-View

/TERM-Size {
    TERMFont setfont
    DDASHLen BOXHgt add
    info stringlen add   west!
    0                    east!
    BOXStep neg          south!
    BOXStep              north!
    0                    finalY!
    west                 finalX!
  } def % TERM-Size

/TERM-Draw {
    TERMFont setfont
    /len info stringlen def
    initialX initialY DASH
    initialX DASHLen add BOXStep add
    newpath
      dup initialY BOXStep 90 270 arc
      len 0 rlineto
      currentpoint BOXStep add BOXStep 270 90 arc
      closepath
    stroke
    dup  initialY SCALE 0.34 mul sub   moveto
    info show
    len add BOXStep add  initialY DASH
  } def % TERM-Draw

% method list

/TERM-Methods [ /TERM-View /TERM-Size /TERM-Draw ] def

%  (name) :TERM constructs a terminal node

/:TERM     { [ TERM-Methods 3 -1 roll 0 0 0 0 0 0 0 0 0 ] } def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%  Non-terminal symbols

/NONTERM-View {
    NONTERMFont setfont
    info show
    /CurrentFrame SEQ: body exec :SEQ def
  } def % NONTERM-View

/NONTERM-Size {
    NONTERMFont setfont
    DDASHLen BOXHgt add
    info stringlen add   west!
    0                    east!
    BOXStep neg          south!
    BOXStep              north!
    0                    finalY!
    west                 finalX!
  } def % NONTERM-Size

/NONTERM-Draw {
    NONTERMFont setfont
    /len info stringlen def
    initialX initialY DASH
    initialX DASHLen add
    newpath
      dup                initialY BOXStep sub  moveto
      0                  BOXHgt                rlineto
      BOXHgt len add     0                     rlineto
      0                  BOXHgt neg            rlineto
      closepath
    stroke
    dup BOXStep add     initialY SCALE 0.34 mul sub    moveto
    info show
    len add BOXHgt add  initialY DASH
  } def % NONTERM-Draw

% method list

/NONTERM-Methods [ /NONTERM-View /NONTERM-Size /NONTERM-Draw ] def

%  (name) {body} :NONTERM

/:NONTERM  { [ NONTERM-Methods 4 -2 roll 0 0 0 0 0 0 0 0 ] } def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%  Macros

/:MACRO {     % (name) {body}
    exch pop  % {body}
    SEQ:      % {body} [ SEQ-Methods 0 [
    5 -1 roll %        [ SEQ-Methods 0 [ {body}
    exec      %        [ SEQ-Methods 0 [ body
    :SEQ      % sequence
  } def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%  Options

/OPT-View {
  } def % OPT-View

/OPT-Size {
    body Compute-Size
    0                           east!
    dup WEST  get DDASHLen add  west!
    dup SOUTH get DDASHLen sub  south!
    dup NORTH get               north!
    dup FINALX get DDASHLen add finalX!
        FINALY get              finalY!
  } def % OPT-Size

/OPT-Draw {
    initialX DASHLen add initialY body Draw
    initialX initialY DASH
    newpath
      initialX initialY moveto
      Hook1
      0 body SOUTH get rlineto
      Hook2
      body WEST get DDASHLen sub 0.5 mul dup
      0 rlineto
      Arrow
      0 rlineto
      Hook3
      0 body FINALY get body SOUTH get sub rlineto
      Hook4
      DASHLen neg 0 rlineto
    stroke
  } def % OPT-Draw

% method list

/OPT-Methods [ /OPT-View /OPT-Size /OPT-Draw ] def

%  OPT: body :OPT

/OPT:      { [ OPT-Methods 0 SEQ: } def
/:OPT      { :SEQ 0 0 0 0 0 0 0 0 ] } def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%  separated lists

/LIST-View {
  } def % LIST-View

/LIST-Size {
    body Compute-Size        % body
    0               east!    % body
    dup WEST  get   west!    % body
    dup SOUTH get   south!   % body
    dup NORTH get   north!   % body
        FINALY get  finalY!  %
    info Compute-Size        % info
    dup NORTH get            % info info.north
    1 index SOUTH get sub    % info info.north-info.south
    north add BOXStep add    % info info.north-info.south+north+B
    north!                   % info
    WEST get west max west!  %
    west DDASHLen add west!  %
    west finalX!             %
  } def % LIST-Size

/LIST-Draw {

    % draw the body

    west body WEST get sub       % west-body.west
    2 div dup dup                % (w-b.w)/2 (w-b.w)/2  (w-b.w)/2
    newpath                      % (w-b.w)/2 (w-b.w)/2  (w-b.w)/2
      initialX initialY moveto   % (w-b.w)/2 (w-b.w)/2  (w-b.w)/2
      0 rlineto                  % (w-b.w)/2 (w-b.w)/2
      finalX initialX add        % (w-b.w)/2 (w-b.w)/2 finX+initX
      finalY initialY add moveto % (w-b.w)/2 (w-b.w)/2
      neg 0 rlineto              % (w-b.w)/2
    stroke                       % (w-b.w)/2
    initialX add                 % (w-b.w)/2+initX
    initialY body Draw           %

    % draw the separator & vertical lines

    west info WEST get sub       % (w-i.w)
    DDASHLen sub                 % (w-i.w-2*D)
    2 div dup                    % (w-i.w)/2 (w-i.w)/2
    newpath                      % (w-i.w)/2 (w-i.w)/2
      initialX DASHLen add       % (w-i.w)/2 (w-i.w)/2 initX+D
      initialY moveto            % (w-i.w)/2 (w-i.w)/2
      Hook5                      % (w-i.w)/2 (w-i.w)/2
      initialX initialY          % (w-i.w)/2 (w-i.w)/2 initX initY
      north add                  % (w-i.w)/2 (w-i.w)/2 iX iY+n
      info NORTH get sub         % (w-i.w)/2 (w-i.w)/2 iX iY+n-i.n
      DASHLen sub lineto         % (w-i.w)/2 (w-i.w)/2
      Hook4                      % (w-i.w)/2 (w-i.w)/2
      0 rlineto currentpoint     % (w-i.w)/2 x' y'
    stroke                       % (w-i.w)/2 x' y'
    2 copy info Draw             % (w-i.w)/2 x' y'
    newpath                      % (w-i.w)/2 x' y'
      info FINALY get add exch   % (w-i.w)/2 y'+i.finY x'
      info FINALX get add exch   % (w-i.w)/2 x'+i.finX y'+i.finY
      moveto                     % (w-i.w)/2
      BackArrow                  %
      0 rlineto                  %
      Hook1                      %
      initialX west add          % initX+w
      initialY finalY add        % intiX+w initY+finY
      DASHLen add lineto         %
      Hook6                      %
    stroke                       %

  } def % LIST-Draw

% method list

/LIST-Methods [ /LIST-View /LIST-Size /LIST-Draw ] def

%  LIST: body :SEP: separator :LIST

/LIST:      { [ LIST-Methods SEQ: } def
/:SEP:      { :SEQ SEQ: } def
/:LIST      { :SEQ exch 0 0 0 0 0 0 0 0 ] } def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% optional separated lists

/OLIST: { OPT: LIST: } def
/:OLIST { :LIST :OPT } def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%  Loops

/LOOP-View {
  } def % LOOP-View

/LOOP-Size {
    body Compute-Size
    0                           east!
    dup WEST  get DDASHLen add  west!
    dup SOUTH get               south!
    dup NORTH get DDASHLen add  north!
    dup FINALX get DDASHLen add finalX!
        FINALY get              finalY!
  } def % LOOP-Size

/LOOP-Draw {
    initialX DASHLen add initialY body Draw
    initialX initialY DASH
    newpath
      initialX DASHLen add initialY moveto
      Hook5
      0 body NORTH get rlineto
      Hook4
      body WEST get 0.5 mul dup
      0 rlineto
      BackArrow
      0 rlineto
      Hook1
      0  body FINALY get  body NORTH get  sub rlineto
      Hook6
      DASHLen 0 rlineto
    stroke
  } def % LOOP-Draw

% method list

/LOOP-Methods [ /LOOP-View /LOOP-Size /LOOP-Draw ] def

%  LOOP: body :LOOP

/LOOP:      { [ LOOP-Methods 0 SEQ: } def
/:LOOP      { :SEQ 0 0 0 0 0 0 0 0 ] } def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Optional loops

/OLOOP:      { OPT: LOOP: } def
/:OLOOP      { :LOOP :OPT } def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%  Vertical list of choices

/CHOICE-View {
  } def % CHOICE-View

/CHOICE-Size {
    0                     % total
    body {                % total f
      Compute-Size        % total f
      dup WEST get        % total f f.west
      west max west!      % total f
      dup NORTH get       % total f f.north
      exch SOUTH get      % total f.north f.south
      sub add             % total+(f.north-f.south)
    } forall              % total
    body length 1 sub     % total N-1
    BOXStep mul add       % total+(N-1)*B/2
    body 0 get NORTH get  % total f[0].north
    dup north!            % total f[0].north
    sub neg south!        %
    0 east!               %
    west DDASHLen dup add % MAX(body[i].west) 4*D
    add west!             %
    body 0 get FINALY get % f[0].finalY
    finalY!               %
    west finalX!          %
  } def % CHOICE-Size

/CHOICE-Draw {
    %
    % draw the first body
    %
    newpath
      initialX initialY moveto
      DDASHLen 0 rlineto
    stroke
    initialX DDASHLen add initialY
    body 0 get
    Draw
    body 0 get
    newpath
      dup FINALX get initialX add DDASHLen add
      exch FINALY get initialY add
      dup 3 -1 roll exch moveto
      west initialX add exch lineto
    stroke
    initialY body 0 get SOUTH get add info!
    %
    % draw the middle bodies
    %
    1 1 body length 2 sub  {
      body exch get
      dup NORTH get BOXStep add info exch sub info!
      newpath
        initialX DDASHLen add info moveto
        Hook5
	initialX DDASHLen add
	1 index FINALX get add
	1 index FINALY get info add
	moveto
	west initialX add DDASHLen sub
	1 index FINALY get info add
	lineto
	Hook3
      stroke
      dup initialX DDASHLen add info
      4 -1 roll Draw
      SOUTH get info add info!
    } for
    %
    % draw the final body
    %
    body dup length 1 sub get            % f[N-1]
    dup NORTH get BOXStep add            % fn fn.north+B/2
    info exch sub info!                  % fn
    newpath                              % fn
      initialX initialY moveto           % fn
      Hook1                              % fn
      initialX DASHLen add               % fn initX+D
      info DASHLen add lineto            % fn
      Hook2                              % fn
      initialX DDASHLen add              % fn initX+2*D
      1 index FINALX get add             % fn initX+2*D+fn.finalX
      1 index FINALY get info add        % fn initX+2*D+fn.finX fn.finY+info
      moveto                             % fn
      west initialX add DDASHLen sub     % fn west+initX-2*D
      1 index FINALY get info add        % fn west+initX-2*D fn.finY+info
      lineto                             % fn
      Hook3                              % fn
      west initialX add DASHLen sub      % fn west+initX-2*D
      initialY body 0 get FINALY get     % fn west+initX-2*D initY+f[0].finalY
      add DASHLen sub lineto             % fn
      Hook4                              % fn
    stroke                               % fn
    initialX DDASHLen add info           % fn initX+2*D info
    3 -1 roll                            % initX+2*D info fn
    Draw                                 %
  } def % CHOICE-Draw

% method list

/CHOICE-Methods [ /CHOICE-View /CHOICE-Size /CHOICE-Draw ] def

%  CHOICE:  body0 body1 body2 ... bodyN  :CHOICE

/CHOICE:      { [ CHOICE-Methods 0 [ } def
/:CHOICE      { ] 0 0 0 0 0 0 0 0 ] } def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%  Horizontal list of choices

/HCHOICE-View {
  } def % HCHOICE-View

/HCHOICE-Size {
    0                     % total
    body {                % total f
      Compute-Size        % total f
      dup NORTH get       % total f f.north
      north max north!    % total f
      dup SOUTH get       % total f f.south
      south min south!    % total f
      WEST get add        % total + f.west
    } forall              % total
    body length           % total N
    3 mul 1 add           % total 3N+1
    DASHLen mul add       % total + (3N+1)*D
    west!                 %
    west finalX!          %
    0 east!               %
    0 finalY!             %
    south DASHLen sub south!
    north DASHLen add north!
  } def % CHOICE-Size

/HCHOICE-Draw {
    %
    % draw the first body
    %
    newpath
      initialX initialY moveto
      DDASHLen 0 rlineto
    stroke
    initialX DDASHLen add initialY
    body 0 get Draw
    body 0 get
    newpath
      dup  FINALX get initialX add DDASHLen add info!
      info exch FINALY get initialY add moveto
      Hook1
      info DASHLen add info!
      info initialY south add DASHLen add lineto
      Hook2
      initialX finalX add DDASHLen sub initialY south add lineto
      Hook3
      0 south neg DDASHLen sub rlineto
      Hook4
    stroke
    %
    % draw the middle bodies
    %
    1 1 body length 2 sub  {
      body exch get
      newpath
	info initialY north add moveto
	Hook1
	info DASHLen add info!
	info initialY DASHLen add lineto
	Hook2
	info DASHLen add info!
	currentpoint
      stroke
      2 index Draw
      newpath
        dup FINALX get info add info!
        FINALY get initialY add
        info exch moveto
	Hook1
	info DASHLen add info!
	info initialY south add DASHLen add lineto
	Hook2
      stroke
    } for
    %
    % draw the final body
    %
    newpath
      initialX initialY moveto
      Hook3
      0 north DDASHLen sub rlineto
      Hook4
      info initialY north add lineto
      Hook1
      info DASHLen add info!
      info initialY DASHLen add lineto
      Hook2
      info DASHLen add info!
    stroke
    body dup length 1 sub get            % f[N-1]
    dup dup                              % fn fn fn
    info initialY 3 -1 roll Draw         % fn fn
    FINALX get info add                  % fn fn.finX+info
    exch FINALY get initialY add         % fn.finX+info fn.finY
    newpath
      moveto
      initialX finalX add
      initialY finalY add
      lineto
    stroke
  } def % HCHOICE-Draw

% method list

/HCHOICE-Methods [ /HCHOICE-View /HCHOICE-Size /HCHOICE-Draw ] def

%  HCHOICE:  body0 body1 body2 ... bodyN  :HCHOICE

/HCHOICE:      { [ HCHOICE-Methods 0 [ } def
/:HCHOICE      { ] 0 0 0 0 0 0 0 0 ] } def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%  Epsilon

/EPSILON-View { } def

/EPSILON-Size {
    0  east!
    0  west!
    0  north!
    0  south!
    0  finalX!
    0  finalY!
  } def % EPSILON-Size

/EPSILON-Draw { } def

% method list

/EPSILON-Methods [ /EPSILON-View /EPSILON-Size /EPSILON-Draw ] def

%  :EPSILON:

/:EPSILON:      { [ EPSILON-Methods 0 0 0 0 0 0 0 0 0 0 ] } def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%  top-level drawing function

/DrawProduction {           % x y f
    3 copy pop moveto       % x y f
    TopView                 % x y f
    Compute-Size            % x y f
    dup NORTH get           % x y f f.north
    2 index sub neg         % x y f (y-f.north)
    BOXStep sub             % x y f (y-f.north-B)
    4 -1 roll BOXStep add   %   y f (y-f.north-B) (x+B)
    4 -1 roll pop exch      %     f (x+B) (y-f.north-B)
    newpath                 %     f (x+B) (y-f.north-B)
      2 copy moveto         %     f (x+B) (y-f.north-B)
      DDASHLen 0 rlineto    %     f (x+B) (y-f.north-B)
      Arrow                 %     f (x+B) (y-f.north-B)
    stroke                  %     f (x+B) (y-f.north-B)
    exch DDASHLen add exch  %     f (x+B+2D) (y-f.north-B)
    2 copy                  %     f (x+B+2D) (y-f.north-B) (x+B+2D) (y-f.n-B)
    4 index                 %     f (x+B+2D) (y-f.north-B) (x+B+2D) (y-f.n-B) f
    Draw                    %     f (x+B+2D) (y-f.north-B)
    newpath                 %     f (x+B+2D) (y-f.north-B)
      moveto                %     f
      dup FINALX get        %     f f.finalX
      1 index FINALY get    %     f f.finalX f.finalY
      rmoveto               %     f
      DDASHLen 0 rlineto    %     f
      Arrow                 %     f
    stroke                  %     f
    dup NORTH get           %     f f.north
    exch SOUTH get          %       f.north f.south
    sub SCALE add           %       f.north-f.south+SCALE
    BOXStep add             %       f.north-f.south+SCALE+B
  } def % DrawProduction

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

500 dict begin % local Modula-3 dictionary

%!
%% Copyright (C) 1989, Digital Equipment Corporation
%% All rights reserved.
%% See the file COPYRIGHT for a full description.
%%
%%Title:         m3grammar.h
%%Creator:       Bill Kalsow
%%CreationDate:  Fri Oct 23 13:21:27 1987 by kalsow
%%EditDate:      Last modified on Fri Oct  4 19:31:07 1991 by kalsow
%%EditDate:           modified on Fri Nov  3 16:32:19 1989 by muller

%%
%%  a Modula-3 grammar
%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%
% terminals
%

/ident    { (id)           :TERM } def
/number   { (number)       :TERM } def
/char     { (char literal) :TERM } def
/string   { (text literal) :TERM } def

/PLUS     { (+)   :TERM } def
/MINUS    { (-)   :TERM } def
/STAR     { (*)   :TERM } def
/SLASH    { (/)   :TERM } def
/GETS     { (:=)  :TERM } def
/CONCAT   { (&)   :TERM } def
/DOT      { (.)   :TERM } def
/COMMA    { (,)   :TERM } def
/SEMI     { (;)   :TERM } def
/LPAREN   { (\()  :TERM } def
/RPAREN   { (\))  :TERM } def
/LBRACK   { ([)   :TERM } def
/RBRACK   { (])   :TERM } def
/LBRACE   { ({)   :TERM } def
/RBRACE   { (})   :TERM } def
/ARROW    { (^)   :TERM } def
/EQ       { (=)   :TERM } def
/NE       { (#)   :TERM } def
/LT       { (<)   :TERM } def
/GT       { (>)   :TERM } def
/LE       { (<=)  :TERM } def
/GE       { (>=)  :TERM } def
/DOTDOT   { (..)  :TERM } def
/COLON    { (:)   :TERM } def
/BAR      { (|)   :TERM } def
/SUBTYPE  { (<:)  :TERM } def
/HENCE    { (=>)  :TERM } def
/SQUOTE   { (')   :TERM } def
/DQUOTE   { (")   :TERM } def
/BSLASH   { (\\)  :TERM } def

/AND             { (AND)            :TERM } def
/ANY             { (ANY)            :TERM } def
/ARRAY           { (ARRAY)          :TERM } def
/AS              { (AS)             :TERM } def
/BEGIN           { (BEGIN)          :TERM } def
/BITS            { (BITS)           :TERM } def
/BRANDED         { (BRANDED)        :TERM } def
/BY              { (BY)             :TERM } def
/CASE            { (CASE)           :TERM } def
/CONST           { (CONST)          :TERM } def
/DEC             { (DEC)            :TERM } def
/DIV             { (DIV)            :TERM } def
/DO              { (DO)             :TERM } def
/ELSE            { (ELSE)           :TERM } def
/ELSIF           { (ELSIF)          :TERM } def
/END             { (END)            :TERM } def
/EVAL            { (EVAL)           :TERM } def
/EXCEPT          { (EXCEPT)         :TERM } def
/EXCEPTION       { (EXCEPTION)      :TERM } def
/EXIT            { (EXIT)           :TERM } def
/EXPORTS         { (EXPORTS)        :TERM } def
/FINALLY         { (FINALLY)        :TERM } def
/FOR             { (FOR)            :TERM } def
/FROM            { (FROM)           :TERM } def
/GENERIC         { (GENERIC)        :TERM } def
/IF              { (IF)             :TERM } def
/IMPORT          { (IMPORT)         :TERM } def
/IN              { (IN)             :TERM } def
/INC             { (INC)            :TERM } def
/INTERFACE       { (INTERFACE)      :TERM } def
/LOCK            { (LOCK)           :TERM } def
/LOOP            { (LOOP)           :TERM } def
/METHODs         { (METHODS)        :TERM } def
/MOD             { (MOD)            :TERM } def
/MODULE          { (MODULE)         :TERM } def
/NEW             { (NEW)            :TERM } def
/NOT             { (NOT)            :TERM } def
/OBJECT          { (OBJECT)         :TERM } def
/OF              { (OF)             :TERM } def
/OR              { (OR)             :TERM } def
/OVERRIDES       { (OVERRIDES)      :TERM } def
/PROCEDURE       { (PROCEDURE)      :TERM } def
/RAISE           { (RAISE)          :TERM } def
/RAISES          { (RAISES)         :TERM } def
/READONLY        { (READONLY)       :TERM } def
/RECORD          { (RECORD)         :TERM } def
/REF             { (REF)            :TERM } def
/REPEAT          { (REPEAT)         :TERM } def
/RETURN          { (RETURN)         :TERM } def
/REVEAL          { (REVEAL)         :TERM } def
/ROOT            { (ROOT)           :TERM } def
/SET             { (SET)            :TERM } def
/THEN            { (THEN)           :TERM } def
/TO              { (TO)             :TERM } def
/TRY             { (TRY)            :TERM } def
/TYPE            { (TYPE)           :TERM } def
/TYPECASE        { (TYPECASE)       :TERM } def
/UNSAFE          { (UNSAFE)         :TERM } def
/UNTIL           { (UNTIL)          :TERM } def
/UNTRACED        { (UNTRACED)       :TERM } def
/VALUE           { (VALUE)          :TERM } def
/VAR             { (VAR)            :TERM } def
/WHILE           { (WHILE)          :TERM } def
/WITH            { (WITH)           :TERM } def

%
% forward declarations
%

/Expression        { (Expression) { }        :NONTERM } def
/ConstExpression   { (ConstExpression) { }   :NONTERM } def
/Type              { (Type)              { } :NONTERM } def
/StatementSequence { (StatementSequence) { } :NONTERM } def
/declarations      { (declarations) { }      :NONTERM } def

%
% non-terminals
%

/QID {
    (QualId)
    { ident OPT: DOT ident :OPT }
    :MACRO
  } def

/TypeID {
    (Type ID)
    { CHOICE: QID ROOT SEQ: UNTRACED ROOT :SEQ :CHOICE }
    :NONTERM
  } def

/ExceptionID {
    (Exception ID)
    { QID }
    :NONTERM
  } def

/IdentList {
    (ID list)
    { LIST: ident :SEP: COMMA :LIST }
    :MACRO
  } def

/actual {
    (Actual)
    { CHOICE: SEQ: OPT: ident GETS :OPT Expression :SEQ Type :CHOICE }
    :NONTERM
  } def

/ActualArgs {
    (actual arguments)
    { LPAREN OLIST: actual :SEP: COMMA :OLIST RPAREN }
    :MACRO
 } def

/Selector {
    (Selector)
    {
      CHOICE:
        :EPSILON:
	SEQ: ARROW        :SEQ
	SEQ: DOT ident    :SEQ
	SEQ: LBRACK LIST: Expression :SEP: COMMA :LIST RBRACK :SEQ
	ActualArgs
      :CHOICE
    }
    :MACRO
  } def

/setElt {
    (set element)
    { Expression OPT: DOTDOT Expression :OPT }
    :MACRO
  } def

/setCons {
    (set constructor)
    { LIST: setElt :SEP: COMMA :LIST }
    :NONTERM
  } def

/recordElt {
    (record element)
    { OPT: ident GETS :OPT Expression }
    :MACRO
  } def

/recordCons {
    (record constructor)
    { LIST: recordElt :SEP: COMMA :LIST }
    :NONTERM
  } def

/arrayCons {
    (array constructor)
    { LIST: Expression :SEP: COMMA :LIST OPT: COMMA DOTDOT :OPT }
    :NONTERM
  } def

/Constructor {
    (Constructor)
    {
      Type
      LBRACE
       CHOICE: :EPSILON: setCons recordCons arrayCons :CHOICE
      RBRACE
    }
    :NONTERM
  } def

/unaryop {
    (unary op)
    { CHOICE: :EPSILON: PLUS MINUS :CHOICE }
    :MACRO
  } def

/e8 {
    (primary)
    {
      CHOICE:
	ident
        number
	char
	string
	Constructor
	SEQ: LPAREN Expression RPAREN :SEQ
      :CHOICE
    }
    :NONTERM
  } def

/e7 {
    (e7)
    { e8 LOOP: Selector :LOOP }
    :MACRO
  } def

/e6 {
    (e6)
    { LOOP: unaryop :LOOP e7 }
    :NONTERM
  } def

/mulop {
    (mul op)
    { HCHOICE: STAR SLASH DIV MOD :HCHOICE }
    :MACRO
  } def

/e5 {
    (e5)
    { e6 OLOOP: mulop e6 :OLOOP }
    :NONTERM
  } def

/addop {
    (add op)
    { HCHOICE: PLUS MINUS CONCAT :HCHOICE }
    :MACRO
  } def

/e4 {
    (e4)
    { e5 OLOOP: addop e5 :OLOOP }
    :NONTERM
  } def

/relation {
    (relation)
    { HCHOICE: EQ NE LT LE GT GE IN :HCHOICE }
    :MACRO
  } def

/e3 {
    (e3)
    { e4 OLOOP: relation e4 :OLOOP }
    :NONTERM
  } def

/e2 {
    (e2)
    { OLOOP: NOT :OLOOP e3 }
    :NONTERM
  } def

/e1 {
    (e1)
    { e2 OLOOP: AND e2 :OLOOP }
    :NONTERM
  } def

/Expression {
    (Expression)
    { e1 OLOOP: OR e1 :OLOOP }
    :NONTERM
  } def

/ConstExpression {
    (Constant expression)
    { Expression }
    :NONTERM
  } def

/formalType {
    (formal type)
    {
      CHOICE:
        SEQ: COLON Type GETS ConstExpression :SEQ
	SEQ: COLON Type :SEQ
        SEQ: GETS ConstExpression :SEQ
      :CHOICE
    }
    :MACRO
  } def

/field {
    (field)
    { IdentList formalType }
    :NONTERM
  } def

/fields {
    (fields)
    { OPT: LIST: field :SEP: SEMI :LIST OPT: SEMI :OPT :OPT }
    :NONTERM
  } def

/ArrayType {
    (Array type)
    { ARRAY OLIST: Type :SEP: COMMA :OLIST OF Type }
    :NONTERM
  } def

/PackedType {
    (Packed type)
    { BITS ConstExpression FOR Type }
    :NONTERM
  } def

/EnumerationType {
    (Enumeration type)
    { LBRACE OPT: IdentList :OPT RBRACE }
    :NONTERM
  } def

/method {
    (method)
    { ident Signature OPT: GETS ConstExpression :OPT }
    :NONTERM
  } def

/methodList {
    (methods)
    { METHODs OPT: LIST: method :SEP: SEMI :LIST OPT: SEMI :OPT :OPT }
    :NONTERM
  } def

/override {
    (override)
    { ident GETS ConstExpression }
    :MACRO
  } def

/overrideList {
    (overrides)
    { OVERRIDES OPT: LIST: override :SEP: SEMI :LIST OPT: SEMI :OPT :OPT }
    :NONTERM
  } def

/Brand {
    (Brand)
    {  OPT: BRANDED OPT: ConstExpression :OPT :OPT  }
    :NONTERM
  } def

/ObjectType {
    (Object type)
    { CHOICE: :EPSILON: TypeID ObjectType :CHOICE  Brand OBJECT
        fields
        OPT: methodList :OPT
        OPT: overrideList :OPT
      END
    }
    :NONTERM
  } def

/ProcedureType {
    (Procedure type)
    { PROCEDURE Signature }
    :NONTERM
  } def

/SubrangeType {
    (Subrange type)
    { LBRACK ConstExpression DOTDOT ConstExpression RBRACK }
    :NONTERM
  } def

/RecordType {
    (Record type)
    { RECORD fields END }
    :NONTERM
  } def

/RefType {
    (Ref type)
    { CHOICE: :EPSILON: UNTRACED :CHOICE Brand REF Type }
    :NONTERM
  } def

/SetType {
    (Set type)
    { SET OF Type }
    :NONTERM
  } def

/Type {
    (Type)
    {
      CHOICE:
        TypeID
        ArrayType
        PackedType
        EnumerationType
        ObjectType
        ProcedureType
        RecordType
        RefType
        SetType
        SubrangeType
        SEQ: LPAREN Type RPAREN :SEQ
      :CHOICE
    }
    :NONTERM
  } def

/AssignmentStatement {
    (Assignment statement)
    { Expression GETS Expression }
    :NONTERM
  } def

/CallStatement {
    (Call statement)
    { Expression ActualArgs }
    :NONTERM
  } def

/caseLabels {
    (case label)
    { ConstExpression OPT: DOTDOT ConstExpression :OPT }
    :MACRO
  } def

/CaseLabelList {
    (Case labels)
    { LIST: caseLabels :SEP: COMMA :LIST }
    :MACRO
  } def

/case {
    (case)
    { CaseLabelList HENCE StatementSequence }
    :NONTERM
  } def

/CaseStatement {
    (Case statement)
    {
      CASE Expression OF
      OPT:   case                   :OPT
      OLOOP: BAR case               :OLOOP
      OPT:   ELSE StatementSequence :OPT
      END
    }
    :NONTERM
  } def

/DecStatement {
    (Dec statement)
    { DEC LPAREN Expression OPT: COMMA Expression :OPT RPAREN }
    :NONTERM
  } def

/ExitStatement {
    (Exit statement)
    { EXIT }
    :NONTERM
  } def

/EvalStatement {
    (Eval statement)
    { EVAL Expression }
    :NONTERM
  } def

/ForStatement {
    (For statement)
    {
      FOR ident GETS Expression TO Expression
        OPT: BY Expression :OPT
	DO StatementSequence END
    }
    :NONTERM
  } def

/IfStatement {
    (If statement)
    {
      IF Expression THEN StatementSequence
      OLOOP: ELSIF Expression THEN StatementSequence :OLOOP
      OPT: ELSE StatementSequence :OPT
      END
    }
    :NONTERM
  } def

/IncStatement {
    (Inc statement)
    { INC LPAREN Expression OPT: COMMA Expression :OPT RPAREN }
    :NONTERM
  } def

/LockStatement {
    (Lock statement)
    { LOCK Expression DO StatementSequence END }
    :NONTERM
  } def

/LoopStatement {
    (Loop statement)
    { LOOP StatementSequence END }
    :NONTERM
  } def

/RaiseStatement {
    (Raise statement)
    { RAISE ExceptionID OPT: LPAREN Expression RPAREN :OPT }
    :NONTERM
  } def

/RepeatStatement {
    (Repeat statement)
    { REPEAT StatementSequence UNTIL Expression }
    :NONTERM
  } def

/ReturnStatement {
    (Return statement)
    { RETURN OPT: Expression :OPT }
    :NONTERM
  } def

/TryFinallyStatement {
    (Try-Finally statement)
    { TRY StatementSequence FINALLY StatementSequence END }
    :NONTERM
  } def

/handler {
    (handler)
    {
      LIST: ExceptionID :SEP: COMMA :LIST
      OPT:  LPAREN ident RPAREN :OPT
      HENCE StatementSequence
    }
    :NONTERM
  } def

/TryStatement {
    (Try statement)
    {
      TRY StatementSequence
      EXCEPT
        OPT:   handler :OPT
	OLOOP: BAR handler :OLOOP
        OPT:   ELSE StatementSequence :OPT
      END
    }
    :NONTERM
  } def

/tcase {
    (tcase)
    {
      LIST: Type :SEP: COMMA :LIST
      OPT:  LPAREN ident RPAREN :OPT
      HENCE StatementSequence
    }
    :NONTERM
  } def

/TypeCaseStatement {
    (Typecase statement)
    {
      TYPECASE Expression OF
      OPT:   tcase                  :OPT
      OLOOP: BAR tcase              :OLOOP
      OPT:   ELSE StatementSequence :OPT
      END
    }
    :NONTERM
  } def

/WhileStatement {
    (While statement)
    { WHILE Expression DO StatementSequence END }
    :NONTERM
  } def

/binding {
    (binding)
    { ident EQ Expression }
    :MACRO
  } def

/WithStatement {
    (With statement)
    { WITH  LIST: binding :SEP: COMMA :LIST DO StatementSequence END }
    :NONTERM
  } def

/statement {
    (statement)
    {
      CHOICE: 
        AssignmentStatement
	Block
	CallStatement
        CaseStatement
	DecStatement
        ExitStatement
	EvalStatement
        ForStatement
        IfStatement
	IncStatement
        LockStatement
        LoopStatement
	RaiseStatement
        RepeatStatement
        ReturnStatement
        TryFinallyStatement
        TryStatement
        TypeCaseStatement
        WhileStatement
        WithStatement
      :CHOICE
    }
    :MACRO
  } def

/StatementSequence {
    (Stmts)
    { OPT: LIST: statement :SEP: SEMI :LIST OPT: SEMI :OPT :OPT }
    :NONTERM
  } def

/raises {
    (raises)
    { CHOICE:
        SEQ: LBRACE OLIST: ExceptionID :SEP: COMMA :OLIST RBRACE :SEQ
        ANY
      :CHOICE }
    :MACRO
  } def

/formal {
    (formal)
    { CHOICE: :EPSILON: VALUE VAR READONLY :CHOICE IdentList formalType }
    :NONTERM
  } def

/formals {
    (formals)
    { OPT: LIST: formal :SEP: SEMI :LIST OPT: SEMI :OPT :OPT }
    :NONTERM
  } def

/Signature {
    (Signature)
    { LPAREN formals RPAREN OPT: COLON Type :OPT OPT: RAISES raises :OPT }
    :NONTERM
  } def

/ProcedureHeading {
    (Procedure heading)
    { PROCEDURE ident Signature }
    :NONTERM
  } def

/ConstDeclaration {
    (Constant declaration)
    { ident OPT: COLON Type :OPT EQ ConstExpression }
    :NONTERM
  } def

/TypeDeclaration {
    (Type declaration)
    { ident CHOICE: EQ SUBTYPE :CHOICE Type }
    :NONTERM
  } def

/VariableDeclaration {
    (Variable declaration)
    {
      IdentList
      CHOICE:
	SEQ: COLON Type OPT: GETS Expression :OPT :SEQ
        SEQ: GETS Expression :SEQ
      :CHOICE
    }
    :NONTERM
  } def

/ExceptionDeclaration {
    (Exception declaration)
    { ident OPT: LPAREN Type RPAREN :OPT }
    :NONTERM
  } def

/Revelation {
    (Revelation)
    { TypeID CHOICE: EQ SUBTYPE :CHOICE Type }
    :NONTERM
  } def

/Declaration {
    (Declaration)
    {
      CHOICE: 
        SEQ: CONST     OLOOP: ConstDeclaration     SEMI :OLOOP :SEQ
        SEQ: TYPE      OLOOP: TypeDeclaration      SEMI :OLOOP :SEQ
        SEQ: EXCEPTION OLOOP: ExceptionDeclaration SEMI :OLOOP :SEQ
        SEQ: VAR       OLOOP: VariableDeclaration  SEMI :OLOOP :SEQ
        SEQ: REVEAL    OLOOP: Revelation           SEMI :OLOOP :SEQ
        SEQ: ProcedureHeading OPT: EQ Block ident :OPT SEMI :SEQ
      :CHOICE
    }
    :NONTERM
  } def

/declarations { OLOOP: Declaration :OLOOP } def

/Block {
    (Block)
    { declarations BEGIN StatementSequence END }
    :NONTERM
  } def

/AsClause {
    (as clause)
    { CHOICE: :EPSILON: SEQ: AS ident :SEQ :CHOICE }
    :MACRO
  } def

/Import {
    (Import)
    { CHOICE:
        SEQ: IMPORT LIST: ident AsClause :SEP: COMMA :LIST SEMI :SEQ
        SEQ: FROM ident IMPORT IdentList SEMI :SEQ
      :CHOICE
    }
    :NONTERM
  } def

/imports { OLOOP: Import :OLOOP } def

/GenericActuals {
    (generic actuals)
    { LPAREN OPT: IdentList :OPT RPAREN }
    :MACRO
  } def

/GenericFormals {
    (generic formals)
    { LPAREN OPT: IdentList :OPT RPAREN }
    :MACRO
  } def

/GenericHead {
    (Generic head)
    { ident GenericActuals }
    :NONTERM
  } def


/InterfaceBody {
    (Interface body)
    { imports declarations }
    :NONTERM
  } def

/Interface {
    (Interface)
    { INTERFACE ident
      CHOICE:
        SEQ: SEMI InterfaceBody  :SEQ
        SEQ: EQ GenericHead      :SEQ
      :CHOICE
      END ident DOT
    }
    :NONTERM
  } def

/ModuleBody {
    (Module body)
    { imports Block }
    :NONTERM
  } def

/Module {
    (Module)
    { MODULE ident OPT: EXPORTS IdentList :OPT
      CHOICE:
        SEQ: SEMI ModuleBody    :SEQ
        SEQ: EQ GenericHead END :SEQ
      :CHOICE
      ident DOT
    }
    :NONTERM
  } def

/GenericInterface {
    (Generic interface)
    { GENERIC INTERFACE GenericHead SEMI InterfaceBody END ident DOT }
    :NONTERM
  } def

/GenericModule {
    (Generic module)
    { GENERIC MODULE GenericHead SEMI ModuleBody ident DOT }
    :NONTERM
  } def

/CompilationUnit {
    (Compilation unit)
    { CHOICE:
        SEQ: CHOICE: :EPSILON: UNSAFE :CHOICE
             CHOICE: Interface Module :CHOICE  :SEQ
        GenericInterface
        GenericModule
      :CHOICE
    }
    :NONTERM
  } def


/MaxY            10.5 inches def
/MinY            0.1 inches def
/MaxX            17  inches def

/StartColumn     { /LastY MaxY def } def
/ColumnOne       { /BaseX   0 def  StartColumn } def
/ColumnTwo       { /BaseX MaxX 0.20 mul def  StartColumn } def
/ColumnThree     { /BaseX MaxX 0.55 mul def StartColumn } def
/ColumnFour      { /BaseX MaxX 0.75 mul def StartColumn } def
/Landscape       { 270 rotate 16.75 neg inches 0 translate } def
/ResetGraphics   { Landscape SCALE 10 div setlinewidth } def
% /ShowPage        { showpage ResetGraphics } def
% /FlushPage       { ShowPage  ColumnOne } def
% /CheckBottom     { LastY MinY lt { FlushPage } if } def

/DoIt {               % rule indent
%    CheckBottom         % rule indent
  5 SCALE mul mul     % rule 5*S*indent
  BaseX add           % rule 5*S*indent+Col
  LastY               % rule 5*S*indent+Col LastY
  3 -1 roll           %      5*S*indent+Col LastY rule
  DrawProduction      % height
  LastY sub neg       % LastY-height
  BOXHgt sub          % LastY-height-BOXHgt
  /LastY exch def     %
} def % DoIt

/Place {                      %  prod x y
  SCALE mul YSHRINK mul exch  %  prod y*S x
  SCALE mul XSHRINK mul exch  %  prod x*S y*S
  3 -1 roll                   %       x*S y*S prod
  DrawProduction              %  height
  pop                         %
} def % Place

/Grid {
  /gridStep exch SCALE mul def
  0 gridStep MaxY {
    newpath dup 0 exch moveto MaxX exch lineto stroke
  } for
  0 gridStep MaxX {
    newpath dup 0 moveto MaxY lineto stroke
  } for
} def % Grid

%%Page: 1 1
save
ResetGraphics
%%% 10 Grid

 CompilationUnit        0 105 Place
 Interface             22 105 Place
 Module                 0  96 Place
 GenericInterface       0  89 Place
 GenericModule          0  86 Place
 GenericHead           72  93 Place
 InterfaceBody         22 100 Place
 ModuleBody            46 100 Place
 Import                46  95 Place
 Block                 30  82 Place
 Declaration            0  82 Place
 ConstDeclaration      30  76 Place
 VariableDeclaration   64  75 Place
 ProcedureHeading      59  80 Place
 TypeDeclaration       30  71 Place
 ExceptionDeclaration  68  84 Place
 Revelation            47  71 Place
 Signature             31  66 Place
  formal                0  60 Place

 StatementSequence      0  42 Place
 AssignmentStatement   22  41 Place
 CallStatement         71  35 Place
 CaseStatement         21  35 Place
  case                 22  28 Place
 DecStatement          21   8 Place  
 ExitStatement         45  41 Place
 EvalStatement         55  41 Place
 ForStatement          21  20 Place
 IfStatement           21  15 Place
 IncStatement          52   8 Place
 LockStatement         90  41 Place
 LoopStatement         72  41 Place
% NewStatement          80   8 Place
 RaiseStatement       120  10 Place
 RepeatStatement       96  35 Place
 ReturnStatement       60  28 Place
 TryFinallyStatement   80  28 Place
 TryStatement         120  42 Place
  handler             130  35 Place
 TypeCaseStatement    110  27 Place
  tcase               145  20 Place
 WhileStatement        80  20 Place
 WithStatement        110  20 Place
 actual                90  11 Place

 Type                 110 105 Place
 ArrayType            125 105 Place
 SetType              150 105 Place
 ObjectType           125  98 Place
   Brand               88  92 Place
   methodList         125  91 Place
   method             140  93 Place
   overrideList       127  85 Place
 ProcedureType        103  82 Place
 RecordType           150  88 Place
 RefType              116  77 Place
 PackedType           143  77 Place
 EnumerationType      153  72 Place
 SubrangeType         116  71 Place
 fields                87  86 Place
 field                 85  78 Place

 ConstExpression       76  58 Place
 Expression            86  65 Place
   e1                 101  65 Place
   e2                 117  65 Place
   e3                 129  65 Place
   e4                  93  59 Place
   e5                  98  50 Place
   e6                 120  59 Place
   e8                 153  59 Place
 Constructor           40  58 Place
    setCons            38  50 Place
    recordCons         60  50 Place
    arrayCons          79  50 Place

 ExceptionID            0  48 Place
 TypeID                17  50 Place

%
%  draw the title
%

/Times-Bold findfont
SCALE 9.5 mul scalefont
setfont
65 SCALE mul XSHRINK mul
99 SCALE mul YSHRINK mul moveto
(Modula-3) show

restore
showpage
% FlushPage

%%Trailer
end % Modula-3 dictionary 
%%EOF
