<HTML>
<HEAD>
<TITLE>SRC Modula-3: m3tk/src/pl/M3LProgContext.i3</TITLE>
</HEAD>
<BODY>
<A NAME="0TOP0">
<H2>m3tk/src/pl/M3LProgContext.i3</H2></A><HR>
<inInterface>
<PRE><A HREF="../../../COPYRIGHT.html">Copyright (C) 1994, Digital Equipment Corp.</A>

INTERFACE <interface><A HREF="M3LProgContext.m3.html">M3LProgContext</A></interface>;

IMPORT <A HREF="../toolmisc/M3Context.i3.html">M3Context</A>, <A HREF="../ast/M3AST_AS.i3.html">M3AST_AS</A>, <A HREF="../../DS/SeqM3AST_AS_Interface.i3.html">SeqM3AST_AS_Interface</A>;

PROCEDURE <A HREF="M3LProgContext.m3.html#Build">Build</A>(m: M3AST_AS.Module): M3Context.T RAISES {};
</PRE><BLOCKQUOTE><EM> This procedure enters all the units that go to make up
the program identified by 'm' into a new context, and returns
that as result. It assumes that the pl_dependson_s has already
been built. </EM></BLOCKQUOTE><PRE>

PROCEDURE <A HREF="M3LProgContext.m3.html#BuildC">BuildC</A>(c: M3Context.T; name: TEXT := NIL): M3Context.T RAISES {};
</PRE><BLOCKQUOTE><EM> First find the main program module in 'c' named 'name', or, if NIL, the 
first one on the list returned by 'M3LMain.Module'. Then compute the 
dependson relation, then call 'Build' to return an exact context. 
If there are no main program modules, return NIL. </EM></BLOCKQUOTE><PRE>

PROCEDURE <A HREF="M3LProgContext.m3.html#BuildPartial">BuildPartial</A>(
    c: M3Context.T;
    list: SeqM3AST_AS_Interface.T)
    : M3Context.T
    RAISES {};
</PRE><BLOCKQUOTE><EM> This is a more general procedure than 'BuildC'. First it
finds those modules that export the interfaces denoted by 'list'.
It then computes the dependson relation for these and then builds
a context from this. If 'list' contained a single entry 'Main', this call
would be equivalent to 'BuildC(c, <CODE>Main</CODE>); </EM></BLOCKQUOTE><PRE>

END M3LProgContext.
</PRE>
</inInterface>
<PRE>























</PRE>
</BODY>
</HTML>
