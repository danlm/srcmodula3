<HTML>
<HEAD>
<TITLE>SRC Modula-3: m3tk/src/target/M3CBackEnd_C.m3</TITLE>
</HEAD>
<BODY>
<A NAME="0TOP0">
<H2>m3tk/src/target/M3CBackEnd_C.m3</H2></A><HR>
<inModule>
<PRE></PRE>*************************************************************************
                      Copyright (C) Olivetti 1989                        
                          All Rights reserved                            
                                                                         
 Use and copy of this software and preparation of derivative works based 
 upon this software are permitted to any person, provided this same      
 copyright notice and the following Olivetti warranty disclaimer are      
 included in any copy of the software or any modification thereof or     
 derivative work therefrom made by any person.                           
                                                                         
 This software is made available AS IS and Olivetti disclaims all        
 warranties with respect to this software, whether expressed or implied  
 under any law, including all implied warranties of merchantibility and  
 fitness for any purpose. In no event shall Olivetti be liable for any   
 damages whatsoever resulting from loss of use, data or profits or       
 otherwise arising out of or in connection with the use or performance   
 of this software.                                                       
*************************************************************************

<PRE><A HREF="../../../COPYRIGHT.html">Copyright (C) 1994, Digital Equipment Corp.</A>

MODULE <module>M3CBackEnd_C</module>  EXPORTS <A HREF="../sem/M3CBackEnd.i3.html"><implements>M3CBackEnd</A></implements>, <A HREF="M3CBackEnd_C.i3.html"><implements>M3CBackEnd_C</A></implements>;
</PRE> This module defines the interface for the information required by
the compiler front-end from a back-end . 

<P> ToDo: all the bootstrap things like FIRST(REAL) 

<P> Version targeted to C back-end for a variety of machines 

<P><PRE>IMPORT <A HREF="../sem/M3CBackEnd.i3.html">M3CBackEnd</A>;
IMPORT <A HREF="../../../fmtlex/src/Fmt.i3.html">Fmt</A>, <A HREF="../../../text/src/Text.i3.html">Text</A>, <A HREF="../../../text/src/TextF.i3.html">TextF</A>, <A HREF="../../../rw/src/Common/TextRd.i3.html">TextRd</A>, <A HREF="../../../rw/src/Common/TextWr.i3.html">TextWr</A>, <A HREF="../../../rw/src/Common/Rd.i3.html">Rd</A>, <A HREF="../../../rw/src/Common/Wr.i3.html">Wr</A>, <A HREF="../../../word/src/Word.i3.html">Word</A>, <A HREF="../../../convert/src/Convert.i3.html">Convert</A>, <A HREF="../misc/RdExtras.i3.html">RdExtras</A>;
IMPORT <A HREF="../ast/M3AST_AS.i3.html">M3AST_AS</A>, <A HREF="../ast/M3AST_SM.i3.html">M3AST_SM</A>;

IMPORT <A HREF="../ast/M3AST_AS_F.i3.html">M3AST_AS_F</A>, <A HREF="../ast/M3AST_SM_F.i3.html">M3AST_SM_F</A>;

IMPORT <A HREF="../../DS/SeqM3AST_AS_RANGE_EXP.i3.html">SeqM3AST_AS_RANGE_EXP</A>, <A HREF="../../DS/SeqM3AST_AS_Fields.i3.html">SeqM3AST_AS_Fields</A>;

IMPORT <A HREF="../syn/M3CId.i3.html">M3CId</A>, <A HREF="../syn/M3CLiteral.i3.html">M3CLiteral</A>;
IMPORT <A HREF="../toolmisc/M3Error.i3.html">M3Error</A>, <A HREF="../misc/M3Assert.i3.html">M3Assert</A>, <A HREF="../syn/M3CSrcPos.i3.html">M3CSrcPos</A>;
IMPORT <A HREF="../sem/M3CStdProcs.i3.html">M3CStdProcs</A>, <A HREF="../sem/M3CWordProcs.i3.html">M3CWordProcs</A>;
IMPORT <A HREF="../sem/M3CExpValue.i3.html">M3CExpValue</A>, <A HREF="../sem/M3CTypesMisc.i3.html">M3CTypesMisc</A>, <A HREF="../sem/M3ASTNext.i3.html">M3ASTNext</A>;
FROM <A HREF="M3CBackEnd_C_cc.i3.html">M3CBackEnd_C_cc</A> IMPORT a32, a64, a16, a8, minAlignment, recAlignment,
  arrayAlignment, ptrA, ptrS, realA, realS, longRealA, longRealS, intA, intS;

IMPORT <A HREF="M3CBackEnd_Float_Real.i3.html">M3CBackEnd_Float_Real</A>, <A HREF="M3CBackEnd_Float_LongReal.i3.html">M3CBackEnd_Float_LongReal</A>,
    <A HREF="M3CBackEnd_Float_Extended.i3.html">M3CBackEnd_Float_Extended</A>;
</PRE> For FATAL 
<PRE>IMPORT <A HREF="../../../thread/src/Common/Thread.i3.html">Thread</A>;

&lt;*FATAL Thread.Alerted, Wr.Failure, Rd.Failure, Rd.EndOfFile, Convert.Failed *&gt;

CONST
  NilValue = 0;
  False = ORD(FALSE);
  True = ORD(TRUE);
</PRE> This does the alignments for ordinals. 
<PRE>PROCEDURE <A NAME="OrdAlign"><procedure>OrdAlign</procedure></A>(size: INTEGER): INTEGER RAISES {}=
  BEGIN
    IF size = 0 THEN
      RETURN 0
    ELSIF size &lt;= 8 THEN RETURN a8
    ELSIF size &lt;= 16 THEN RETURN a16
    ELSIF size &lt;= 32 THEN RETURN a32
    ELSE  RETURN a64

    END; (* if *)
  END OrdAlign;
</PRE> This does the alignments for sets. 
<PRE>PROCEDURE <A NAME="SetAlign"><procedure>SetAlign</procedure></A>(VAR (*inout*) size: INTEGER; exact: BOOLEAN): INTEGER =
  BEGIN
    IF NOT exact THEN (* represented as arrays of ints *)
      size := AlignTo(size, intS);
    END; (* if *)
    RETURN MAX(intA, recAlignment);
  END SetAlign;

PROCEDURE <A NAME="RegisterProcs"><procedure>RegisterProcs</procedure></A>() RAISES {}=
  BEGIN
    M3CBackEnd.LiteralValue:= LiteralValue_C;
    M3CBackEnd.ConstructorValue:= ConstructorValue_C;
    M3CBackEnd.ConstructorOriginal:= ConstructorOriginal_C;
    M3CBackEnd.IsOrdinal := IsOrdinal_C;
    M3CBackEnd.Ord:= Ord_C;
    M3CBackEnd.Val:= Val_C;
    M3CBackEnd.ConvertOrdinal := ConvertOrdinal_C;
    M3CBackEnd.BinaryOp:= BinaryOp_C;
    M3CBackEnd.InOp:= InOp_C;
    M3CBackEnd.UnaryOp:= UnaryOp_C;
    M3CBackEnd.StdUnaryOp:= StdUnaryOp_C;
    M3CBackEnd.StdBinaryOp:= StdBinaryOp_C;
    M3CBackEnd.StdUnaryTypeOp:= StdUnaryTypeOp_C;
    M3CBackEnd.WordOp := WordOp_C;
    M3CBackEnd.Compare:= Compare_C;
    M3CBackEnd.LoopholeOK:= LoopholeOK_C;
    M3CBackEnd.BitsOK:= BitsOK_C;
    M3CBackEnd.VarParamOK:= VarParamOK_C;
    M3CBackEnd.BitSizeAndAlign:= BitSizeAndAlign_C;
    M3CBackEnd.ExpValueToText := ExpValueToText_C;
    M3CBackEnd.TextToExpValue := TextToExpValue_C;
  END RegisterProcs;

&lt;*INLINE*&gt; PROCEDURE <A NAME="SimpleNewInteger_value"><procedure>SimpleNewInteger_value</procedure></A>(int: INTEGER): Integer_value RAISES {}=
  BEGIN
    RETURN NEW(Integer_value, sm_value := int);
  END SimpleNewInteger_value;

VAR
  smallIntegers_g := ARRAY [0..255] OF Integer_value {NIL, ..};
  firstInteger_g := SimpleNewInteger_value(FIRST(INTEGER));
  lastInteger_g := SimpleNewInteger_value(LAST(INTEGER));

PROCEDURE <A NAME="NewInteger_value"><procedure>NewInteger_value</procedure></A>(int: INTEGER): Integer_value RAISES {}=
  BEGIN
    IF FIRST(smallIntegers_g) &lt;= int AND int &lt;= LAST(smallIntegers_g) THEN
      WITH result = smallIntegers_g[int] DO
        IF result = NIL THEN result := SimpleNewInteger_value(int) END;
        RETURN result;
      END;
    ELSIF int = FIRST(INTEGER) THEN
      RETURN firstInteger_g;
    ELSIF int = LAST(INTEGER) THEN
      RETURN lastInteger_g;
    ELSE
      RETURN SimpleNewInteger_value(int);
    END;
  END NewInteger_value;

CONST
  BadBits = -1;

PROCEDURE <A NAME="SizeInBits"><procedure>SizeInBits</procedure></A>(ts: M3AST_SM.TYPE_SPEC_UNSET;
    exact := FALSE): INTEGER RAISES {}=
  BEGIN
    IF ts = NIL THEN
      RETURN BadBits
    ELSE
      MayBeExactBitSizeAndAlign(ts, exact);
      RETURN NARROW(ts, M3AST_AS.TYPE_SPEC).sm_bitsize;
    END;
  END SizeInBits;

PROCEDURE <A NAME="BitSizeAndAlign_C"><procedure>BitSizeAndAlign_C</procedure></A>(ts: M3AST_AS.TYPE_SPEC) RAISES {}=
  BEGIN
    MayBeExactBitSizeAndAlign(ts);
  END BitSizeAndAlign_C;

PROCEDURE <A NAME="MayBeExactBitSizeAndAlign"><procedure>MayBeExactBitSizeAndAlign</procedure></A>(ts: M3AST_AS.TYPE_SPEC;
    exact := FALSE) RAISES {}=
  VAR
    array_element, array_index: M3AST_SM.TYPE_SPEC_UNSET;
    size, align: INTEGER;
    s1, s2: INTEGER;
    isopen: BOOLEAN;
  BEGIN
    size := 0; align := 0;

    TYPECASE ts OF &lt;*NOWARN*&gt;
    | M3AST_AS.Ref_type,
      M3AST_AS.RefAny_type,
      M3AST_AS.Root_type,
      M3AST_AS.Address_type,
      M3AST_AS.Null_type,
      M3AST_AS.Opaque_type,
      M3AST_AS.Procedure_type =&gt;
        size := ptrS;
        align := ptrA;

    | M3AST_AS.Integer_type =&gt;
        size := intS;
        align := intA;

    | M3AST_AS.Real_type =&gt;
        size := realS;
        align := realA;

    | M3AST_AS.LongReal_type, M3AST_AS.Extended_type =&gt;
        size := longRealS;
        align := longRealA;

    | M3AST_AS.Enumeration_type(t) =&gt;
        size := BitsForOrd(t.sm_num_elements-1, exact);
        align := OrdAlign(size);

    | M3AST_AS.Subrange_type(t) =&gt;
        WITH range = t.as_range DO
          s1 := NARROW(range.as_exp1.sm_exp_value, Integer_value).sm_value;
          s2 := NARROW(range.as_exp2.sm_exp_value, Integer_value).sm_value;
        END;
        IF s1 &lt;= s2 THEN
          IF s1 &gt;= 0 THEN
            size := BitsForOrd(s2, exact);
          ELSE
            IF s2 &lt; 0 THEN s2 := 0; END;
            size := 1 + MAX(BitsForOrd(-(s1+1), TRUE), BitsForOrd(s2, TRUE));
            IF NOT exact THEN size := ChooseByteHalfFull(size); END;
          END;
        END; (* if *)
        align := OrdAlign(size);

    | M3AST_AS.Set_type(t) =&gt;
        GetSetBounds(t, s1, s2);
        IF s1 &lt;= s2 THEN
          size := 1 + s2 - s1;
        END; (* if *)
        align := SetAlign(size, exact);

    | M3AST_AS.Packed_type(t) =&gt;
        (* the check for legality is done elsewhere *)
        size := NARROW(t.as_exp.sm_exp_value, Integer_value).sm_value;
        align := 1;

    | M3AST_AS.Record_type(t) =&gt;
        FieldsSizeAndAlign(t.as_fields_s, size, align);

    | M3AST_AS.Object_type(object_type) =&gt;
        (* compute in place in case of self-reference *)
        size := ptrS; ts.sm_bitsize := size;
        align :=  ptrA; ts.sm_align := align;
        (* compute the referent size and alignment (for this component
        of the object; i.e. ignore supertypes). *)
        object_type.sm_rf_bitsize := 0;
        object_type.sm_rf_align := 0;
        FieldsSizeAndAlign(object_type.as_fields_s,
            object_type.sm_rf_bitsize, object_type.sm_rf_align);

    | M3AST_AS.Array_type(t) =&gt;
        EVAL M3ASTNext.Array(t, array_element, isopen, array_index);
        WITH elemTS = NARROW(array_element, M3AST_AS.TYPE_SPEC) DO
          align := MAX(elemTS.sm_align, arrayAlignment);
          IF isopen THEN
            (* leave size at 0 *)
          ELSE
            VAR
              low, high: M3AST_SM.Exp_value;
              s1, s2: INTEGER;
            BEGIN
              IF M3CExpValue.GetBounds(array_index, low, high) =
                    M3CBackEnd.NumStatus.Valid THEN
                s1 := NARROW(low, Integer_value).sm_value;
                s2 := NARROW(high, Integer_value).sm_value;
                IF s1 &lt;= s2 THEN
                  size :=
                      AlignTo(elemTS.sm_bitsize, elemTS.sm_align) * (s2-s1+1);
                END;
              END;
            END;
          END;
        END;
    END; (* case *)

    ts.sm_bitsize := size;
    ts.sm_align := align;
  END MayBeExactBitSizeAndAlign;

PROCEDURE <A NAME="FieldsSizeAndAlign"><procedure>FieldsSizeAndAlign</procedure></A>(fields: SeqM3AST_AS_Fields.T;
    VAR (*inout*) size, align: INTEGER) RAISES {}=
  VAR
    field_id: M3AST_AS.Field_id;
    iter := M3ASTNext.NewIterField(fields);
  BEGIN
    WHILE M3ASTNext.Field(iter, field_id) DO
      size := AlignTo(size, field_id.sm_type_spec.sm_align);
      INC(size, field_id.sm_type_spec.sm_bitsize);
      align := MAX(align, field_id.sm_type_spec.sm_align);
    END;
    align := MAX(align, recAlignment);
  END FieldsSizeAndAlign;

PROCEDURE <A NAME="LiteralValue_C"><procedure>LiteralValue_C</procedure></A>(lit: M3AST_AS.EXP;
    VAR (*out*) er: M3AST_SM.Exp_value): M3CBackEnd.NumStatus RAISES {}=
  BEGIN
    TYPECASE lit OF &lt;*NOWARN*&gt;
    | M3AST_AS.Char_literal =&gt;
        (* 'x' or '\x' or '\ddd' *)
        VAR
          cvi: INTEGER;
          t: TEXT := M3CLiteral.ToText(
              NARROW(lit, M3AST_AS.Char_literal).lx_litrep);
        BEGIN
          IF Text.GetChar(t, 1) = '\\' THEN
            (* escape *)
            CASE Text.GetChar(t, 2) OF
            | 'n' =&gt; cvi := ORD('\n');
            | 't' =&gt; cvi := ORD('\t');
            | 'r' =&gt; cvi := ORD('\r');
            | '\'' =&gt; cvi := ORD('\'');
            | '\&quot;' =&gt; cvi := ORD('\&quot;');
            | 'f' =&gt; cvi := ORD('\f');
            | '\\' =&gt; cvi := ORD('\\');
            ELSE  (* \ddd *)
              cvi := CHV(Text.GetChar(t, 2)) * 64 +
                     CHV(Text.GetChar(t, 3)) * 8 +
                     CHV(Text.GetChar(t, 4));
            END; (* case *)
          ELSE
            cvi := ORD(Text.GetChar(t, 1));
          END; (* if *)
          er := NewInteger_value(cvi);
        END;

    | M3AST_AS.Text_literal =&gt;
        VAR tv := NEW(Text_value);
            t: TEXT := M3CLiteral.ToText(
                NARROW(lit, M3AST_AS.Text_literal).lx_litrep);
        BEGIN
          er := tv;
          tv.sm_value := Text.Sub(t, 1, Text.Length(t) - 2);
        END;

    | M3AST_AS.Nil_literal =&gt;
        er := NewInteger_value(NilValue);

    | M3AST_AS.Integer_literal =&gt;
        VAR
          t: TEXT := M3CLiteral.ToText(
              NARROW(lit, M3AST_AS.Integer_literal).lx_litrep);
          int: INTEGER;
        BEGIN
          IF NOT TextTo_Int(t, int) THEN
            RETURN M3CBackEnd.NumStatus.Overflow;
          END;
          er := NewInteger_value(int);
        END;

    | M3AST_AS.Real_literal =&gt;
        VAR
	  real: REAL;
	  t := M3CLiteral.ToText(NARROW(lit, M3AST_AS.Real_literal).lx_litrep);
        BEGIN
          IF NOT TextTo_Real(t, real) THEN
            RETURN M3CBackEnd.NumStatus.Overflow;
          END;
          er := M3CBackEnd_Float_Real.New_value(real);
        END;

    | M3AST_AS.LongReal_literal =&gt;
        VAR
	  longReal: LONGREAL;
	  t := M3CLiteral.ToText(
              NARROW(lit, M3AST_AS.LongReal_literal).lx_litrep);
        BEGIN
          IF NOT TextTo_LongReal(t, longReal) THEN
            RETURN M3CBackEnd.NumStatus.Overflow;
          END;
          er := M3CBackEnd_Float_LongReal.New_value(longReal)
        END;

    | M3AST_AS.Extended_literal =&gt;
        VAR
	  extended: EXTENDED;
	  t := M3CLiteral.ToText(
              NARROW(lit, M3AST_AS.Extended_literal).lx_litrep);
        BEGIN
          IF NOT TextTo_Extended(t, extended) THEN
            RETURN M3CBackEnd.NumStatus.Overflow;
          END;
          er := M3CBackEnd_Float_Extended.New_value(extended)
        END;

    | M3AST_AS.Exp_used_id, M3AST_AS.Select =&gt;
        (* procedure constants *)
        VAR
          idp, idu: M3AST_AS.Exp_used_id;
          pv := NEW(Proc_value);
        BEGIN
          er := pv;
          IF ISTYPE(lit, M3AST_AS.Select) THEN
            idp := NARROW(lit, M3AST_AS.Select).as_id;
            idu := NARROW(lit, M3AST_AS.Select).as_exp;
          ELSE
            idp := lit; idu := NIL;
          END; (* if *)
          pv.sm_value := M3CId.ToText(idp.vUSED_ID.lx_symrep);
          IF idu # NIL THEN
            pv.sm_value := M3CId.ToText(idu.vUSED_ID.lx_symrep) &amp; Separator &amp;
              pv.sm_value;
          END; (* if *)
        END;
    END; (* case *)
    RETURN M3CBackEnd.NumStatus.Valid;
  END LiteralValue_C;

&lt;*INLINE*&gt; PROCEDURE <A NAME="CHV"><procedure>CHV</procedure></A>(ch: CHAR): INTEGER RAISES {}=
  BEGIN
    RETURN ORD(ch) - ORD('0');
  END CHV;

PROCEDURE <A NAME="GetSetBounds"><procedure>GetSetBounds</procedure></A>(s: M3AST_AS.Set_type; VAR low, high: INTEGER) RAISES {}=
  VAR
    baseType: M3AST_SM.TYPE_SPEC_UNSET;
    l, h: M3AST_SM.Exp_value;
  BEGIN
    M3CTypesMisc.GetTYPE_SPECFromM3TYPE(s.as_type, baseType);
    M3Assert.Check(
        M3CExpValue.GetBounds(baseType, l, h) = M3CBackEnd.NumStatus.Valid);
    low := NARROW(l, Integer_value).sm_value;
    high := NARROW(h, Integer_value).sm_value;
  END GetSetBounds;

PROCEDURE <A NAME="ConstructorValue_C"><procedure>ConstructorValue_C</procedure></A>(
    cons: M3AST_AS.Constructor;
    VAR (*out*) er: M3AST_SM.Exp_value)
    : M3CBackEnd.NumStatus
    RAISES {}=
  BEGIN
    TYPECASE M3CTypesMisc.CheckedUnpack(cons.sm_exp_type_spec) OF &lt;*NOWARN*&gt;
    | M3AST_AS.Set_type(setType) =&gt;
        VAR
          cv := NEW(Set_constructor_value);
          s1, s2: INTEGER;
        BEGIN
          GetSetBounds(setType, s1, s2);
          cv.sm_low := s1;
          cv.sm_value := NEW(REF ARRAY OF INTEGER,
              (setType.sm_bitsize + Word.Size - 1) DIV Word.Size);
          FOR i := 0 TO LAST(cv.sm_value^) DO
            cv.sm_value[i] := 0;
          END;
          VAR
            iterActuals := SeqM3AST_AS_RANGE_EXP.NewIter(cons.sm_actual_s);
            actual: M3AST_AS.RANGE_EXP;
            lowBit, highBit: INTEGER;
          BEGIN
            WHILE SeqM3AST_AS_RANGE_EXP.Next(iterActuals, actual) DO
              TYPECASE actual OF &lt;*NOWARN*&gt;
              | M3AST_AS.Range_EXP(rExp) =&gt;
                  lowBit := NARROW(
                      rExp.as_exp.sm_exp_value, Integer_value).sm_value;
                  highBit := lowBit;
              | M3AST_AS.Range(range) =&gt;
                  lowBit := NARROW(
                      range.as_exp1.sm_exp_value, Integer_value).sm_value;
                  highBit := NARROW(
                      range.as_exp2.sm_exp_value, Integer_value).sm_value;
              END;
              DEC(lowBit, s1);
              DEC(highBit, s1);
              FOR setbit := lowBit TO highBit DO
                WITH w = cv.sm_value[setbit DIV Word.Size] DO
                  w := Word.Or(w, Word.Shift(1, setbit MOD Word.Size));
                END;
              END;
            END;
          END;
          er := cv;
        END;
    | M3AST_AS.Record_type, M3AST_AS.Array_type =&gt;
        VAR
          cv := NEW(Array_or_record_constructor_value);
        BEGIN
          cv.sm_constructor := cons;
          er := cv;
        END;
    END;
    RETURN M3CBackEnd.NumStatus.Valid;
  END ConstructorValue_C;

PROCEDURE <A NAME="ConstructorOriginal_C"><procedure>ConstructorOriginal_C</procedure></A>(
    e: M3AST_SM.Exp_value)
    : M3AST_AS.Constructor
    RAISES {}=
  BEGIN
    TYPECASE e OF &lt;*NOWARN*&gt;
    | Array_or_record_constructor_value(cv) =&gt;
        RETURN cv.sm_constructor;
    END; (* typecase *)
  END ConstructorOriginal_C;

PROCEDURE <A NAME="IsOrdinal_C"><procedure>IsOrdinal_C</procedure></A>(e: M3AST_SM.Exp_value): BOOLEAN RAISES {}=
  BEGIN
    RETURN e # NIL AND ISTYPE(e, Integer_value);
  END IsOrdinal_C;

PROCEDURE <A NAME="Val_C"><procedure>Val_C</procedure></A>(n: INTEGER;
                &lt;*UNUSED*&gt; ts: M3AST_SM.TYPE_SPEC_UNSET;
    VAR (*out*) er: M3AST_SM.Exp_value): M3CBackEnd.NumStatus RAISES {}=
  BEGIN
    (* ORD(n) = n for all types *)
    er := NewInteger_value(n);
    RETURN M3CBackEnd.NumStatus.Valid;
  END Val_C;

PROCEDURE <A NAME="Ord_C"><procedure>Ord_C</procedure></A>(
    e: M3AST_SM.Exp_value;
    VAR (*out*) i: INTEGER)
    : M3CBackEnd.NumStatus
    RAISES {}=
  BEGIN
    TYPECASE e OF &lt;*NOWARN*&gt;
    | Integer_value(iv) =&gt;
        i := iv.sm_value;
        RETURN M3CBackEnd.NumStatus.Valid;
    END;
  END Ord_C;

PROCEDURE <A NAME="ConvertOrdinal_C"><procedure>ConvertOrdinal_C</procedure></A>(
    e: M3AST_SM.Exp_value;
    &lt;*UNUSED*&gt; ts: M3AST_AS.TYPE_SPEC;
    VAR (* out *) er: M3AST_SM.Exp_value)
    : M3CBackEnd.NumStatus
    RAISES {}=
  BEGIN
    er := e;
    RETURN M3CBackEnd.NumStatus.Valid;
  END ConvertOrdinal_C;

PROCEDURE <A NAME="BinaryOp_C"><procedure>BinaryOp_C</procedure></A>(op: M3AST_AS.BINARY; e1, e2: M3AST_SM.Exp_value;
    VAR (*out*) er: M3AST_SM.Exp_value): M3CBackEnd.NumStatus RAISES {}=
  BEGIN
    (* Compatibility check *)
    IF TYPECODE(e1) # TYPECODE(e2) THEN
      RETURN M3CBackEnd.NumStatus.Unknown;
    END;
    (* Now the real work, computing values *)
    TYPECASE e2 OF
    | Integer_value(integerValue2) =&gt;
        VAR
          integerValue1 := NARROW(e1, Integer_value);
          int1 := integerValue1.sm_value;
          int2 := integerValue2.sm_value;
          intr: INTEGER;
        BEGIN
          TYPECASE op OF &lt;*NOWARN*&gt;
          | M3AST_AS.Plus =&gt; intr := int1 + int2;
          | M3AST_AS.Minus =&gt; intr := int1 - int2;
          | M3AST_AS.Times =&gt; intr := int1 * int2;
          | M3AST_AS.Div =&gt;
              IF int2 = 0 THEN RETURN M3CBackEnd.NumStatus.Overflow END;
              intr := int1 DIV int2;
          | M3AST_AS.Mod =&gt;
              IF int2 = 0 THEN RETURN M3CBackEnd.NumStatus.Overflow END;
              intr := int1 MOD int2;
          | M3AST_AS.Eq =&gt; intr := ORD(int1 = int2);
          | M3AST_AS.Ne =&gt; intr := ORD(int1 # int2);
          | M3AST_AS.Gt =&gt; intr := ORD(int1 &gt; int2);
          | M3AST_AS.Lt =&gt; intr := ORD(int1 &lt; int2);
          | M3AST_AS.Ge =&gt; intr := ORD(int1 &gt;= int2);
          | M3AST_AS.Le =&gt; intr := ORD(int1 &lt;= int2);
          | M3AST_AS.And =&gt;
              intr := ORD((int1 = True) AND (int2 = True));
          | M3AST_AS.Or =&gt;
              intr := ORD((int1 = True) OR (int2 = True));
          ELSE RETURN M3CBackEnd.NumStatus.Unknown;
          END; (* case *)
          IF intr = int1 THEN
            er := integerValue1;
          ELSIF intr = int2 THEN
            er := integerValue2;
          ELSE
            er := NewInteger_value(intr);
          END;
        END;

    | Text_value(textValue2) =&gt;
        VAR
          tv := NEW(Text_value);
        BEGIN
          IF ISTYPE(op, M3AST_AS.Textcat) THEN
            er := tv;
            tv.sm_value :=
                NARROW(e1, Text_value).sm_value &amp; textValue2.sm_value;
          ELSE
            RETURN M3CBackEnd.NumStatus.Unknown;
          END;
        END;

    | Real_value(rv2) =&gt;
        RETURN M3CBackEnd_Float_Real.BinaryOp(op,
                                              NARROW(e1, Real_value), rv2, er);

    | LongReal_value(lrv2) =&gt;
        RETURN M3CBackEnd_Float_LongReal.BinaryOp(op,
            NARROW(e1, LongReal_value), lrv2, er);

    | Extended_value(ev2) =&gt;
        RETURN M3CBackEnd_Float_Extended.BinaryOp(op,
            NARROW(e1, Extended_value), ev2, er);

    | Set_constructor_value(c2) =&gt;
        VAR
          c1 := NARROW(e1, Set_constructor_value);
        BEGIN
          IF NUMBER(c1.sm_value^) # NUMBER(c2.sm_value^) THEN
            RETURN M3CBackEnd.NumStatus.Unknown;
          END;
          TYPECASE op OF &lt;*NOWARN*&gt;
          | M3AST_AS.Plus,
            M3AST_AS.Minus,
            M3AST_AS.Times,
            M3AST_AS.Rdiv =&gt;
              (* All return set as result *)
              VAR
                cv := NEW(Set_constructor_value);
              BEGIN
                cv.sm_value := NEW(REF ARRAY OF INTEGER, NUMBER(c1.sm_value^));
                er := cv;
                FOR i := 0 TO LAST(c1.sm_value^) DO
                  WITH w = cv.sm_value[i] DO
                    VAR
                      w1 := c1.sm_value[i];
                      w2 := c2.sm_value[i];
                    BEGIN
                      TYPECASE op OF &lt;*NOWARN*&gt;
                      | M3AST_AS.Plus =&gt;
                          w := Word.Or(w1, w2);
                      | M3AST_AS.Minus =&gt;
                         w := Word.And(w1, Word.Not(w2));
                      | M3AST_AS.Times =&gt;
                          w := Word.And(w1, w2);
                      | M3AST_AS.Rdiv =&gt;
                          w := Word.Xor(w1, w2);
                      END; (* case *)
                    END;
                  END; (* with *)
                END; (* for *)
              END;

          | M3AST_AS.Eq, M3AST_AS.Ne,
            M3AST_AS.Le, M3AST_AS.Ge,
            M3AST_AS.Lt, M3AST_AS.Gt =&gt;
              (* All return booleans. The following is not very efficient but
               who cares? It won't get executed very often. *)
              VAR
                result: BOOLEAN;
              BEGIN
                IF Compare(c1, c2) = 0 THEN
                  (* Equal *)
                  TYPECASE op OF &lt;*NOWARN*&gt;
                  | M3AST_AS.Eq, M3AST_AS.Le, M3AST_AS.Ge =&gt;
                      result := TRUE;
                  | M3AST_AS.Ne, M3AST_AS.Lt, M3AST_AS.Gt =&gt;
                      result := FALSE;
                  END;
                ELSE
                  (* Not equal *)
                  TYPECASE op OF
                  | M3AST_AS.Eq =&gt;
                      result := FALSE;
                  | M3AST_AS.Ne =&gt;
                      result := TRUE;
                  ELSE
                    IF ISTYPE(op, M3AST_AS.Le) OR
		       ISTYPE(op, M3AST_AS.Lt) THEN
                      VAR
                        temp := c1;
                      BEGIN
                        c1 := c2; c2 := temp;
                      END;
                    END;
                    result := TRUE;
                    FOR i := 0 TO LAST(c1.sm_value^) DO
                      VAR
                        elem1 := c1.sm_value[i];
                      BEGIN
                        IF elem1 # Word.Or(elem1, c2.sm_value[i]) THEN
                          result := FALSE;
                          EXIT;
                        END;
                      END;
                    END;
                  END;
                END;
                er := NewInteger_value(ORD(result));
              END;
          END; (* case *)
        END; (* begin *)

    ELSE
      RETURN NotImplemented();
    END; (* case *)

    RETURN M3CBackEnd.NumStatus.Valid;
  END BinaryOp_C;

PROCEDURE <A NAME="InOp_C"><procedure>InOp_C</procedure></A>(e1, e2: M3AST_SM.Exp_value;
    VAR (*out*) er: M3AST_SM.Exp_value): M3CBackEnd.NumStatus RAISES {}=
  VAR
    int := NARROW(e1, Integer_value).sm_value;
    set := NARROW(e2, Set_constructor_value);
    bool: BOOLEAN;
  BEGIN
    WITH i = int - set.sm_low, s = set.sm_value DO
      bool := Word.Extract(s[i DIV Word.Size], i MOD Word.Size, 1) # 0;
    END;
    er := NewInteger_value(ORD(bool));
    RETURN M3CBackEnd.NumStatus.Valid;
  END InOp_C;

PROCEDURE <A NAME="UnaryOp_C"><procedure>UnaryOp_C</procedure></A>(op: M3AST_AS.UNARY; e: M3AST_SM.Exp_value;
    VAR (*out*) er: M3AST_SM.Exp_value): M3CBackEnd.NumStatus RAISES {}=
  BEGIN
    TYPECASE e OF
    | Integer_value(eiv) =&gt;
        VAR
          intr: INTEGER;
        BEGIN
          TYPECASE op OF
          | M3AST_AS.Unaryplus =&gt;
              intr := eiv.sm_value;
          | M3AST_AS.Unaryminus =&gt;
              intr := -eiv.sm_value;
          | M3AST_AS.Not =&gt;
              intr := ORD(eiv.sm_value = False);
          ELSE
            RETURN M3CBackEnd.NumStatus.Unknown;
          END; (* case *)
          er := NewInteger_value(intr);
        END;

    | Real_value(rv) =&gt;
        RETURN M3CBackEnd_Float_Real.UnaryOp(op, rv, er);

    | LongReal_value(lrv) =&gt;
        RETURN M3CBackEnd_Float_LongReal.UnaryOp(op, lrv, er);

    | Extended_value(ev) =&gt;
        RETURN M3CBackEnd_Float_Extended.UnaryOp(op, ev, er);

    ELSE
      RETURN M3CBackEnd.NumStatus.Unknown;
    END; (* case *)
    RETURN M3CBackEnd.NumStatus.Valid;
  END UnaryOp_C;

PROCEDURE <A NAME="StdUnaryOp_C"><procedure>StdUnaryOp_C</procedure></A>(f: M3CStdProcs.Func;
    e: M3AST_SM.Exp_value;
    VAR (*out*) er: M3AST_SM.Exp_value;
    ft: M3AST_AS.FLOAT_TYPE := NIL): M3CBackEnd.NumStatus RAISES {}=
  BEGIN
    TYPECASE e OF
    | Integer_value(eiv) =&gt;
        VAR
          eint: INTEGER := eiv.sm_value;
        BEGIN
          CASE f OF
          | M3CStdProcs.T.Abs =&gt;
              IF eint &lt; 0 THEN eint := -eint; END; (* if *)
              er := NewInteger_value(eint);
          | M3CStdProcs.T.Float =&gt;
              TYPECASE ft OF &lt;*NOWARN*&gt;
              | M3AST_AS.Real_type =&gt;
  	          er := M3CBackEnd_Float_Real.New_value(FLOAT(eint));
              | M3AST_AS.LongReal_type =&gt;
                  er := M3CBackEnd_Float_LongReal.New_value(FLOAT(eint, LONGREAL));
              | M3AST_AS.Extended_type =&gt;
                  er := M3CBackEnd_Float_Extended.New_value(FLOAT(eint, EXTENDED));
              END; (* typecase *)
	  ELSE
            RETURN NotImplemented();
          END; (* case *)
        END;

    | Real_value(rv) =&gt;
        RETURN M3CBackEnd_Float_Real.StdUnaryOp(f, rv, er, ft);

    | LongReal_value(lrv) =&gt;
        RETURN M3CBackEnd_Float_LongReal.StdUnaryOp(f, lrv, er, ft);

    | Extended_value(ev) =&gt;
        RETURN M3CBackEnd_Float_Extended.StdUnaryOp(f, ev, er, ft);
    ELSE
      RETURN NotImplemented();
    END; (* case *)
    RETURN M3CBackEnd.NumStatus.Valid;
  END StdUnaryOp_C;

PROCEDURE <A NAME="StdBinaryOp_C"><procedure>StdBinaryOp_C</procedure></A>(f: M3CStdProcs.Func;
    e1, e2: M3AST_SM.Exp_value;
    VAR (*out*) er: M3AST_SM.Exp_value): M3CBackEnd.NumStatus RAISES {}=
  BEGIN
    IF TYPECODE(e1) # TYPECODE(e2) THEN RETURN
      M3CBackEnd.NumStatus.Unknown;
    END;
    TYPECASE e1 OF
    | Integer_value(eiv1) =&gt;
        VAR
          eiv2 := NARROW(e2, Integer_value);
        BEGIN
          CASE f OF &lt;*NOWARN*&gt;
          | M3CStdProcs.T.Min =&gt;
              IF eiv1.sm_value &lt; eiv2.sm_value THEN
                er := eiv1;
              ELSE
                er := eiv2;
              END;
          | M3CStdProcs.T.Max =&gt;
              IF eiv1.sm_value &gt; eiv2.sm_value THEN
                er := eiv1;
              ELSE
                er := eiv2;
              END;
          END; (* case *)
        END;

    | Real_value(rv1) =&gt;
        RETURN M3CBackEnd_Float_Real.StdBinaryOp(f, rv1,
            NARROW(e2, Real_value), er);

    | LongReal_value(lrv1) =&gt;
        RETURN M3CBackEnd_Float_LongReal.StdBinaryOp(f, lrv1,
            NARROW(e2, LongReal_value), er);

    | Extended_value(ev1) =&gt;
        RETURN M3CBackEnd_Float_Extended.StdBinaryOp(f, ev1,
            NARROW(e2, Extended_value), er);

    ELSE
      RETURN NotImplemented();
    END; (* case *)
    RETURN M3CBackEnd.NumStatus.Valid;
  END StdBinaryOp_C;

PROCEDURE <A NAME="StdUnaryTypeOp_C"><procedure>StdUnaryTypeOp_C</procedure></A>(
    pf: M3CStdProcs.Func;
    ts: M3AST_SM.TYPE_SPEC_UNSET;
    VAR (*out*) er: M3AST_SM.Exp_value): M3CBackEnd.NumStatus RAISES {}=
  VAR
    eint: INTEGER;
  BEGIN
    CASE pf OF
    | M3CStdProcs.T.BitSize =&gt;
        eint := SizeInBits(ts);
    | M3CStdProcs.T.ByteSize,
      M3CStdProcs.T.AdrSize =&gt;
        eint := RoundToByte(SizeInBits(ts));
    | M3CStdProcs.T.First =&gt;
        TYPECASE ts OF &lt;*NOWARN*&gt;
        | M3AST_AS.Integer_type =&gt;
            eint := FIRST(INTEGER);
        | M3AST_AS.Real_type =&gt;
        | M3AST_AS.LongReal_type =&gt;
        | M3AST_AS.Extended_type =&gt;
        END; (* typecase *)
    | M3CStdProcs.T.Last =&gt;
        TYPECASE ts OF &lt;*NOWARN*&gt;
        | M3AST_AS.Integer_type =&gt;
            eint := LAST(INTEGER);
        | M3AST_AS.Real_type =&gt;
        | M3AST_AS.LongReal_type =&gt;
        | M3AST_AS.Extended_type =&gt;
        END; (* typecase *)
    ELSE
      RETURN NotImplemented();
    END; (* case *)
    er := NewInteger_value(eint);
    RETURN M3CBackEnd.NumStatus.Valid;
  END StdUnaryTypeOp_C;

PROCEDURE <A NAME="RoundToByte"><procedure>RoundToByte</procedure></A>(n: INTEGER): INTEGER RAISES {}=
  CONST
    BitsInByte = 8;
  VAR er: INTEGER;
  BEGIN
    er := n DIV BitsInByte;
    IF (n MOD BitsInByte) # 0 THEN
      INC(er);
    END; (* if *)
    RETURN er;
  END RoundToByte;

PROCEDURE <A NAME="WordOp_C"><procedure>WordOp_C</procedure></A>(
    w: M3CWordProcs.T;
    READONLY args: ARRAY OF M3AST_SM.Exp_value;
    VAR (* out *) er: M3AST_SM.Exp_value)
    : M3CBackEnd.NumStatus
    RAISES {}=
  VAR
    res: Word.T;
    arg0 := NARROW(args[0], Integer_value).sm_value;
  BEGIN
    IF w = M3CWordProcs.T.Not THEN
      res := Word.Not(arg0);
    ELSE
      VAR
        arg1 := NARROW(args[1], Integer_value).sm_value;
      BEGIN
        CASE w OF &lt;*NOWARN*&gt;
        | M3CWordProcs.T.Plus =&gt;
            res := Word.Plus(arg0, arg1);
        | M3CWordProcs.T.Times =&gt;
            res := Word.Times(arg0, arg1);
        | M3CWordProcs.T.Minus =&gt;
            res := Word.Minus(arg0, arg1);
        | M3CWordProcs.T.Divide =&gt;
            res := Word.Divide(arg0, arg1);
        | M3CWordProcs.T.Mod =&gt;
            res := Word.Mod(arg0, arg1);
        | M3CWordProcs.T.LT =&gt;
            res := ORD(Word.LT(arg0, arg1));
        | M3CWordProcs.T.LE =&gt;
            res := ORD(Word.LE(arg0, arg1));
        | M3CWordProcs.T.GT =&gt;
            res := ORD(Word.GT(arg0, arg1));
        | M3CWordProcs.T.GE =&gt;
            res := ORD(Word.GE(arg0, arg1));
        | M3CWordProcs.T.And =&gt;
            res := Word.And(arg0, arg1);
        | M3CWordProcs.T.Or =&gt;
            res := Word.Or(arg0, arg1);
        | M3CWordProcs.T.Xor =&gt;
            res := Word.Xor(arg0, arg1);
        | M3CWordProcs.T.Shift =&gt;
            res := Word.Shift(arg0, arg1);
        | M3CWordProcs.T.RightShift =&gt;
            res := Word.RightShift(arg0, arg1);
        | M3CWordProcs.T.Rotate =&gt;
            res := Word.Rotate(arg0, arg1);
        | M3CWordProcs.T.RightRotate =&gt;
            res := Word.RightRotate(arg0, arg1);
        | M3CWordProcs.T.Extract =&gt;
            VAR
              arg2 := NARROW(args[2], Integer_value).sm_value;
            BEGIN
              IF arg1 &lt; 0 OR arg2 &lt; 0 OR arg1 + arg2 &gt; Word.Size THEN
                RETURN M3CBackEnd.NumStatus.Unknown;
              END;
              res := Word.Extract(arg0, arg1, arg2);
            END;
        | M3CWordProcs.T.Insert =&gt;
            VAR
              arg2 := NARROW(args[2], Integer_value).sm_value;
              arg3 := NARROW(args[3], Integer_value).sm_value;
            BEGIN
              IF arg2 &lt; 0 OR arg3 &lt; 0 OR arg2 + arg3 &gt; Word.Size THEN
                RETURN M3CBackEnd.NumStatus.Unknown;
              END;
              res := Word.Insert(arg0, arg1, arg2, arg3);
            END;
        END;
      END;
    END;
    er := NewInteger_value(res);
    RETURN M3CBackEnd.NumStatus.Valid;
  END WordOp_C;

PROCEDURE <A NAME="LoopholeOK_C"><procedure>LoopholeOK_C</procedure></A>(&lt;*UNUSED*&gt; e: M3AST_AS.EXP;
    &lt;*UNUSED*&gt; ts: M3AST_AS.TYPE_SPEC): BOOLEAN RAISES {}=
  BEGIN
    RETURN TRUE; (* no extra prohibitions *)
  END LoopholeOK_C;

PROCEDURE <A NAME="AlignTo"><procedure>AlignTo</procedure></A>(size, align: CARDINAL): INTEGER RAISES {}=
  VAR
    rem: CARDINAL;
  BEGIN
    IF align = 0 THEN RETURN size END;
    rem := size MOD align;
    IF rem = 0 THEN
      RETURN size
    ELSE
      RETURN size - rem + align;
    END; (* if *)
  END AlignTo;

PROCEDURE <A NAME="BitsForOrd"><procedure>BitsForOrd</procedure></A>(n: INTEGER; exact := FALSE): CARDINAL RAISES {}=
  VAR i, c: CARDINAL;
  BEGIN
    IF n &lt;= 0 THEN RETURN 0 END;
    i := 0;
    c := n;
    WHILE c # 0 DO
      INC(i); c := c DIV 2;
    END; (* while *)
    IF NOT exact THEN
      i := ChooseByteHalfFull(i);
    END;
    RETURN i;
  END BitsForOrd;

PROCEDURE <A NAME="ChooseByteHalfFull"><procedure>ChooseByteHalfFull</procedure></A>(i: INTEGER): INTEGER=
  BEGIN
    IF i &lt;= 8 THEN i := 8
    ELSIF i &lt;= 16 THEN i := 16;
    ELSE i := AlignTo(i, 32);
    END; (* if *)
    RETURN i;
  END ChooseByteHalfFull;

PROCEDURE <A NAME="BitsOK_C"><procedure>BitsOK_C</procedure></A>(e: M3AST_AS.EXP;
    ts: M3AST_AS.TYPE_SPEC): BOOLEAN RAISES {}=
  VAR tts: M3AST_SM.TYPE_SPEC_UNSET;
  BEGIN
    M3Assert.Check(ISTYPE(e.sm_exp_value, Integer_value));
    tts := ts;
    RETURN SizeInBits(tts, exact := TRUE) &lt;=
           NARROW(e.sm_exp_value, Integer_value).sm_value;
  END BitsOK_C;

PROCEDURE <A NAME="VarParamOK_C"><procedure>VarParamOK_C</procedure></A>(ts: M3AST_AS.TYPE_SPEC): BOOLEAN RAISES {}=
  BEGIN
    RETURN ts.sm_align MOD minAlignment = 0;
  END VarParamOK_C;

PROCEDURE <A NAME="Compare_C"><procedure>Compare_C</procedure></A>(e1, e2: M3AST_SM.Exp_value): INTEGER RAISES {}=
  BEGIN
    TYPECASE e1 OF
    | Integer_value(eiv1) =&gt;
        TYPECASE e2 OF
        | Integer_value(eiv2) =&gt;
            IF eiv1.sm_value = eiv2.sm_value THEN
              RETURN 0
            ELSIF eiv1.sm_value &lt; eiv2.sm_value THEN
              RETURN -1
            ELSE
              RETURN 1
            END; (* if *)
        ELSE
          RETURN 1;
        END;

    | Set_constructor_value(cv1) =&gt;
        TYPECASE e2 OF
        | Set_constructor_value(cv2) =&gt;
            WITH s1 = cv1.sm_value, s2 = cv2.sm_value DO
              IF NUMBER(cv1.sm_value^) = NUMBER(cv2.sm_value^) THEN
                FOR i := 0 TO LAST(cv1.sm_value^) DO
                  IF s1[i] # s2[i] THEN RETURN 1 END;
                END;
              ELSE
                 RETURN 1;
              END;
              RETURN 0;
            END;
        ELSE
          RETURN 1;
        END;

    | Text_value(tv1) =&gt;
        TYPECASE e2 OF
        | Text_value(tv2) =&gt;
            RETURN Text.Compare(tv1.sm_value, tv2.sm_value);
        ELSE
          RETURN 1;
        END;

    | Proc_value(pv1) =&gt;
        TYPECASE e2 OF
        | Proc_value(pv2) =&gt;
            RETURN Text.Compare(pv1.sm_value, pv2.sm_value);
        ELSE
          RETURN 1;
        END;

    | Real_value(rv1) =&gt;
        TYPECASE e2 OF
        | Real_value(rv2) =&gt;
            IF rv1.sm_value = rv2.sm_value THEN RETURN 0
            ELSIF rv1.sm_value &lt; rv2.sm_value THEN RETURN -1
            ELSE  RETURN 1
            END; (* if *)
        ELSE RETURN 1;
        END;

    | LongReal_value(rv1) =&gt;
        TYPECASE e2 OF
        | LongReal_value(rv2) =&gt;
            IF rv1.sm_value = rv2.sm_value THEN RETURN 0
            ELSIF rv1.sm_value &lt; rv2.sm_value THEN RETURN -1
            ELSE RETURN 1
            END; (* if *)
        ELSE RETURN 1;
        END;

    | Extended_value(rv1) =&gt;
        TYPECASE e2 OF
        | Extended_value(rv2) =&gt;
            IF rv1.sm_value = rv2.sm_value THEN RETURN 0
            ELSIF rv1.sm_value &lt; rv2.sm_value THEN RETURN -1
            ELSE RETURN 1
            END; (* if *)
        ELSE RETURN 1;
        END;

    ELSE
      EVAL NotImplemented();
      RETURN 0;
    END; (* case *)
  END Compare_C;

PROCEDURE <A NAME="NotImplemented"><procedure>NotImplemented</procedure></A>(): M3CBackEnd.NumStatus RAISES {}=
  BEGIN
    M3Error.ReportAtPos(M3CSrcPos.Null, &quot;back-end facility not implemented&quot;);
    RETURN M3CBackEnd.NumStatus.Unknown;
  END NotImplemented;

CONST
  SetCh = 's';
  ExtendedCh = 'x';  ExtendedText = &quot;x&quot;;
  LongRealCh = 'l';  LongRealText = &quot;l&quot;;
  RealCh = 'r';      RealText = &quot;r&quot;;
  TextCh = 't';      TextText = &quot;t&quot;;
  ProcCh = 'p';      ProcText = &quot;p&quot;;
  (* Integer values, hopefully the most common, are just hex numbers *)

PROCEDURE <A NAME="ExpValueToText_C"><procedure>ExpValueToText_C</procedure></A>(e: M3AST_SM.Exp_value): TEXT RAISES {}=
  BEGIN
    TYPECASE e OF &lt;*NOWARN*&gt;
    | Integer_value(intValue) =&gt;
        RETURN Fmt.Int(intValue.sm_value, 16);
    | Set_constructor_value(setValue) =&gt;
        VAR
          s := TextWr.New();
          val := setValue.sm_value;
          result: TEXT;
        BEGIN
          Wr.PutChar(s, SetCh);
          Wr.PutText(s, Fmt.F(&quot;%s %s&quot;,
              Fmt.Int(setValue.sm_low, 16),
              Fmt.Int(NUMBER(val^), 16)));
          FOR i := 0 TO LAST(val^) DO
            Wr.PutText(s, Fmt.F(&quot; %s&quot;, Fmt.Int(val[i], 16)));
          END;
          result := TextWr.ToText(s);
          Wr.Close(s);
          RETURN result;
        END;
    | Extended_value(extValue) =&gt;
        RETURN ExtendedText &amp; Fmt.Extended(extValue.sm_value);
    | LongReal_value(longValue) =&gt;
        RETURN LongRealText &amp; Fmt.LongReal(longValue.sm_value);
    | Real_value(realValue) =&gt;
        RETURN RealText &amp; Fmt.Real(realValue.sm_value);
    | Proc_value(procValue) =&gt;
        RETURN ProcText &amp; procValue.sm_value;
    | Text_value(textValue) =&gt;
        RETURN TextText &amp; textValue.sm_value;
    END;
  END ExpValueToText_C;

EXCEPTION
  Fatal;
&lt;*FATAL Fatal*&gt;

PROCEDURE <A NAME="TextToExpValue_C"><procedure>TextToExpValue_C</procedure></A>(t: TEXT): M3AST_SM.Exp_value RAISES {}=
  VAR
    length := Text.Length(t);
  BEGIN
    CASE Text.GetChar(t, 0) OF
    | SetCh =&gt;
        RETURN SetTextToExpValue(t);
    | ExtendedCh =&gt;
        VAR
	  new := NEW(Extended_value);
        BEGIN
          IF NOT TextTo_Extended(t, new.sm_value) THEN RAISE Fatal END;
          RETURN new;
        END;
    | LongRealCh =&gt;
        VAR
	  new := NEW(LongReal_value);
        BEGIN
          IF NOT TextTo_LongReal(t, new.sm_value) THEN RAISE Fatal END;
          RETURN new;
        END;
    | RealCh =&gt;
        VAR
	  new := NEW(Real_value);
        BEGIN
          IF NOT TextTo_Real(t, new.sm_value) THEN RAISE Fatal END;
          RETURN new;
        END;
    | ProcCh =&gt;
        RETURN NEW(Proc_value, sm_value := Text.Sub(t, 1, length - 1));
    | TextCh =&gt;
        RETURN NEW(Text_value, sm_value := Text.Sub(t, 1, length - 1));
    ELSE
      VAR
        new := NEW(Integer_value);
      BEGIN
        IF NOT TextTo_Int(t, new.sm_value, 16) THEN RAISE Fatal END;
        RETURN new;
      END;
    END
  END TextToExpValue_C;

PROCEDURE <A NAME="SetTextToExpValue"><procedure>SetTextToExpValue</procedure></A>(t: TEXT): Set_constructor_value RAISES {}=
  VAR
    new := NEW(Set_constructor_value);
    s := TextRd.New(t);
  BEGIN
    EVAL(Rd.GetChar(s));
    new.sm_low := GetInt(s, 16);
    new.sm_value := NEW(REF ARRAY OF INTEGER, GetInt(s, 16));
    FOR i := 0 TO LAST(new.sm_value^) DO
      new.sm_value[i] := GetInt(s, 16);
    END;
    Rd.Close(s);
    RETURN new;
  END SetTextToExpValue;

PROCEDURE <A NAME="GetInt"><procedure>GetInt</procedure></A>(s: Rd.T; base: CARDINAL): INTEGER=
  VAR t := RdExtras.GetText(s); result: INTEGER;
  BEGIN
    EVAL TextTo_Int(t, result, base);
    RETURN result;
  END GetInt;

PROCEDURE <A NAME="TextTo_Int"><procedure>TextTo_Int</procedure></A>(t: Text.T;
    VAR i: INTEGER;
    &lt;*UNUSED*&gt; base: Fmt.Base := 10)
    : BOOLEAN=
  VAR used: INTEGER; l: INTEGER;
  BEGIN
    M3Assert.Check(t # NIL);
    l := Text.Length(t);
    IF l&gt;2 AND Text.GetChar(t, 2) = '_' OR
       l&gt;1 AND Text.GetChar(t, 1) = '_' THEN
      i := Convert.ToUnsigned(t^, used);
    ELSE
      i := Convert.ToInt(t^, used);
    END;
    RETURN used = l;
  END TextTo_Int;

PROCEDURE <A NAME="TextTo_Real"><procedure>TextTo_Real</procedure></A>(t: Text.T; VAR real: REAL): BOOLEAN=
  VAR used: INTEGER;
  BEGIN
    real := Convert.ToFloat(t^, used);
    RETURN used = Text.Length(t);
  END TextTo_Real;

PROCEDURE <A NAME="TextTo_LongReal"><procedure>TextTo_LongReal</procedure></A>(t: Text.T; VAR long: LONGREAL): BOOLEAN=
  VAR used: INTEGER;
  BEGIN
    long := Convert.ToLongFloat(t^, used);
    RETURN used = Text.Length(t);
  END TextTo_LongReal;

PROCEDURE <A NAME="TextTo_Extended"><procedure>TextTo_Extended</procedure></A>(t: Text.T; VAR extended: EXTENDED): BOOLEAN=
  VAR used: INTEGER;
  BEGIN
    extended := Convert.ToExtended(t^, used);
    RETURN used = Text.Length(t);
  END TextTo_Extended;

BEGIN
  RegisterProcs();
END M3CBackEnd_C.
</PRE>
</inModule>
<PRE>























</PRE>
</BODY>
</HTML>
