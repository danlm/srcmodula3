<HTML>
<HEAD>
<TITLE>SRC Modula-3: metasyn/derived/MetaSynBdl.m3</TITLE>
</HEAD>
<BODY>
<A NAME="0TOP0">
<H2>metasyn/derived/MetaSynBdl.m3</H2></A><HR>
<inModule>
<PRE>MODULE <module><implements><A HREF="MetaSynBdl.i3.html">MetaSynBdl</A></implements></module>;
</PRE><BLOCKQUOTE><EM> Generated by m3bundle; see its manpage. </EM></BLOCKQUOTE><PRE>

IMPORT <A HREF="../../bundleintf/src/Bundle.i3.html">Bundle</A>, <A HREF="../../bundleintf/src/BundleRep.i3.html">BundleRep</A>, <A HREF="../../text/src/Text.i3.html">Text</A>;

TYPE T = Bundle.T OBJECT OVERRIDES get := LookUp END;

VAR bundle: T := NIL;

PROCEDURE <A NAME="Get"><procedure>Get</procedure></A>(): Bundle.T =
  BEGIN
    IF (bundle = NIL) THEN bundle := NEW (T) END;
    RETURN bundle;
  END Get;

PROCEDURE <A NAME="LookUp"><procedure>LookUp</procedure></A> (&lt;*UNUSED*&gt; self: T;  element: TEXT): TEXT =
  BEGIN
    FOR i := 0 TO LAST (Names)-1 DO
      IF Text.Equal (Names[i], element) THEN
        RETURN Elements[i];
      END;
    END;
    RETURN NIL;
  END LookUp;

CONST Names = ARRAY [0..2] OF TEXT {
  &quot;ExtendGram&quot;,
  &quot;MetaGram&quot;,
  NIL
};

CONST Elements = ARRAY [0..2] OF TEXT {
  E0,
  E1,
  NIL
};

CONST E0 =
   &quot;(* Grammar file for extensible grammars, using MPTreeSubst as their\n  &quot;
 &amp; &quot; substitution\011routine *)\n\ngrammar ::=\n     clauseSeq\nclauseSeq :&quot;
 &amp; &quot;:=\n     [ \011gramExpIde _1\n        paramList_5\n\011\&quot;::=\&quot; \n\011cl&quot;
 &amp; &quot;auseExtends_2 \n\011gramExp_3\n\011clauseRest_4 \n\011] :: ClauseList\n&quot;
 &amp; &quot;clauseRest ::=\n     { clauseSeq [] }\nclauseExtends ::=\n     { [ \&quot;.\&quot;&quot;
 &amp; &quot; \&quot;.\&quot; \&quot;.\&quot; \n        { [ \&quot;*\&quot; { [ \&quot;_\&quot; int_3 ] :: ClauseExtendsIter&quot;
 &amp; &quot;Pos \n\011          []            :: ClauseExtendsIterNoPos \n         &quot;
 &amp; &quot;       }_2 ]  :: ClauseExtendsIter \n          []           :: ClauseEx&quot;
 &amp; &quot;tendsChoice\n        }_1 \n       ]   :: ClauseExtendsYes\n       []  :&quot;
 &amp; &quot;: ClauseExtendsNo\n     }\n\n\n\nparamList ::= { [ \&quot;&lt;\&quot; paramList2_1 \&quot;&quot;
 &amp; &quot;&gt;\&quot; ]::select1 [] }\nparamList2 ::= { [ \&quot;_\&quot; int_1 { [ \&quot;,\&quot; paramList&quot;
 &amp; &quot;2_2 ]::select2 [] }_2 ]::cons [] }\n\n\n(*34567890123456789012345678901&quot;
 &amp; &quot;23456789012345678901234567890*)\n(*       1         2         3        &quot;
 &amp; &quot; 4         5          *)\n\ngramExp ::=\n     [ gramExpBase_1 \n\011{ [&quot;
 &amp; &quot; \&quot;_\&quot; int_3 ]::Storage \n          [ ExtendAction&lt;_1&gt;_2 ] :: select2\n&quot;
 &amp; &quot;          []::select1 }_2 \n     ]::select2\n\n\ngramExpBase ::=\n     &quot;
 &amp; &quot;{ [ ide_1 paramList_2 ] :: GramIde\n       string_1              :: Gra&quot;
 &amp; &quot;mString\n       \&quot;ide\&quot;                 :: GramKeyIde\n       \&quot;int\&quot;  &quot;
 &amp; &quot;               :: GramKeyInt\n       \&quot;EOF\&quot;                 :: GramKey&quot;
 &amp; &quot;Eof\n       \&quot;real\&quot;                :: GramKeyReal\n       \&quot;char\&quot;    &quot;
 &amp; &quot;            :: GramKeyChar\n       \&quot;string\&quot;              :: GramKeySt&quot;
 &amp; &quot;ring \n       gramExpSequence \n       gramExpChoice   \n       gramExp&quot;
 &amp; &quot;Parens \n     }\n\ngramExpIde ::=\n     ide_1 :: Ide\n\n\ngramExpSequen&quot;
 &amp; &quot;ce ::=\n     [ \&quot;[\&quot; gramExpList_1 \&quot;]\&quot; ]   :: GramExpSequence\n  \ngr&quot;
 &amp; &quot;amExpChoice ::=\n     [ \&quot;{\&quot; gramExpList_1 \&quot;}\&quot; ] :: GramExpChoice\n &quot;
 &amp; &quot; \ngramExpParens ::=\n     [ \&quot;(\&quot; gramExp_1\n     { [ \&quot;*\&quot; { [ \&quot;_\&quot; &quot;
 &amp; &quot;int_4 gramExp_3  ] :: GramExpIterPos\n               gramExp_3         &quot;
 &amp; &quot;       :: GramExpIterNoPos  \n             }_5 ]  :: GramExpIter\n     &quot;
 &amp; &quot;  []           :: GramExpBase   }_6\n     \&quot;)\&quot; ]  :: GramExpParens\n  &quot;
 &amp; &quot;\ngramExpList ::=\n     { [ gramExp_1 gramExpList_2 ]::GramList [] }\n\n&quot;
 &amp; &quot;\n\n\n\n\n\n&quot;;

CONST E1 =
   &quot;grammar ::=\n     clauseSeq\nclauseSeq ::=\n     [ \011gramExpIde _1\n\011&quot;
 &amp; &quot;\&quot;::=\&quot; \n\011clauseExtends_2 \n\011gramExp_3\n\011clauseRest_4 \n\011]&quot;
 &amp; &quot; :: ClauseList\nclauseRest ::=\n     { \&quot;EOF\&quot; clauseSeq  }\nclauseExte&quot;
 &amp; &quot;nds ::=\n     { [ \&quot;.\&quot; \&quot;.\&quot; \&quot;.\&quot; \n        { [ \&quot;*\&quot; { [ \&quot;_\&quot; int_3&quot;
 &amp; &quot; ] :: ClauseExtendsIterPos \n\011          []            :: ClauseExten&quot;
 &amp; &quot;dIterNoPos \n                }_2 ]  :: ClauseExtendsIter \n          []&quot;
 &amp; &quot;           :: ClauseExtendsChoice\n        }_1 \n       ]   :: ClauseEx&quot;
 &amp; &quot;tendsYes\n       []  :: ClauseExtendsNo\n     }_1\n\ngramExpIde ::=\n  &quot;
 &amp; &quot;   ide\n\ngramExp ::=\n     [ gramExpBase_1 \n\011{ [ \&quot;_\&quot; int_3 ]::St&quot;
 &amp; &quot;orage [ \&quot;::\&quot; sum_3 ]::caction []::select1 }_2 \n     ]::select2\n\n\n&quot;
 &amp; &quot;gramExpBase ::=\n     { ide_1    :: GramIde\n       string_1 :: GramStr&quot;
 &amp; &quot;ing\n       \&quot;ide\&quot;    :: GramKeyIde\n       \&quot;int\&quot;    :: GramKeyInt\n&quot;
 &amp; &quot;       \&quot;EOF\&quot;    :: GramKeyEof\n       \&quot;real\&quot;   :: GramKeyReal\n    &quot;
 &amp; &quot;   \&quot;char\&quot;   :: GramKeyChar\n       \&quot;string\&quot; :: GramKeyString \n    &quot;
 &amp; &quot;   gramExpSequence \n       gramExpChoice   \n       gramExpParens \n  &quot;
 &amp; &quot;   }\n\ngramExpSequence ::=\n     [ \&quot;[\&quot; gramExpList \&quot;]\&quot; ]   :: Gram&quot;
 &amp; &quot;ExpSequence\n  \ngramExpChoice ::=\n     [ \&quot;{\&quot; gramExpList_1 \&quot;}\&quot; ] &quot;
 &amp; &quot;:: GramExpChoice\n  \ngramExpParens ::=\n     [ \&quot;(\&quot; gramExp_1\n     {&quot;
 &amp; &quot; [ \&quot;*\&quot; { [ \&quot;_\&quot; int_4 gramExp_3  ] :: GramExpIterPos\n              &quot;
 &amp; &quot; gramExp_3                :: GramExpIterNoPos  \n             }_5 ]  ::&quot;
 &amp; &quot; GramExpIter\n       []           :: GramExpBase   }_6\n     \&quot;)\&quot; ]  :&quot;
 &amp; &quot;: GramExpParens\n  \ngramExpList ::=\n     { [ gramExp_1 gramExpList_2 &quot;
 &amp; &quot;]::GramList [] }\n  \n  \n\n\n&quot;;

BEGIN
END MetaSynBdl.
</PRE>
</inModule>
<PRE>























</PRE>
</BODY>
</HTML>
