<HTML>
<HEAD>
<TITLE>SRC Modula-3: unix/src/freebsd-1/Udir.i3</TITLE>
</HEAD>
<BODY>
<A NAME="0TOP0">
<H2>unix/src/freebsd-1/Udir.i3</H2></A><HR>
<inInterface>
<PRE><A HREF="../../../COPYRIGHT.html">Copyright (C) 1994, Digital Equipment Corp.</A>

UNSAFE INTERFACE <interface><A HREF="#x1">Udir</A></interface>;
</PRE>** &lt;dir.h&gt; **

<P><PRE>IMPORT <A HREF="../../../C/src/Common/Ctypes.i3.html">Ctypes</A>;

CONST
  MAXNAMLEN = 255;   (* maximum length of component of file path name *)
  MAXPATHLEN = 1024; (* maximum length of file path name *)

  (* file types *)
  DT_UNKNOWN =      0;
  DT_FIFO    =      1;
  DT_CHR     =      2;
  DT_DIR     =      4;
  DT_BLK     =      6;
  DT_REG     =      8;
  DT_LNK     =     10;
  DT_SOCK    =     12;
</PRE><P>
 * The dirent structure defines the format of directory entries returned by
 * the getdirentries(2) system call.
 *
 * A directory entry has a struct dirent at the front of it, containing its
 * inode number, the length of the entry, and the length of the name
 * contained in the entry.  These are followed by the name padded to a 4
 * byte boundary with null bytes.  All names are guaranteed null terminated.
 * The maximum length of a name in a directory is MAXNAMLEN.
 
<PRE>TYPE
  dirent = RECORD                    (* describes directory entry *)
    d_fileno:   Ctypes.long;           (* inode number of entry *)
    d_reclen:   Ctypes.unsigned_char;  (* record length in bytes *)
    d_type:     Ctypes.unsigned_char;  (* file types, see above *)
    d_namelen:  Ctypes.unsigned_short; (* name length in bytes *)
    d_name:     ARRAY [0..MAXNAMLEN] OF Ctypes.char;  (* name *)
  END;

  direct = dirent;                    (* backwards compatibility *)

  DIR = RECORD
    dd_fd:    Ctypes.int;  (* file descriptor associated with directory *)
    dd_loc:   Ctypes.long;  (* offset in current buffer *)
    dd_size:  Ctypes.long;  (* amount of data returned by getdirentries *)
    dd_buf:   UNTRACED REF Ctypes.char;  (* data buffer *)
    dd_len:   Ctypes.int;  (* size of data buffer *)
    dd_seek:  Ctypes.long;  (* magic cookie returned by getdirentries *)
    dd_ddloc: Ctypes.void_star;  (* Linked list of ddloc structs for telldir/seekdir *)
  END;

  DIR_star = UNTRACED REF DIR;

  direct_star = UNTRACED REF direct;

&lt;*EXTERNAL*&gt; PROCEDURE opendir (filename: Ctypes.char_star): DIR_star;
&lt;*EXTERNAL*&gt; PROCEDURE <A HREF="../solaris-2-x/Udir.m3.html#readdir">readdir</A> (dirp: DIR_star): direct_star;
&lt;*EXTERNAL*&gt; PROCEDURE telldir (dirp: DIR_star): Ctypes.long;
&lt;*EXTERNAL*&gt; PROCEDURE seekdir (dirp: DIR_star; loc: Ctypes.long);
&lt;*EXTERNAL*&gt; PROCEDURE rewinddir (dirp: DIR_star);
&lt;*EXTERNAL*&gt; PROCEDURE closedir(dirp: DIR_star): Ctypes.int;
&lt;*EXTERNAL*&gt; PROCEDURE getdirentries(fd  : Ctypes.int;
                                     buf : UNTRACED REF Ctypes.char;
                                     nbytes : Ctypes.int;
                                     basep  : UNTRACED REF Ctypes.long): Ctypes.int;

END Udir.
</PRE>
</inInterface>
<HR>
<A NAME="x1">Udir's implementation  is in:
</A><UL>
<LI><A HREF="../aix-3-2/Udir.m3.html#0TOP0">unix/src/aix-3-2/Udir.m3</A>
<LI><A HREF="../aix-ps2-1-2/Udir.m3.html#0TOP0">unix/src/aix-ps2-1-2/Udir.m3</A>
<LI><A HREF="../solaris-2-x/Udir.m3.html#0TOP0">unix/src/solaris-2-x/Udir.m3</A>
</UL>
<P>
<PRE>























</PRE>
</BODY>
</HTML>
