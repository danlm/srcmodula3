<HTML>
<HEAD>
<TITLE>SRC Modula-3: obliqparse/derived/ObliqBdl.m3</TITLE>
</HEAD>
<BODY>
<A NAME="0TOP0">
<H2>obliqparse/derived/ObliqBdl.m3</H2></A><HR>
<inModule>
<PRE>MODULE <module><implements><A HREF="ObliqBdl.i3.html">ObliqBdl</A></implements></module>;
</PRE><BLOCKQUOTE><EM> Generated by m3bundle; see its manpage. </EM></BLOCKQUOTE><PRE>

IMPORT <A HREF="../../bundleintf/src/Bundle.i3.html">Bundle</A>, <A HREF="../../bundleintf/src/BundleRep.i3.html">BundleRep</A>, <A HREF="../../text/src/Text.i3.html">Text</A>;
IMPORT <A HREF="../../thread/src/Common/Thread.i3.html">Thread</A>, <A HREF="../../rw/src/Common/Wr.i3.html">Wr</A>, <A HREF="../../rw/src/Common/TextWr.i3.html">TextWr</A>;

TYPE T = Bundle.T OBJECT OVERRIDES get := LookUp END;

VAR bundle: T := NIL;

PROCEDURE <A NAME="Get"><procedure>Get</procedure></A>(): Bundle.T =
  BEGIN
    IF (bundle = NIL) THEN bundle := NEW (T) END;
    RETURN bundle;
  END Get;

PROCEDURE <A NAME="LookUp"><procedure>LookUp</procedure></A> (&lt;*UNUSED*&gt; self: T;  element: TEXT): TEXT =
  BEGIN
    FOR i := 0 TO LAST (Names)-1 DO
      IF Text.Equal (Names[i], element) THEN
        IF Elements[i] = NIL THEN Elements[i] := GetElt (i) END;
        RETURN Elements[i];
      END;
    END;
    RETURN NIL;
  END LookUp;

CONST Names = ARRAY [0..1] OF TEXT {
  &quot;ObliqGram&quot;,
  NIL
};

VAR Elements := ARRAY [0..1] OF TEXT {
  NIL (* E0 .. E0_4 *),
  NIL
};

PROCEDURE <A NAME="GetElt"><procedure>GetElt</procedure></A> (n: INTEGER): TEXT =
  &lt;*FATAL Thread.Alerted, Wr.Failure *&gt;
  VAR wr := TextWr.New ();
  BEGIN
    CASE n OF
    | 0 =&gt;
        Wr.PutText (wr, E0);
        Wr.PutText (wr, E0_0);
        Wr.PutText (wr, E0_1);
        Wr.PutText (wr, E0_2);
        Wr.PutText (wr, E0_3);
        Wr.PutText (wr, E0_4);
    ELSE (*skip*)
    END;
    RETURN TextWr.ToText (wr);
  END GetElt;

CONST E0 =
   &quot;(* &lt;pre&gt; *)\n(* METASYNTAX  (Parsing is LL(1) recursive descent).\n    &quot;
 &amp; &quot; Non-terminals are declared by \'::=\' and must be non-left-recursive.\n&quot;
 &amp; &quot;     Terminals are in double quotes \'\&quot;\'\n     \'{ g1 .. gn }\' is a &quot;
 &amp; &quot;(sequential) choice of grammars gi.\n     \'[ g1 .. gn ]\' is a sequenc&quot;
 &amp; &quot;e of grammars gi.\n     \'(g1 * g2)\' is \'[g1 g]\' where \'g::={[g2 g]&quot;
 &amp; &quot;[]}\', but left-associative\n     \'_n\' and \'::\' are used for abstra&quot;
 &amp; &quot;ct-syntax-tree generation.\n*)\n\nphrase ::=\n  { phraseEmpty\n    phra&quot;
 &amp; &quot;seHelp\n    phraseFlag\n    phraseFrame\n    phraseType\n    phraseTerm&quot;
 &amp; &quot;\n    phraseEOF\n  }\n\nphraseEmpty ::=\n  \&quot;;\&quot; \011\011\011\011\011\011&quot;
 &amp; &quot;:: BuildPhraseEmpty\n\nphraseEOF ::=\n  EOF \011\011\011\011\011\011:: &quot;
 &amp; &quot;BuildPhraseEmpty\n\nphraseHelp ::=\n  [ \&quot;~help\&quot; \n    { name string [&quot;
 &amp; &quot;] }_1\n    { name string [] }_2\n    \&quot;;\&quot;\n  ]                        &quot;
 &amp; &quot;                     :: BuildPhraseHelp\n\nphraseFlag ::=\n  [ \&quot;~flag\&quot;&quot;
 &amp; &quot; \n    { name string [] }_1\n    { name string [] }_2\n    \&quot;;\&quot;\n  ]  &quot;
 &amp; &quot;                                           :: BuildPhraseFlag\n\nphrase&quot;
 &amp; &quot;Type ::=\n  [ typDecl \&quot;;\&quot; ] :: BuildPhraseEmpty\n\nphraseFrame ::=\n &quot;
 &amp; &quot; { phraseLoad\n    phraseImport\n    phraseModule\n    phraseEndModule\n&quot;
 &amp; &quot;    phraseEstablish\n    phraseDelete\n    phraseSave\n    phraseQualif&quot;
 &amp; &quot;y\n    phraseQuit\n  }\n\nphraseQuit ::=\n  [ \&quot;~quit\&quot; \&quot;;\&quot; ]\011\011&quot;
 &amp; &quot;\011\011:: BuildPhraseQuit\n\nphraseLoad ::=\n  [ \&quot;load\&quot; \n    { name&quot;
 &amp; &quot;_1\011\011\011\011\011:: BuildPhraseLoadName\n      string_1 \011\011\011&quot;
 &amp; &quot;\011\011:: BuildPhraseLoadString\n    }_2\n    \&quot;;\&quot; \n  ]\011\011\011\011&quot;
 &amp; &quot;\011\011:: Select2\n\nphraseImport ::=\n  [ \&quot;import\&quot; name_1 \&quot;;\&quot; ]\011&quot;
 &amp; &quot;\011\011:: BuildPhraseImport\n\nphraseEstablish ::=\n  [ \&quot;~establish\&quot;&quot;
 &amp; &quot; name_1\n    { [ \&quot;for\&quot; name_2 ]\011                \011:: Select2\n  &quot;
 &amp; &quot;    []\n    }_3\n    \&quot;;\&quot; \n  ]\011\011                               &quot;
 &amp; &quot; :: BuildPhraseEstablish\n\nphraseSave ::=\n  [ \&quot;~save\&quot; name_1 \&quot;;\&quot; &quot;
 &amp; &quot;]\011                :: BuildPhraseSave\n\nphraseDelete ::=\n  [ \&quot;~del&quot;
 &amp; &quot;ete\&quot; name_1 \&quot;;\&quot; ]\011        \011:: BuildPhraseDelete\n\nphraseQuali&quot;
 &amp; &quot;fy ::=\n  [ \&quot;~qualify\&quot; \&quot;;\&quot; ]                            :: BuildPhr&quot;
 &amp; &quot;aseQualify\n\nphraseModule ::=\n  [ \&quot;module\&quot; \n    name_1\n    { [ \&quot;&quot;
 &amp; &quot;for\&quot; name_2 ]                          :: Select2\n      []\n    }_3&quot;;

CONST E0_0 =
   &quot;\n    { [ \&quot;import\&quot; importList_4  ]               \011:: Select4\n    &quot;
 &amp; &quot;  []\n    }_5\n    { [ \&quot;export\&quot; exportList ] [] }\n    \&quot;;\&quot; \n  ]\011&quot;
 &amp; &quot;\011\011                \011:: BuildPhraseModule\n\nphraseEndModule ::=&quot;
 &amp; &quot;\n  [ \&quot;end\&quot; \&quot;module\&quot; \&quot;;\&quot; ]                        :: BuildPhraseE&quot;
 &amp; &quot;ndModule\n\nimportList ::=\n  { [ name_1 \n\011{ [ \&quot;,\&quot; importList_2 ]&quot;
 &amp; &quot;\011\011\011:: BuildImportList\n\011  []\011\011\011\011\011:: BuildImp&quot;
 &amp; &quot;ortListSingle\n\011}_3\n    ]    \011\011\011\011\011:: Select3        &quot;
 &amp; &quot;         \n    []\011\011\011\011\011\011:: BuildImportListNil\n  }\n\n&quot;
 &amp; &quot;phraseTerm ::=\n  [ term_1 \n      { [ \&quot;!\&quot;\n          { int_2\011\011&quot;
 &amp; &quot;\011\011:: BuildPhraseTermDepth\n\011    [] \011\011\011\011\011:: Buil&quot;
 &amp; &quot;dPhraseTermDeep\n          }_3\n\011]\011\011\011\011\011:: Select3\n\011&quot;
 &amp; &quot;[]\011\011\011\011\011:: BuildPhraseTerm\n      }_4\n    \&quot;;\&quot;\n  ]\011&quot;
 &amp; &quot;\011\011\011\011\011:: Select4\n\ntypDecl ::=\n  [ \&quot;type\&quot; ide { typPa&quot;
 &amp; &quot;rams [] } \&quot;=\&quot; typ ]\n\ntyp ::=\n  { [ \&quot;(\&quot; typList \&quot;)\&quot; { typRngSpe&quot;
 &amp; &quot;c [] } ]\n    [ \&quot;Option\&quot; typFields \&quot;end\&quot; ]\n    [ \&quot;{\&quot; typFields \&quot;&quot;
 &amp; &quot;}\&quot; ]\n    [ \&quot;[\&quot; { [ int \&quot;~*\&quot; ] [] } typ \&quot;]\&quot; ]\n    [ \&quot;All\&quot; \&quot;(&quot;
 &amp; &quot;\&quot; ide { typBound [] } \&quot;)\&quot; typ ]\n    [ \&quot;Some\&quot; \&quot;(\&quot; ide { typBound&quot;
 &amp; &quot; [] } \&quot;)\&quot; typ ]\n    [ \&quot;Self\&quot; \&quot;(\&quot; ide \&quot;)\&quot; typ ]\n    [ ide \n  &quot;
 &amp; &quot;      { [ \&quot;_\&quot; name { typParams [] } ]\n          typParams\n         &quot;
 &amp; &quot; []\n        }\n    ]\n  }\n\ntypBound ::= \n  [ \&quot;&lt;:\&quot; typ ]\n\ntypPar&quot;
 &amp; &quot;ams ::=\n  [ \&quot;(\&quot; typNameList \&quot;)\&quot; ]\n\ntypNameList ::=\n  { [ ide { &quot;
 &amp; &quot;[ \&quot;,\&quot; typList ] [] } ]\n    []\n  }\n\ntypList ::=\n  { [ typ { [ \&quot;,&quot;
 &amp; &quot;\&quot; typList ] [] } ]\n    []\n  }\n\ntypFields ::=\n  { [ ide \&quot;:\&quot; typ\n&quot;
 &amp; &quot;      { [ \&quot;,\&quot; typFields ]\n\011[]\n      }\n    ]\n    []\n  }\n\ntyp&quot;
 &amp; &quot;Spec ::=\n  { [ \&quot;:\&quot; typ ] [] }\n\ntypResSpec ::=\n  { [ \&quot;:\&quot; typ { [&quot;
 &amp; &quot; \&quot;!\&quot; excList ] [] } ] \n    [ \&quot;!\&quot; excList ]\n  }\n\ntypRngSpec ::=\n&quot;
 &amp; &quot;  { [ \&quot;-&gt;\&quot; typ { [ \&quot;!\&quot; excList ] [] } ] \n    [ \&quot;=&gt;\&quot; typ { [ \&quot;!\&quot;&quot;
 &amp; &quot; excList ] [] } ] \n    [ \&quot;!\&quot; excList ]\n  }\n\nexcList ::=\n  { [ id&quot;
 &amp; &quot;e { [ \&quot;_\&quot; name ] [] } excList ] [] }\n\nprocDecl ::=\n  {\n    [ { \&quot;&quot;
 &amp; &quot;All\&quot; \&quot;Some\&quot; } \&quot;(\&quot; ide { typBound [] } \&quot;)\&quot; procDecl ]\n    [ ide &quot;
 &amp; &quot;\n      { [ \&quot;:\&quot; typ ]\n        [ \&quot;(\&quot; ideList \&quot;)\&quot; typResSpec ]\n  &quot;
 &amp; &quot;      []\n      }\n    ]\n  }\n  \nexportList ::=\n  { [ typDecl { [ \&quot;&quot;
 &amp; &quot;,\&quot; exportList ] [] } ]\n    [ procDecl { [ \&quot;,\&quot; exportList ] [] } ]\n&quot;
 &amp; &quot;    []\n  }\n\ntermBinding ::=\n  { [ ide&quot;;

CONST E0_1 =
   &quot;_1 typSpec \&quot;=\&quot; term_2 \n      { [ \&quot;,\&quot; termBinding_3 ] \011\011\011:&quot;
 &amp; &quot;: BuildTermBinding\n        []\011\011\011\011\011:: BuildTermBindingSi&quot;
 &amp; &quot;ngle\n      }_4\n    ]\011\011\011\011\011\011:: Select4\n    []\011\011&quot;
 &amp; &quot;\011\011\011\011:: BuildTermBindingNil\n  }\n\ntermSeq ::=\n  [ term_1\n&quot;
 &amp; &quot;    { [ \&quot;;\&quot; \n\011{ termSeq_2\011\011\011\011:: BuildTermSeq\n\011  [&quot;
 &amp; &quot;]\011\011\011\011\011:: Select1\n\011}_3\n      ]\011\011\011\011\011\011&quot;
 &amp; &quot;:: Select3\n      []\011\011\011\011\011:: Select1\n    }_4\n  ]\011\011&quot;
 &amp; &quot;\011\011\011\011:: Select4\n\ntermSeqOpt ::=\n  { termSeq\n    []      &quot;
 &amp; &quot;                                    :: BuildTermOk\n  }\n\nterm ::=\n  &quot;
 &amp; &quot;( termBase *_1\n    { [ \&quot;(\&quot; termList_2 \&quot;)\&quot; ]\011\011\011:: BuildTer&quot;
 &amp; &quot;mAppl\n      [ \&quot;_\&quot; name_2 \n        { [ \&quot;(\&quot; termList_3 \&quot;)\&quot; ]\011\011&quot;
 &amp; &quot;:: BuildTermOp\n          []\011\011\011\011\011:: BuildTermOpConst\n  &quot;
 &amp; &quot;      }_4\n      ]\011\011\011\011\011\011:: Select4\n      [ \&quot;.\&quot; nam&quot;
 &amp; &quot;e_2 \n        { [ \&quot;:=\&quot; termOrAlias_3 ]\011\011:: BuildTermUpdate\n   &quot;
 &amp; &quot;       [ \&quot;(\&quot; termList_3 \&quot;)\&quot; ]                :: BuildTermInvoke\n  &quot;
 &amp; &quot;        []\011\011\011\011\011:: BuildTermSelect\n        }_4\n      ]\011&quot;
 &amp; &quot;\011\011\011\011\011:: Select4\n      [ \&quot;:=\&quot; term_2 ]                &quot;
 &amp; &quot;           :: BuildTermAssign\n      [ \&quot;[\&quot; term_2 \n        { [ \&quot;]\&quot;&quot;
 &amp; &quot;\n            { [ \&quot;:=\&quot; term_3 ]\011\011\011:: BuildTermArraySet\n    &quot;
 &amp; &quot;          []\011\011\011\011:: BuildTermArrayGet\n            }_4\n    &quot;
 &amp; &quot;      ]\011\011\011\011\011:: Select4\n          [ \&quot;for\&quot; term_3 \&quot;]\&quot;&quot;
 &amp; &quot;\n            { [ \&quot;:=\&quot; term_4 ]\011\011\011:: BuildTermArrayUpd\n    &quot;
 &amp; &quot;          []\011\011\011\011:: BuildTermArraySub\n            }_5\n    &quot;
 &amp; &quot;      ]\011\011\011\011\011:: Select5\n        }_6\n      ]\011\011\011&quot;
 &amp; &quot;\011\011\011:: Select6\n      [ ide_2 term_3 ]\011\011\011\011:: BuildT&quot;
 &amp; &quot;ermInfix\n      [ \&quot;andif\&quot; term_2 ]\011\011\011:: BuildTermAndif\n    &quot;
 &amp; &quot;  [ \&quot;orif\&quot; term_2 ]\011\011\011\011:: BuildTermOrif\n    }\n  )\n\nte&quot;
 &amp; &quot;rmBase ::=\n  { \n    termMinus\n    termIde\n    termConst\n    termAr&quot;
 &amp; &quot;ray\n    termObj\n    termOption\n    termClone\n    termDelegate\n    &quot;
 &amp; &quot;termRedirect\n    termProc\n    termMeth\n    termPar\n    termLet\n   &quot;
 &amp; &quot; termVar\n    termIf\n    termCase\n    termLoop\n    termExit\n    ter&quot;
 &amp; &quot;mFor\n    termForeach\n    termException\n    termRaise\n    termTry\n &quot;
 &amp; &quot;   termLock\n    termWatch\n    termAll\n    termSome\n    termSelf\n  &quot;
 &amp; &quot;}\n\ntermIde ::=\n  ide_1 \011\011\011\011\011:: BuildTermIde\n\ntermCo&quot;
 &amp; &quot;nst ::=\n  { \&quot;ok\&quot;                                        :: BuildTerm&quot;
 &amp; &quot;Ok\n    \&quot;true\&quot; &quot;;

CONST E0_2 =
   &quot;                                     :: BuildTermBoolTrue\n    \&quot;false\&quot;&quot;
 &amp; &quot;                                     :: BuildTermBoolFalse\n    char_1 &quot;
 &amp; &quot;                                     :: BuildTermChar\n    string_1    &quot;
 &amp; &quot;                                :: BuildTermString\n    int_1          &quot;
 &amp; &quot;                             :: BuildTermInt\n    real_1               &quot;
 &amp; &quot;                       :: BuildTermReal\n  }\n\ntermMinus ::=\n  [ \&quot;~-&quot;
 &amp; &quot;\&quot; term_1 ]                               :: BuildTermMinus\n\ntermArra&quot;
 &amp; &quot;y ::=\n  [ \&quot;[\&quot; termList_1 \&quot;]\&quot; ]\011\011\011:: BuildTermArray\n\nter&quot;
 &amp; &quot;mObj ::=\n  [ \&quot;{\&quot; termObjProtected_1 termObjSerialized_2\n    termObj&quot;
 &amp; &quot;Fields_3 \&quot;}\&quot; ]                 \011:: BuildTermObj\n\ntermObjProtecte&quot;
 &amp; &quot;d ::=\n {  [ \&quot;protected\&quot; { \&quot;,\&quot; [] } ] \011\011        :: BuildOptio&quot;
 &amp; &quot;nYes\n    []\011\011\011\011\011\011:: BuildOptionNo\n  }\n  \ntermObjS&quot;
 &amp; &quot;erialized ::=\n {  [ \&quot;serialized\&quot; { \&quot;,\&quot; [] } ] \011        :: Build&quot;
 &amp; &quot;OptionYes\n    []\011\011\011\011\011\011:: BuildOptionNo\n  }\n\ntermO&quot;
 &amp; &quot;ption ::=\n  [ \&quot;option\&quot; name_1 typSpec \&quot;=&gt;\&quot; termSeqOpt_2 \&quot;end\&quot; ]\011&quot;
 &amp; &quot;:: BuildTermOption\n\ntermOrAlias ::=\n  { term\n    [ \&quot;alias\&quot; ide_1 &quot;
 &amp; &quot;\&quot;of\&quot; termSeq_2 \&quot;end\&quot; ]      :: BuildTermAlias\n  }\n\ntermObjFields&quot;
 &amp; &quot; ::=\n  { [ name_1 typSpec \&quot;=&gt;\&quot; termOrAlias_2 \n      { [ \&quot;,\&quot; termO&quot;
 &amp; &quot;bjFields_3 ]\011\011\011:: BuildTermObjField\n\011[]\011\011\011\011\011&quot;
 &amp; &quot;:: BuildTermObjFieldSingle\n      }_4\n    ]\011\011\011\011\011\011:: &quot;
 &amp; &quot;Select4\n    []\011\011\011\011\011\011:: BuildTermObjFieldNil\n  }\n\n&quot;
 &amp; &quot;termClone ::=\n  [ \&quot;clone\&quot; \&quot;(\&quot; termList_1 \&quot;)\&quot; ]\011\011:: BuildTe&quot;
 &amp; &quot;rmClone\n\ntermDelegate ::= (* OBSOLETE *)\n  [ \&quot;delegate\&quot; termSeq_1 &quot;
 &amp; &quot;\&quot;to\&quot; termSeq_2 \&quot;end\&quot; ]\011:: BuildTermRedirect\n\ntermRedirect ::=\n&quot;
 &amp; &quot;  [ \&quot;redirect\&quot; termSeq_1 \&quot;to\&quot; termSeq_2 \&quot;end\&quot; ]\011:: BuildTermRe&quot;
 &amp; &quot;direct\n\ntermProc ::=\n  [ \&quot;proc\&quot; \&quot;(\&quot; ideList_1 \&quot;)\&quot; { [ typResSp&quot;
 &amp; &quot;ec \&quot;,\&quot; ] [] } termSeqOpt_2 \&quot;end\&quot; ]\n\011\011\011\011\011 \011:: Bui&quot;
 &amp; &quot;ldTermProc\n\ntermMeth ::=\n  [ \&quot;meth\&quot; \&quot;(\&quot; ideList_1 \&quot;)\&quot; { [ typR&quot;
 &amp; &quot;esSpec \&quot;,\&quot; ] [] } termSeqOpt_2 \&quot;end\&quot; ]\n\011\011\011\011\011\011:: &quot;
 &amp; &quot;BuildTermMeth\ntermPar ::=\n  [ \&quot;(\&quot; termSeqOpt_1 \&quot;)\&quot; ]\011\011\011:&quot;
 &amp; &quot;: Select1\n\ntermLet ::=\n  [ \&quot;let\&quot;\n    { [ \&quot;rec\&quot; termBinding_1 ] &quot;
 &amp; &quot;                  :: BuildTermLetRec\n      termBinding_1              &quot;
 &amp; &quot;               :: BuildTermLet\n    }_2\n  ]         &quot;;

CONST E0_3 =
   &quot;                                    :: Select2                    \n\nt&quot;
 &amp; &quot;ermVar ::=\n  [ \&quot;var\&quot;\n    { [ \&quot;rec\&quot; termBinding_1 ]               &quot;
 &amp; &quot;    :: BuildTermVarRec\n      termBinding_1                            &quot;
 &amp; &quot; :: BuildTermVar\n    }_2\n  ]                                         &quot;
 &amp; &quot;    :: Select2                    \n\ntermIf ::=\n  [ \&quot;if\&quot; termSeq_1 &quot;
 &amp; &quot;\&quot;then\&quot; termSeqOpt_2 termElsif_3 ]\n\011\011\011\011\011\011:: BuildTe&quot;
 &amp; &quot;rmIf\ntermElsif ::=\n  { [ \&quot;end\&quot; ]\011\011\011\011\011:: BuildTermIfE&quot;
 &amp; &quot;nd\n    [ \&quot;else\&quot; termSeqOpt_1 \&quot;end\&quot; ]\011\011\011:: Select1\n    [ &quot;
 &amp; &quot;\&quot;elsif\&quot; termSeq_1 \&quot;then\&quot; termSeqOpt_2 termElsif_3 ]\n\011\011\011\011&quot;
 &amp; &quot;\011\011:: BuildTermIf\n  }\n\ntermCase ::=\n  [ \&quot;case\&quot; termSeq_1 \n &quot;
 &amp; &quot;   \&quot;of\&quot; termCaseList_2 ]\011\011\011:: BuildTermCase\n\ntermLoop ::=\n&quot;
 &amp; &quot;  [ \&quot;loop\&quot; termSeqOpt_1 \&quot;end\&quot; ]\011\011\011:: BuildTermLoop\n\nterm&quot;
 &amp; &quot;Exit ::=\n  \&quot;exit\&quot;\011\011\011\011\011:: BuildTermExit\n\ntermFor ::=&quot;
 &amp; &quot;\n  [ \&quot;for\&quot; ide_1 typSpec \&quot;=\&quot; term_2 \&quot;to\&quot; term_3 \&quot;do\&quot; termSeqOp&quot;
 &amp; &quot;t_4 \&quot;end\&quot; ]\n\011\011\011\011\011\011:: BuildTermFor\n\ntermForeach :&quot;
 &amp; &quot;:=\n  [ \&quot;foreach\&quot; ide_1 typSpec \&quot;in\&quot; term_2 \n    { [ \&quot;do\&quot; termSe&quot;
 &amp; &quot;qOpt_3 ]\011\011\011:: BuildTermForeachDo\n      [ \&quot;map\&quot; termSeqOpt_3&quot;
 &amp; &quot; ]\011\011\011:: BuildTermForeachMap\n    }_4\n    \&quot;end\&quot; \n  ]\011\011&quot;
 &amp; &quot;\011\011\011\011:: Select4\n\011\011\011\011\011\011\ntermException ::=&quot;
 &amp; &quot;\n  [ \&quot;exception\&quot;\011\&quot;(\&quot; term_1 \&quot;)\&quot; ]\011\011:: BuildTermExceptio&quot;
 &amp; &quot;n\n\ntermRaise ::=\n  [ \&quot;raise\&quot; \&quot;(\&quot; term_1 \&quot;)\&quot; ]                 &quot;
 &amp; &quot;   :: BuildTermRaise\n\ntermTry ::=\n  [ \&quot;try\&quot; termSeqOpt_1 \n    { [&quot;
 &amp; &quot; \&quot;except\&quot; termTryList_2 \&quot;end\&quot; ] \011\011:: BuildTermTry\n      [ \&quot;&quot;
 &amp; &quot;else\&quot; termSeqOpt_2 \&quot;end\&quot; ] \011\011:: BuildTermTryElse\n      [ \&quot;fi&quot;
 &amp; &quot;nally\&quot; termSeqOpt_2 \&quot;end\&quot; ]\011\011:: BuildTermTryFinally\n    }_3\n&quot;
 &amp; &quot;  ]\011\011\011\011\011\011:: Select3\n\ntermList ::=\n  { [ term_1 \n &quot;
 &amp; &quot;     { [ \&quot;,\&quot; termList_2 ]\011\011\011:: BuildTermListCons\n\011[]\011&quot;
 &amp; &quot;\011\011\011\011:: BuildTermListSingle\n      }_3\n    ]\011\011\011\011&quot;
 &amp; &quot;\011\011:: Select3\n    []\011\011\011\011\011\011:: BuildTermListNil\n&quot;
 &amp; &quot;  }\n\ntermLock ::=\n  [ \&quot;lock\&quot; termSeq_1 \&quot;do\&quot; termSeqOpt_2 \&quot;end\&quot;&quot;
 &amp; &quot; ]  :: BuildTermLock\n\ntermWatch ::=\n  [ \&quot;watch\&quot; termSeq_1 \&quot;until\&quot;&quot;
 &amp; &quot; termSeq_2 \&quot;end\&quot; ] :: BuildTermWatch\n\nideList ::=\n  { [ ide_1 typS&quot;
 &amp; &quot;pec\n      { [ \&quot;,\&quot; ideList_2 ]\011\011\011:: BuildIdeListCons\n\011[]&quot;
 &amp; &quot;\011\011\011\011\011:: BuildIdeListSingle\n      }_3\n    ]\011\011\011&quot;
 &amp; &quot;\011\011\011:: Select3\n    []\011\011\011\011\011\011:: BuildIdeListNi&quot;
 &amp; &quot;l\n  }\n\nterm&quot;;

CONST E0_4 =
   &quot;CaseListEnd ::=\n  { \&quot;end\&quot;\011\011\011\011\011:: BuildCaseListNil\n  &quot;
 &amp; &quot;  [ \&quot;else\&quot; termSeqOpt_1 \&quot;end\&quot; ]\011        :: BuildCaseListElse\n  &quot;
 &amp; &quot;}\n\ntermCaseList ::=\n  { termCaseListEnd\n    [ name_1 \n      { [ \&quot;&quot;
 &amp; &quot;(\&quot; ide_2 typSpec \&quot;)\&quot; \&quot;=&gt;\&quot; termSeqOpt_3\n          { [ \&quot;,\&quot; termCa&quot;
 &amp; &quot;seList_4 ]\011\011:: BuildCaseListCons\n\011    termCaseListEnd_4      &quot;
 &amp; &quot;   \011\011:: BuildCaseListCons\n          }_5\n        ]\011\011\011\011&quot;
 &amp; &quot;\011:: Select5\n        [ \&quot;=&gt;\&quot; termSeqOpt_3\n          { [ \&quot;,\&quot; term&quot;
 &amp; &quot;CaseList_4 ]\011\011:: BuildCaseListCons\n\011    termCaseListEnd_4    &quot;
 &amp; &quot;     \011\011:: BuildCaseListCons\n          }_5\n        ]\011\011\011&quot;
 &amp; &quot;\011\011:: Select5\n      }_6\n    ]\011\011\011\011\011\011:: Select6\n&quot;
 &amp; &quot;  }\n\ntermTryList ::=\n  { [ \&quot;else\&quot; termSeqOpt_1 ]                  &quot;
 &amp; &quot;   :: BuildTryListElse\n    [ term_1 \&quot;=&gt;\&quot; termSeqOpt_2 \n      { [ \&quot;&quot;
 &amp; &quot;,\&quot; termTryList_3 ]\011\011\011:: BuildTryListCons\n\011[ \&quot;else\&quot; term&quot;
 &amp; &quot;SeqOpt_3 ]\011\011\011:: BuildTryListConsElse\n\011[]\011\011\011\011\011&quot;
 &amp; &quot;:: BuildTryListSingle\n      }_4\n    ]\011\011\011\011\011\011:: Selec&quot;
 &amp; &quot;t4\n    []\011\011\011\011\011\011:: BuildTryListNil\n  }\n\ntermAll ::&quot;
 &amp; &quot;=\n    [ \&quot;All\&quot; \&quot;(\&quot; ide { typBound [] } \&quot;)\&quot; term_1 ]    :: Select1&quot;
 &amp; &quot;\n\ntermSome ::=\n    [ \&quot;Some\&quot; \&quot;(\&quot; ide { typBound [] } \&quot;)\&quot; term_1&quot;
 &amp; &quot; ]    :: Select1\n\ntermSelf ::=\n    [ \&quot;Self\&quot; \&quot;(\&quot; ide \&quot;)\&quot; term_1&quot;
 &amp; &quot; ]    :: Select1\n\n(* &lt;/pre&gt; *)\n&quot;;

BEGIN
END ObliqBdl.
</PRE>
</inModule>
<PRE>























</PRE>
</BODY>
</HTML>
