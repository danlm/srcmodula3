<HTML>
<HEAD>
<TITLE>SRC Modula-3: ui/src/winvbt/WinScrnPaintOp.m3</TITLE>
</HEAD>
<BODY>
<A NAME="0TOP0">
<H2>ui/src/winvbt/WinScrnPaintOp.m3</H2></A><HR>
<inModule>
<PRE><A HREF="../../../COPYRIGHT.html">Copyright (C) 1994, Digital Equipment Corp.</A>
</PRE><BLOCKQUOTE><EM> Digital Internal Use Only                                                 </EM></BLOCKQUOTE><PRE>
</PRE>                                                                           
       Created on Tue Jan 17 16:48:42 PST 1995 by najork                   

<P>
<P><PRE>MODULE <module><implements><A HREF="WinScrnPaintOp.i3.html">WinScrnPaintOp</A></implements></module>;

IMPORT <A HREF="../vbt/PaintOp.i3.html">PaintOp</A>, <A HREF="../vbt/ScreenType.i3.html">ScreenType</A>, <A HREF="../vbt/ScrnPaintOp.i3.html">ScrnPaintOp</A>, <A HREF="../vbt/TrestleClass.i3.html">TrestleClass</A>, <A HREF="../vbt/VBTClass.i3.html">VBTClass</A>, <A HREF="../../../win32/src/WinDef.i3.html">WinDef</A>,
       <A HREF="../../../win32/src/WinGDI.i3.html">WinGDI</A>, <A HREF="WinScreenType.i3.html">WinScreenType</A>, <A HREF="WinScreenTypePrivate.i3.html">WinScreenTypePrivate</A>, <A HREF="../../../word/src/Word.i3.html">Word</A>;

PROCEDURE <A NAME="NewOracle"><procedure>NewOracle</procedure></A> (st: WinScreenType.T): ScrnPaintOp.Oracle =
  BEGIN
    RETURN NEW(Oracle, st := st)
  END NewOracle;

TYPE
  Oracle = ScrnPaintOp.Oracle BRANDED OBJECT
    st: WinScreenType.T;
  OVERRIDES
    opaque      := Opaque;
    bgfg        := BgFg;
    swap        := Swap;
    transparent := Transparent;
    copy        := Copy;
    builtIn     := BuiltIn;
  END;

PROCEDURE <A NAME="Opaque"><procedure>Opaque</procedure></A> (self: Oracle; pix: ScrnPaintOp.Pixel): ScrnPaintOp.T =
  BEGIN
    RETURN NewPaintOp (self.st, Op {Mode.Opaq, pix}, Op {Mode.Opaq, pix}, pix);
  END Opaque;

PROCEDURE <A NAME="Transparent"><procedure>Transparent</procedure></A> (self: Oracle): ScrnPaintOp.T =
  BEGIN
    RETURN NewPaintOp (self.st, Op {Mode.Tran, 0}, Op {Mode.Tran, 0});
  END Transparent;

PROCEDURE <A NAME="Copy"><procedure>Copy</procedure></A> (self: Oracle): ScrnPaintOp.T =
  BEGIN
    RETURN NewPaintOp (self.st, Op {Mode.Copy, 0}, Op {Mode.Copy, 0});
  END Copy;

PROCEDURE <A NAME="Swap"><procedure>Swap</procedure></A> (self: Oracle; p, q: ScrnPaintOp.Pixel): ScrnPaintOp.T =
  VAR
    pix := Word.Xor(p, q);
</PRE><BLOCKQUOTE><EM>    pix := 16_00000000; </EM></BLOCKQUOTE><PRE> (* expected behavior - no-op *)
</PRE><BLOCKQUOTE><EM>    pix := 16_00FFFFFF; </EM></BLOCKQUOTE><PRE> (* white to black, red to green (but not cyan) *)
</PRE><BLOCKQUOTE><EM>    pix := 16_02FFFFFF; </EM></BLOCKQUOTE><PRE> (* white turns green; red turns blue *)
  BEGIN
    (* &quot;p = q&quot; is a special case, which can be handled
       much more efficiently by calling &quot;Transparent&quot;. *)
    IF p = q THEN
      RETURN Transparent(self);
    END;
    RETURN NewPaintOp (self.st, Op {Mode.Swap, pix}, Op {Mode.Swap, pix});
  END Swap;

PROCEDURE <A NAME="BgFg"><procedure>BgFg</procedure></A> (self: Oracle; bg, fg: ScrnPaintOp.T): ScrnPaintOp.T
    RAISES {ScrnPaintOp.Failure} =

  PROCEDURE IsTint (rec: OpRecord): BOOLEAN =
    BEGIN
      RETURN rec.bop = rec.fop AND NOT rec.bop.mode = Mode.Copy;
    END IsTint;

  VAR
    st := self.st;
  BEGIN
    LOCK st.trsl DO
      IF bg.id &lt; 0 OR bg.id &gt;= st.opcount OR NOT IsTint(st.optable[bg.id]) OR
         fg.id &lt; 0 OR fg.id &gt;= st.opcount OR NOT IsTint(st.optable[fg.id]) THEN
        RAISE ScrnPaintOp.Failure;
      END;
    END;
    RETURN NewPaintOp(st, st.optable[bg.id].bop, st.optable[fg.id].fop);
  END BgFg;

PROCEDURE <A NAME="BuiltIn"><procedure>BuiltIn</procedure></A> (self: Oracle; op: PaintOp.Predefined): ScrnPaintOp.T =
  VAR
    b    := self.st.bg;
    f    := self.st.fg;
    back := Op {Mode.Opaq, b};
    fore := Op {Mode.Opaq, f};
    swap := Op {Mode.Swap, Word.Xor (b, f)};
    tran := Op {Mode.Tran, 0};
  BEGIN
    CASE op OF
    | PaintOp.Bg.op              =&gt; RETURN NewPaintOp (self.st, back, back, b);
    | PaintOp.BgFg.op            =&gt; RETURN NewPaintOp (self.st, back, fore);
    | PaintOp.BgTransparent.op   =&gt; RETURN NewPaintOp (self.st, back, tran);
    | PaintOp.BgSwap.op          =&gt; RETURN NewPaintOp (self.st, back, swap);
    | PaintOp.FgBg.op            =&gt; RETURN NewPaintOp (self.st, fore, back);
    | PaintOp.Fg.op              =&gt; RETURN NewPaintOp (self.st, fore, fore, f);
    | PaintOp.FgTransparent.op   =&gt; RETURN NewPaintOp (self.st, fore, tran);
    | PaintOp.FgSwap.op          =&gt; RETURN NewPaintOp (self.st, fore, swap);
    | PaintOp.TransparentBg.op   =&gt; RETURN NewPaintOp (self.st, tran, back);
    | PaintOp.TransparentFg.op   =&gt; RETURN NewPaintOp (self.st, tran, fore);
    | PaintOp.Transparent.op     =&gt; RETURN NewPaintOp (self.st, tran, tran);
    | PaintOp.TransparentSwap.op =&gt; RETURN NewPaintOp (self.st, tran, swap);
    | PaintOp.SwapBg.op          =&gt; RETURN NewPaintOp (self.st, swap, back);
    | PaintOp.SwapFg.op          =&gt; RETURN NewPaintOp (self.st, swap, fore);
    | PaintOp.SwapTransparent.op =&gt; RETURN NewPaintOp (self.st, swap, tran);
    | PaintOp.Swap.op            =&gt; RETURN NewPaintOp (self.st, swap, swap);
    | PaintOp.Copy.op            =&gt; RETURN Copy(self);
    END;
  END BuiltIn;

PROCEDURE <A NAME="ToBinaryRasterOp"><procedure>ToBinaryRasterOp</procedure></A> (bop, fop: Op): INTEGER =
  BEGIN
    CASE bop.mode OF
    | Mode.Copy =&gt;
      CASE fop.mode OF
      | Mode.Copy =&gt; RETURN WinGDI.R2_COPYPEN;
      | Mode.Tran =&gt; RETURN WinGDI.R2_NOP;  (* illegal combination *)
      | Mode.Opaq =&gt; RETURN WinGDI.R2_NOP;  (* illegal combination *)
      | Mode.Swap =&gt; RETURN WinGDI.R2_NOP;  (* illegal combination *)
      END;
    | Mode.Tran =&gt;
      CASE fop.mode OF
      | Mode.Copy =&gt; RETURN WinGDI.R2_NOP;  (* illegal combination *)
      | Mode.Tran =&gt; RETURN WinGDI.R2_NOP;
      | Mode.Opaq =&gt; RETURN WinGDI.R2_COPYPEN;
      | Mode.Swap =&gt; RETURN WinGDI.R2_XORPEN;
      END;
    | Mode.Opaq =&gt;
      CASE fop.mode OF
      | Mode.Copy =&gt; RETURN WinGDI.R2_NOP;  (* illegal combination *)
      | Mode.Tran =&gt; RETURN WinGDI.R2_NOP;
      | Mode.Opaq =&gt; RETURN WinGDI.R2_COPYPEN;
      | Mode.Swap =&gt; RETURN WinGDI.R2_XORPEN;
      END;
    | Mode.Swap =&gt;
      CASE fop.mode OF
      | Mode.Copy =&gt; RETURN WinGDI.R2_NOP;  (* illegal combination *)
      | Mode.Tran =&gt; RETURN WinGDI.R2_NOP;
      | Mode.Opaq =&gt; RETURN WinGDI.R2_COPYPEN;
      | Mode.Swap =&gt; RETURN WinGDI.R2_XORPEN;
      END;
    END;
  END ToBinaryRasterOp;
</PRE>*****
CONST
  R3_NOOP = 16_00AA0029;
****

<P><PRE>PROCEDURE <A NAME="ToBgTernaryRasterOp"><procedure>ToBgTernaryRasterOp</procedure></A> (op: Op): WinDef.DWORD =
  BEGIN
    CASE op.mode OF
    | Mode.Opaq =&gt; RETURN 16_00B8074A;
    | Mode.Tran =&gt; RETURN 0;
    | Mode.Swap =&gt; RETURN 16_009A0709;
    | Mode.Copy =&gt; RETURN WinGDI.SRCCOPY;
    END;
  END ToBgTernaryRasterOp;

PROCEDURE <A NAME="ToFgTernaryRasterOp"><procedure>ToFgTernaryRasterOp</procedure></A> (op: Op): WinDef.DWORD =
  BEGIN
    CASE op.mode OF
    | Mode.Opaq =&gt; RETURN 16_00E20746;
    | Mode.Tran =&gt; RETURN 0;
    | Mode.Swap =&gt; RETURN 16_006A01E9;
    | Mode.Copy =&gt; RETURN 0;
    END;
  END ToFgTernaryRasterOp;

PROCEDURE <A NAME="NewPaintOp"><procedure>NewPaintOp</procedure></A> (VAR      st  : WinScreenType.T;
                      READONLY bop : Op;
                      READONLY fop : Op;
                               pix := -1): ScrnPaintOp.T =
  VAR
    res := NEW(ScrnPaintOp.T, pix := pix);
    rec : OpRecord;
  BEGIN
    rec.bop   := bop;
    rec.fop   := fop;
    rec.rop2  := ToBinaryRasterOp  (bop, fop);
    rec.brop3 := ToBgTernaryRasterOp (bop);
    rec.frop3 := ToFgTernaryRasterOp (fop);

    LOCK st.trsl DO
      WITH n = NUMBER(st.optable^) DO
        IF n = st.opcount THEN
          WITH new = NEW(REF ARRAY OF OpRecord, 2 * n) DO
            SUBARRAY (new^, 0, n) := st.optable^;
            st.optable := new;
          END;
        END;
      END;
      res.id := st.opcount;
      st.optable[res.id] := rec;
      INC(st.opcount);
    END;
    RETURN res
  END NewPaintOp;

BEGIN
END WinScrnPaintOp.
</PRE>
</inModule>
<PRE>























</PRE>
</BODY>
</HTML>
