<HTML>
<HEAD>
<TITLE>SRC Modula-3: ui/src/winvbt/WinPaint.m3</TITLE>
</HEAD>
<BODY>
<A NAME="0TOP0">
<H2>ui/src/winvbt/WinPaint.m3</H2></A><HR>
<inModule>
<PRE><A HREF="../../../COPYRIGHT.html">Copyright (C) 1994, Digital Equipment Corp.</A>
</PRE><BLOCKQUOTE><EM> Digital Internal Use Only                                                 </EM></BLOCKQUOTE><PRE>
</PRE>                                                                           
       Created on Mon Jun 26 09:33:27 PDT 1995 by najork                   

<P>
<P><PRE>UNSAFE MODULE <module><implements><A HREF="WinPaint.i3.html">WinPaint</A></implements></module>;   (* unsafe because of M3toC *)

IMPORT <A HREF="../vbt/Batch.i3.html">Batch</A>, <A HREF="../vbt/BatchRep.i3.html">BatchRep</A>, <A HREF="../vbt/BatchUtil.i3.html">BatchUtil</A>, <A HREF="../../../C/src/Common/Ctypes.i3.html">Ctypes</A>, <A HREF="../../../C/src/Common/M3toC.i3.html">M3toC</A>, <A HREF="../vbt/PaintExt.i3.html">PaintExt</A>, <A HREF="../vbt/PaintPrivate.i3.html">PaintPrivate</A>, <A HREF="../../../geometry/src/Path.i3.html">Path</A>,
       <A HREF="#x1">PathPrivate</A>, <A HREF="../../../geometry/src/Point.i3.html">Point</A>, <A HREF="../../../geometry/src/PolyRegion.i3.html">PolyRegion</A>, <A HREF="../../../geometry/src/Rect.i3.html">Rect</A>, <A HREF="../../../geometry/src/Region.i3.html">Region</A>, <A HREF="../vbt/ScrnFont.i3.html">ScrnFont</A>, <A HREF="../../../geometry/src/Trapezoid.i3.html">Trapezoid</A>,
       <A HREF="../vbt/Trestle.i3.html">Trestle</A>, <A HREF="../trestle/TrestleImpl.i3.html">TrestleImpl</A>, <A HREF="../vbt/VBT.i3.html">VBT</A>, <A HREF="../vbt/VBTRep.i3.html">VBTRep</A>, <A HREF="../../../win32/src/WinBase.i3.html">WinBase</A>, <A HREF="WinContext.i3.html">WinContext</A>, <A HREF="../../../win32/src/WinDef.i3.html">WinDef</A>, <A HREF="../../../win32/src/WinGDI.i3.html">WinGDI</A>,
       <A HREF="WinScreenType.i3.html">WinScreenType</A>, <A HREF="WinScreenTypePrivate.i3.html">WinScreenTypePrivate</A>, <A HREF="WinScrnFont.i3.html">WinScrnFont</A>, <A HREF="WinScrnPaintOp.i3.html">WinScrnPaintOp</A>,
       <A HREF="WinScrnPixmap.i3.html">WinScrnPixmap</A>, <A HREF="../../../word/src/Word.i3.html">Word</A>;

TYPE
  PC = PaintPrivate.PaintCommand;

CONST
  (** False = 0; **)
  True  = 1;

  ComSize = ADRSIZE (PaintPrivate.CommandRec);

VAR
  Chicago            := IsChicago ();
  Bug95_SetDIBits    := FALSE; (* Chicago; *)
  Bug95_PatternBrush := Chicago;

PROCEDURE <A NAME="PaintBatch"><procedure>PaintBatch</procedure></A> (self: Trestle.T; v: VBT.T; ba: Batch.T;  hdc: WinDef.HDC) =
  VAR
    cmdP  := LOOPHOLE (ADR (ba.b[0]), PaintPrivate.CommandPtr);
    endP  : PaintPrivate.CommandPtr := ba.next;
    st    : WinScreenType.T := v.st;
  BEGIN
    IF ba.clip.west &gt;= ba.clip.east OR st = NIL THEN
      Batch.Free (ba);
      RETURN;
    END;
    IF ba.clipped = BatchUtil.ClipState.Unclipped THEN
      BatchUtil.Clip (ba);
    END;
    LOCK self DO
      WHILE cmdP &lt; endP DO
        CASE cmdP.command OF
        | PC.TintCom =&gt;
          cmdP := TintCom (cmdP, endP, hdc, st);
        | PC.TextureCom =&gt;
          cmdP := TextureCom (cmdP, endP, hdc, st);
        | PC.PixmapCom =&gt;
          cmdP := PixmapCom (cmdP, endP, hdc, st);
        | PC.ScrollCom =&gt;
          cmdP := ScrollCom (cmdP, hdc, st);
        | PC.TrapCom =&gt;
          cmdP := TrapCom (cmdP, endP, hdc, st);
        | PC.TextCom =&gt;
          cmdP := TextCom (cmdP, cmdP, endP, hdc, st);
        | PC.ExtensionCom =&gt;
          cmdP := ExtensionCom (cmdP, endP, hdc, self, st);
        | PC.RepeatCom =&gt;
          INC (cmdP, ComSize);
        ELSE
          EXIT;
        END
      END;
      Batch.Free(ba);
    END;
  END PaintBatch;
</PRE>***************************************************************************
 Painting Tints                                                            
***************************************************************************

<P>
<P><PRE>PROCEDURE <A NAME="TintCom"><procedure>TintCom</procedure></A> (cmdP, endP: PaintPrivate.CommandPtr;
                   hdc       : WinDef.HDC;
                   st        : WinScreenType.T): PaintPrivate.CommandPtr =
  BEGIN
    WITH op   = LOOPHOLE (cmdP, PaintPrivate.TintPtr)^,
         ctxt = WinContext.PushTint (hdc, st, op.op) DO
      FillRect (hdc, op.clip);
      INC (cmdP, ADRSIZE (op));
      WHILE cmdP &lt; endP AND cmdP.command = PC.RepeatCom DO
        FillRect (hdc, cmdP.clip);
        INC (cmdP, ComSize);
      END;
      WinContext.Pop (ctxt);
    END;
    RETURN cmdP;
  END TintCom;

PROCEDURE <A NAME="FillRect"><procedure>FillRect</procedure></A> (hdc: WinDef.HDC; READONLY r: Rect.T) =
  VAR
    rc    : WinDef.RECT;
    pen   : WinDef.HPEN;
    oldPen: WinDef.HPEN;
    status: WinDef.BOOL;
  BEGIN
    IF r.west &lt; r.east THEN
      rc := FromRect(r);

      (*
       * One would assume that
       *     EVAL WinUser.FillRect (hdc, ADR(rc), hbr);
       * should be sufficient here. However, &quot;WinUser.FillRect&quot; ignores the
       * current raster operation mode for some reason.
       *)

      (* Load an invisible pen into the DC *)
      oldPen := WinGDI.SelectObject (hdc,
                                     WinGDI.GetStockObject (WinGDI.NULL_PEN));
      &lt;* ASSERT oldPen # NIL *&gt;

      (* &quot;WinGDI.Rectangle&quot; uses both the current pen and the current brush *)
      status := WinGDI.Rectangle (hdc, r.west, r.north, r.east+1, r.south+1);
      &lt;* ASSERT status = True *&gt;

      pen := WinGDI.SelectObject (hdc, oldPen);
      &lt;* ASSERT pen # NIL *&gt;
    END;
  END FillRect;
</PRE>*******************
(*
 * Debugging gear
 
<PRE>PROCEDURE StrokeRect (hdc: WinDef.HDC; READONLY r: Rect.T) =
  VAR
    rc    : WinDef.RECT;
    oldBr : WinDef.HBRUSH;
    oldPen: WinDef.HPEN;
    status: WinDef.BOOL;
  BEGIN
    IF r.west &lt; r.east THEN
      rc := FromRect(r);

      oldPen := WinGDI.SelectObject (hdc,
                                     WinGDI.GetStockObject (WinGDI.BLACK_PEN));
      &lt;* ASSERT oldPen # NIL *&gt;
      oldBr := WinGDI.SelectObject (hdc,
                                    WinGDI.GetStockObject (WinGDI.NULL_BRUSH));
      &lt;* ASSERT oldBr # NIL *&gt;
      (* &quot;WinGDI.Rectangle&quot; uses both the current pen and the current brush *)
      status := WinGDI.Rectangle (hdc, r.west, r.north, r.east+1, r.south+1);
      &lt;* ASSERT status = True *&gt;
      oldBr := WinGDI.SelectObject (hdc, oldBr);
      oldPen := WinGDI.SelectObject (hdc, oldPen);
    END;
  END StrokeRect;
*************)
</PRE>***********
(*
 * More debugging gear
 
<PRE>PROCEDURE MarkPoint (hdc: WinDef.HDC; READONLY a: Point.T) =
  VAR
    oldPen: WinDef.HGDIOBJ;
  BEGIN
    oldPen := WinGDI.SelectObject (hdc,
                                   WinGDI.GetStockObject (WinGDI.BLACK_PEN));
    &lt;* ASSERT oldPen # NIL *&gt;
    DrawLine(hdc, Point.T{a.h - 2, a.v}, Point.T{a.h + 2, a.v});
    DrawLine(hdc, Point.T{a.h, a.v - 2}, Point.T{a.h, a.v + 2});
    oldPen := WinGDI.SelectObject (hdc, oldPen);
  END MarkPoint;
***********)
</PRE>***************************************************************************
 Painting textures                                                         
***************************************************************************

<P>
<P><PRE>PROCEDURE <A NAME="TextureCom"><procedure>TextureCom</procedure></A> (cmdP, endP: PaintPrivate.CommandPtr;
                      hdc       : WinDef.HDC;
                      st        : WinScreenType.T): PaintPrivate.CommandPtr =
  VAR
    fastPath : BOOLEAN;
    status   : WinDef.BOOL;
    comdc    : WinDef.HDC;
    bitmap   : WinDef.HBITMAP;
    oldBitmap: WinDef.HBITMAP;
    pm       : PaintPrivate.Pixmap;
    delta    : Point.T;
    pst      : WinScreenType.T;
    color    : WinDef.COLORREF;
    brush    : WinDef.HBRUSH;
    auxBrush : WinDef.HBRUSH;
    brop     : INTEGER;
    frop     : INTEGER;
    pat0     : INTEGER;
    pat1     : INTEGER;
  BEGIN
    WITH op = LOOPHOLE (cmdP, PaintPrivate.PixmapPtr)^ DO

      IF Bug95_PatternBrush AND NOT PixmapIs8x8 (op.pm, st) THEN
        RETURN ChicagoTextureCom (cmdP, endP, hdc, st);
      END;

      (* First, determine if we can use a fast path.  For Windows NT, the fast
         path is to fill the rectangle directly using a pattern brush.  The
         slow path is to copy the texture onto a memory device context, and
         then to repeatedly bit-blit this memory device context onto &quot;hdc&quot;. *)

      IF op.op &gt;= 0 AND st.optable # NIL AND op.op &lt; NUMBER(st.optable^) THEN
        WITH tbl = st.optable[op.op] DO
          fastPath := (tbl.bop.mode = tbl.fop.mode);
        END;
      ELSE
        fastPath := TRUE;
      END;

      IF NOT fastPath THEN

        (* Create a compatible device context *)
        comdc := WinGDI.CreateCompatibleDC (hdc);
        (* Create a bitmap that can hold the rectangle covered by op.clip *)
        bitmap := WinGDI.CreateCompatibleBitmap (hdc,
                                                 op.clip.east - op.clip.west,
                                                 op.clip.south - op.clip.north);
        (* Select the bitmap into &quot;comdc&quot;. *)
        oldBitmap := WinGDI.SelectObject (comdc, bitmap);

        (* Map point (&quot;op.clip.west&quot;,&quot;op.clip.north&quot;) of page space to point
           (0,0) of device space. Since the device is a bitmap of width
           &quot;op.clip.east - op.clip.west&quot; and height &quot;op.clip.south -
           op.clip.north&quot;, the rectangle &quot;op.clip&quot; of page space is mapped
           onto the device. *)
        status := WinGDI.SetWindowOrgEx (comdc, op.clip.west, op.clip.north, NIL);
        status := WinGDI.SetViewportOrgEx (comdc, 0, 0, NIL);

        (* I dabbled a bit around with &quot;SetWorldTransform&quot;, but could
           not get it to work. Anyways, &quot;SetWordTransform&quot; is supported
           under NT, but not under Chicago. *)

        delta := op.delta;
        IF delta # Point.Origin THEN
          WITH pmb = WinScrnPixmap.PixmapDomain (st, pm) DO
            IF NOT Rect.IsEmpty (pmb) THEN
              delta := Rect.Mod (delta, pmb);
            END;
          END;
        END;

        pm := op.pm;
        IF pm &lt; 0 THEN
          pm := WinScrnPixmap.SolidPixmap - pm;
          pst := st.bits;
        ELSE
          pst := st;
        END;

        IF op.op &gt;= 0 AND st.optable # NIL AND op.op &lt; NUMBER(st.optable^) AND
          pst.pmtable # NIL AND pm &lt; NUMBER (pst.pmtable^) THEN
          WITH tbl = st.optable[op.op] DO

            (* Select the pixmap into a pattern brush *)
            brush := WinGDI.CreatePatternBrush (pst.pmtable[pm].hbmp);
            &lt;* ASSERT brush # NIL *&gt;

            (* Set the pattern brush origin. The Windows way to do this is
               confusing in two respects: (1) One has to set the origin BEFORE
               selecting the brush into the device context, and (2) the origin
               is specified in device space, not in world/page space. *)

            status := WinGDI.SetBrushOrgEx (comdc,
                                            delta.h - op.clip.west,
                                            delta.v - op.clip.north,
                                            NIL);
            &lt;* ASSERT status = True *&gt;

            auxBrush := WinGDI.SelectObject (comdc, brush);
            &lt;* ASSERT auxBrush # NIL *&gt;

            (* In Windows, '0' pixels of the bitmap in the pattern brush are
               drawn in the current text color, so the text color should be
               &quot;tbl.bop.col&quot;. '1' pixels are drawn in the current background
               color, so this color should be &quot;tbl.fop.col&quot;. Counterintuive?
               Well, after all, this is Windows! *)

            (* Draw the pixels which are 0 in &quot;pst.pmtable[pm].hbmp&quot; as black
               (all 0's), and the pixels which are 1 as white (all 1's) into
               &quot;comdc&quot;. *)

            (* Setting the colors of comdc seems to have no effect. *)
            color := WinGDI.SetTextColor (comdc, WinGDI.RGB(0,0,0));
            &lt;* ASSERT color # WinGDI.CLR_INVALID *&gt;
            color := WinGDI.SetBkColor (comdc, WinGDI.RGB(255,255,255));
            &lt;* ASSERT color # WinGDI.CLR_INVALID *&gt;

            color := WinGDI.SetTextColor (hdc, WinGDI.RGB(0,0,0));
            &lt;* ASSERT color # WinGDI.CLR_INVALID *&gt;
            color := WinGDI.SetBkColor (hdc, WinGDI.RGB(255,255,255));
            &lt;* ASSERT color # WinGDI.CLR_INVALID *&gt;

            brop := tbl.brop3;
            frop := tbl.frop3;

            pat0 := tbl.bop.col;
            pat1 := tbl.fop.col;

          END;
        ELSE
          brop := 0;
          frop := 0;
        END;

        (* Fill comdc, using the pattern brush *)
        FillRect (comdc, op.clip);

        (* STILL TO DO: delete &quot;brush&quot; *)

        BitBltFill (hdc, pat0, brop, op.clip, comdc);
        BitBltFill (hdc, pat1, frop, op.clip, comdc);
        INC (cmdP, ADRSIZE(op));

        WHILE cmdP &lt; endP AND cmdP.command = PC.RepeatCom DO
          BitBltFill (hdc, pat0, brop, cmdP.clip, comdc);
          BitBltFill (hdc, pat1, frop, cmdP.clip, comdc);
          INC (cmdP, ComSize);
        END;

        status := WinGDI.DeleteDC (comdc);
        &lt;* ASSERT status = True *&gt;
        status := WinGDI.DeleteObject (bitmap);
        &lt;* ASSERT status = True *&gt;

      ELSE (* fastPath = TRUE *)

        WITH ctxt = WinContext.PushTexture (hdc, st, op.op, op.pm, op.delta) DO

          FillRect (hdc, op.clip);
          INC (cmdP, ADRSIZE(op));
          WHILE cmdP &lt; endP AND cmdP.command = PC.RepeatCom DO
            FillRect (hdc, cmdP.clip);
            INC (cmdP, ComSize);
          END;

          WinContext.Pop (ctxt);
        END;

      END;
    END;

    RETURN cmdP;
  END TextureCom;

PROCEDURE <A NAME="PixmapIs8x8"><procedure>PixmapIs8x8</procedure></A> (pm: PaintPrivate.Pixmap; st: WinScreenType.T): BOOLEAN =
  BEGIN
    IF pm &lt; 0 THEN
      pm := WinScrnPixmap.SolidPixmap - pm;
      st := st.bits;
    END;
    IF st.pmtable # NIL AND pm &lt; NUMBER (st.pmtable^) THEN
      WITH rect = st.pmtable[pm].domain DO
        RETURN Rect.VerSize (rect) = 8 AND Rect.HorSize (rect) = 8;
      END;
    ELSE
      RETURN TRUE;
    END;
  END PixmapIs8x8;

PROCEDURE <A NAME="ChicagoTextureCom"><procedure>ChicagoTextureCom</procedure></A> (cmdP, endP: PaintPrivate.CommandPtr;
                             hdc       : WinDef.HDC;
                             st        : WinScreenType.T): PaintPrivate.CommandPtr =
  VAR
    dci   : INTEGER;
    status: WinDef.BOOL;
  BEGIN
    WITH op = LOOPHOLE (cmdP, PaintPrivate.PixmapPtr)^ DO

      dci := WinGDI.SaveDC (hdc);
      &lt;* ASSERT dci # 0 *&gt;

      ClipToRect (hdc, op.clip);
      ChicagoFill (hdc, st, op.clip, op.op, op.pm, op.delta, TRUE);

      status := WinGDI.RestoreDC (hdc, -1);
      &lt;* ASSERT status = True *&gt;

      INC (cmdP, ADRSIZE(op));
      WHILE cmdP &lt; endP AND cmdP.command = PC.RepeatCom DO

        dci := WinGDI.SaveDC (hdc);
        &lt;* ASSERT dci # 0 *&gt;

        ClipToRect (hdc, cmdP.clip);
        ChicagoFill (hdc, st, cmdP.clip, op.op, op.pm, op.delta, TRUE);

        status := WinGDI.RestoreDC (hdc, -1);
        &lt;* ASSERT status = True *&gt;

        INC (cmdP, ComSize);
      END;

    END;
    RETURN cmdP;
  END ChicagoTextureCom;

PROCEDURE <A NAME="ClipToRect"><procedure>ClipToRect</procedure></A> (hdc: WinDef.HDC; clip: Rect.T) =
  VAR
    hrgn  : WinDef.HRGN;
    status: WinDef.BOOL;
  BEGIN
    hrgn := WinGDI.CreateRectRgn (clip.west, clip.north,
                                  clip.east, clip.south);
    &lt;* ASSERT hrgn # NIL *&gt;

    status := WinGDI.SelectClipRgn (hdc, hrgn);
    &lt;* ASSERT status # WinGDI.ERROR *&gt;

    status := WinGDI.DeleteObject (hrgn);
    &lt;* ASSERT status = True *&gt;
  END ClipToRect;

PROCEDURE <A NAME="ChicagoFill"><procedure>ChicagoFill</procedure></A> (hdc  : WinDef.HDC;
                       st   : WinScreenType.T;
                       rect : Rect.T;
                       op   : PaintPrivate.PaintOp;
                       pm   : PaintPrivate.Pixmap;
                       delta: Point.T;
                       tile : BOOLEAN) =

  PROCEDURE BitBlt (hdc   : WinDef.HDC;
                    col   : WinDef.COLORREF;
                    rop   : WinDef.DWORD;
                    rect  : Rect.T;
                    delta : Point.T;
                    comdc : WinDef.HDC;
                    width : INTEGER;
                    height: INTEGER;
                    tile  : BOOLEAN) =
    VAR
      oldBrush: WinDef.HBRUSH;
      solBrush: WinDef.HBRUSH;
      status  : WinDef.BOOL;
    BEGIN
      IF rop # 0 THEN
        solBrush := WinGDI.CreateSolidBrush (col);
        &lt;* ASSERT solBrush # NIL *&gt;
        oldBrush := WinGDI.SelectObject (hdc, solBrush);
        &lt;* ASSERT oldBrush # NIL *&gt;

        WITH west = rect.west - (rect.west - delta.h) MOD width,
             north = rect.north - (rect.north - delta.v) MOD height DO
          IF tile THEN
            FOR x := west TO rect.east - 1 BY width DO
              FOR y := north TO rect.south - 1 BY height DO

                status := WinGDI.BitBlt (hdc, x, y, width, height,
                                         comdc, 0, 0, rop);
                &lt;* ASSERT status = True *&gt;
              END;
            END;
          ELSE
            status := WinGDI.BitBlt (hdc, west, north, width, height,
                                     comdc, 0, 0, rop);
            &lt;* ASSERT status = True *&gt;
          END;
        END;

        oldBrush := WinGDI.SelectObject (hdc, oldBrush);
        &lt;* ASSERT oldBrush = solBrush *&gt;
        status := WinGDI.DeleteObject (solBrush);
        &lt;* ASSERT status = True *&gt;
      END;
    END BitBlt;

  VAR
    pst     : WinScreenType.T;
    comdc   : WinDef.HDC;
    oldBmp  : WinDef.HBITMAP;
    hbmp    : WinDef.HBITMAP;
    status  : WinDef.BOOL;
    bmi     : WinGDI.BITMAPINFO;
    k       := 0;
  BEGIN
    IF delta # Point.Origin THEN
      WITH pmb = WinScrnPixmap.PixmapDomain (st, pm) DO
        IF NOT Rect.IsEmpty (pmb) THEN
          delta := Rect.Mod (delta, pmb);
        END;
      END;
    END;

    IF pm &lt; 0 THEN
      pm := WinScrnPixmap.SolidPixmap - pm;
      pst := st.bits;
    ELSE
      pst := st;
    END;

    IF op &gt;= 0 AND st.optable # NIL AND op &lt; NUMBER(st.optable^) AND
       pst.pmtable # NIL AND pm &lt; NUMBER (pst.pmtable^) THEN

      WITH tbl    = st.optable[op],
           spm    = pst.pmtable[pm],
           height = Rect.VerSize (spm.domain),
           width  = Rect.HorSize (spm.domain),
           pixels = NEW (REF ARRAY OF WinGDI.RGBQUAD, height * width) DO

        comdc := WinGDI.CreateCompatibleDC (hdc);
        &lt;* ASSERT comdc # NIL *&gt;

        hbmp := WinGDI.CreateCompatibleBitmap (hdc, width, height);
        &lt;* ASSERT hbmp # NIL *&gt;

        WITH h = bmi.bmiHeader DO
          h.biSize := BYTESIZE(WinGDI.BITMAPINFOHEADER);
          h.biWidth := width;
          h.biHeight := height;
          h.biPlanes := 1;
          h.biBitCount := BITSIZE (WinDef.COLORREF);
          h.biCompression := WinGDI.BI_RGB;
        END;

        status := WinGDI.GetDIBits (comdc,
                                    spm.hbmp,
                                    0,             (* start at scan line 0 *)
                                    height,        (* copy &quot;height&quot; lines *)
                                    ADR(pixels[0]),(* into &quot;pixels&quot; *)
                                    ADR (bmi),
                                    WinGDI.DIB_RGB_COLORS);
        &lt;* ASSERT status = height *&gt;

        (* On NT, we can use &quot;SetDIBits&quot; to copy &quot;pixels&quot; into &quot;hbmp&quot;.
           On Windows 95, the bitmap comes out black. So, we copy the
           pixels individually, using &quot;SetPixelV&quot;. This works fine
           both on NT and on Windows 95.

           Note that the spec of &quot;SetDIBits&quot; says that &quot;hbmp&quot; must not be
           selected into &quot;comdc&quot;, while the spec of &quot;SetPixelV&quot; says that
           it must be. *)

        IF NOT Bug95_SetDIBits THEN
          status := WinGDI.SetDIBits (comdc,
                                      hbmp,
                                      0,
                                      height,
                                      ADR(pixels[0]),
                                      ADR (bmi),
                                      WinGDI.DIB_RGB_COLORS);
          &lt;* ASSERT status = height *&gt;

          oldBmp := WinGDI.SelectObject (comdc, hbmp);
          &lt;* ASSERT oldBmp # NIL *&gt;

        ELSE (* Bug95_SetDIBits = TRUE *)

          oldBmp := WinGDI.SelectObject (comdc, hbmp);
          &lt;* ASSERT oldBmp # NIL *&gt;

          k := 0;
          FOR y := height - 1 TO 0 BY -1 DO
            FOR x := 0 TO width - 1 DO
              WITH p = pixels[k],
                   col = WinGDI.RGB (p.rgbRed, p.rgbGreen, p.rgbBlue) DO
                status := WinGDI.SetPixelV (comdc, x, y, col);
                &lt;* ASSERT status = True *&gt;
                INC (k);
              END;
            END;
          END;

        END;

        BitBlt (hdc, tbl.bop.col, tbl.brop3, rect, delta,
                comdc, width, height, tile);
        BitBlt (hdc, tbl.fop.col, tbl.frop3, rect, delta,
                comdc, width, height, tile);

        status := WinGDI.DeleteDC (comdc);
        &lt;* ASSERT status = True *&gt;
        status := WinGDI.DeleteObject (hbmp);
        &lt;* ASSERT status = True *&gt;
      END;
    ELSE
      (* &quot;op&quot; not in &quot;st.optable&quot;, or &quot;pm&quot; not in &quot;pst.pmtable&quot; - do nothing *)
    END;
  END ChicagoFill;
</PRE>***************************************************************************
 Painting pixmaps                                                          
***************************************************************************

<P> For now, I try to treat pixmaps just like textures. This might not work 
   for color pixmaps, and might not work for every PaintOp. 
<P>
   This code has not been tested for every possible PaintOp and for color.
   It seems to work with PaintOp.BgFg and with PaintOp.TransparentFg.
   I should run a fullsuite of tests once I got rudimentary color working.
<P>
   Note that the Win32 specification states that WinGDI.SetBrushOrgEx works
   only for x and y coordinates between 0 and 7, and that I assume it to 
   work for arbitrary coordinates. Under NT, this seems to be ok, but there
   is no guarantee that it will work under Windows 95. 

<P>
<P><PRE>PROCEDURE <A NAME="PixmapCom"><procedure>PixmapCom</procedure></A> (cmdP, endP: PaintPrivate.CommandPtr;
                     hdc       : WinDef.HDC;
                     st        : WinScreenType.T): PaintPrivate.CommandPtr =
  VAR
    fastPath : BOOLEAN;
    status   : WinDef.BOOL;
    comdc    : WinDef.HDC;
    bitmap   : WinDef.HBITMAP;
    oldBitmap: WinDef.HBITMAP;
    pm       : PaintPrivate.Pixmap;
    delta    : Point.T;
    pst      : WinScreenType.T;
    apm      : PaintPrivate.Pixmap;
    color    : WinDef.COLORREF;
    brush    : WinDef.HBRUSH;
    auxBrush : WinDef.HBRUSH;
    oldBrush : WinDef.HBRUSH;
    brop     : INTEGER;
    frop     : INTEGER;
    pat0     : INTEGER;
    pat1     : INTEGER;
  BEGIN
    WITH op = LOOPHOLE (cmdP, PaintPrivate.PixmapPtr)^ DO

      IF Bug95_PatternBrush AND NOT PixmapIs8x8 (op.pm, st) THEN
        RETURN ChicagoPixmapCom (cmdP, endP, hdc, st);
      END;

      IF op.op &gt;= 0 AND st.optable # NIL AND op.op &lt; NUMBER(st.optable^) THEN
        WITH tbl = st.optable[op.op] DO
          brop := tbl.brop3;
          frop := tbl.frop3;
          fastPath := (tbl.bop.mode = tbl.fop.mode);
        END;
      ELSE
        fastPath := TRUE;
      END;

      IF NOT fastPath THEN

        (* Create a compatible device context *)
        comdc := WinGDI.CreateCompatibleDC (hdc);
        (* Create a bitmap that can hold the rectangle covered by op.clip *)
        bitmap := WinGDI.CreateCompatibleBitmap (hdc,
                                                 op.clip.east - op.clip.west,
                                                 op.clip.south - op.clip.north);
        (* Select the bitmap into &quot;comdc&quot;. *)
        oldBitmap := WinGDI.SelectObject (comdc, bitmap);

        (* Map point (&quot;op.clip.west&quot;,&quot;op.clip.north&quot;) of page space to point
           (0,0) of device space. Since the device is a bitmap of width
           &quot;op.clip.east - op.clip.west&quot; and height &quot;op.clip.south -
           op.clip.north&quot;, the rectangle &quot;op.clip&quot; of page space is mapped
           onto the device. *)
        status := WinGDI.SetWindowOrgEx (comdc, op.clip.west, op.clip.north, NIL);
        status := WinGDI.SetViewportOrgEx (comdc, 0, 0, NIL);

        (* I dabbled a bit around with &quot;SetWorldTransform&quot;, but could
           not get it to work. Anyways, &quot;SetWordTransform&quot; is supported
           under NT, but not under Chicago. *)

        (* Select the pixmap into a pattern brush *)
        pm := op.pm;  apm := pm;
        delta := op.delta;
        IF pm &lt; 0 THEN
          pm := WinScrnPixmap.SolidPixmap - pm;
          pst := st.bits;
        ELSE
          pst := st;
        END;
        IF delta # Point.Origin THEN
          WITH pmb = WinScrnPixmap.PixmapDomain (st, apm) DO
            IF NOT Rect.IsEmpty (pmb) THEN
              delta := Rect.Mod (delta, pmb);
            END;
          END;
        END;
        IF op.op &gt;= 0 AND st.optable # NIL AND op.op &lt; NUMBER(st.optable^) AND
          pst.pmtable # NIL AND pm &lt; NUMBER (pst.pmtable^) THEN
          WITH tbl = st.optable[op.op] DO

            brush := WinGDI.CreatePatternBrush (pst.pmtable[pm].hbmp);
            &lt;* ASSERT brush # NIL *&gt;

            (* Set the pattern brush origin. The Windows way to do this is
               confusing in two respects: (1) One has to set the origin BEFORE
               selecting the brush into the device context, and (2) the origin
               is specified in device space, not in world/page space. *)

            status := WinGDI.SetBrushOrgEx (comdc,
                                            delta.h - op.clip.west,
                                            delta.v - op.clip.north,
                                            NIL);
            &lt;* ASSERT status = True *&gt;

            auxBrush := WinGDI.SelectObject (comdc, brush);
            &lt;* ASSERT auxBrush # NIL *&gt;

            (* In Windows, '0' pixels of the bitmap in the pattern brush are
               drawn in the current text color, so the text color should be
               &quot;tbl.bop.col&quot;. '1' pixels are drawn in the current background
               color, so this color should be &quot;tbl.fop.col&quot;. Counterintuive?
               Well, after all, this is Windows! *)

            (* Draw the pixels which are 0 in &quot;pst.pmtable[pm].hbmp&quot; as black
               (all 0's), and the pixels which are 1 as white (all 1's) into
               &quot;comdc&quot;. *)

            (* Setting the colors of comdc seems to have no effect. *)
            color := WinGDI.SetTextColor (comdc, WinGDI.RGB(0,0,0));
            &lt;* ASSERT color # WinGDI.CLR_INVALID *&gt;
            color := WinGDI.SetBkColor (comdc, WinGDI.RGB(255,255,255));
            &lt;* ASSERT color # WinGDI.CLR_INVALID *&gt;

            color := WinGDI.SetTextColor (hdc, WinGDI.RGB(0,0,0));
            &lt;* ASSERT color # WinGDI.CLR_INVALID *&gt;
            color := WinGDI.SetBkColor (hdc, WinGDI.RGB(255,255,255));
            &lt;* ASSERT color # WinGDI.CLR_INVALID *&gt;

            pat0 := tbl.bop.col;
            pat1 := tbl.fop.col;

          END;
        ELSE
          brop := 0;
          frop := 0;
        END;

        (* Fill comdc, using the pattern brush *)
        FillRect (comdc, op.clip);

        oldBrush := WinGDI.GetCurrentObject (hdc, WinGDI.OBJ_BRUSH);

        BitBltFill (hdc, pat0, brop, op.clip, comdc);
        BitBltFill (hdc, pat1, frop, op.clip, comdc);
        INC (cmdP, ADRSIZE(op));

        WHILE cmdP &lt; endP AND cmdP.command = PC.RepeatCom DO
          BitBltFill (hdc, pat0, brop, cmdP.clip, comdc);
          BitBltFill (hdc, pat1, frop, cmdP.clip, comdc);
          INC (cmdP, ComSize);
        END;

        (* Clean up. *)
        brush := WinGDI.SelectObject (hdc, oldBrush);
        &lt;* ASSERT brush # NIL *&gt;
        status := WinGDI.DeleteObject (brush);
        &lt;* ASSERT status = True *&gt;

        status := WinGDI.DeleteDC (comdc);
        &lt;* ASSERT status = True *&gt;
        status := WinGDI.DeleteObject (bitmap);
        &lt;* ASSERT status = True *&gt;

      ELSE (* fastPath = TRUE *)

        WITH ctxt = WinContext.PushTexture (hdc, st, op.op, op.pm, op.delta) DO
          FillRect (hdc, op.clip);
          INC (cmdP, ADRSIZE(op));
          WHILE cmdP &lt; endP AND cmdP.command = PC.RepeatCom DO
            FillRect (hdc, cmdP.clip);
            INC (cmdP, ComSize);
          END;
          WinContext.Pop (ctxt);
        END;
      END;
    END;

    RETURN cmdP;
  END PixmapCom;

PROCEDURE <A NAME="ChicagoPixmapCom"><procedure>ChicagoPixmapCom</procedure></A> (
                cmdP, endP: PaintPrivate.CommandPtr;
                hdc       : WinDef.HDC;
                st        : WinScreenType.T): PaintPrivate.CommandPtr =
  VAR
    dci   : INTEGER;
    status: WinDef.BOOL;
  BEGIN
    WITH op = LOOPHOLE (cmdP, PaintPrivate.PixmapPtr)^ DO

      dci := WinGDI.SaveDC (hdc);
      &lt;* ASSERT dci # 0 *&gt;

      ClipToRect (hdc, op.clip);
      ChicagoFill (hdc, st, op.clip, op.op, op.pm, op.delta, FALSE);

      status := WinGDI.RestoreDC (hdc, -1);
      &lt;* ASSERT status = True *&gt;

      INC (cmdP, ADRSIZE(op));
      WHILE cmdP &lt; endP AND cmdP.command = PC.RepeatCom DO

        dci := WinGDI.SaveDC (hdc);
        &lt;* ASSERT dci # 0 *&gt;

        ClipToRect (hdc, cmdP.clip);
        ChicagoFill (hdc, st, cmdP.clip, op.op, op.pm, op.delta, FALSE);

        status := WinGDI.RestoreDC (hdc, -1);
        &lt;* ASSERT status = True *&gt;

        INC (cmdP, ComSize);
      END;

    END;
    RETURN cmdP;
  END ChicagoPixmapCom;

PROCEDURE <A NAME="BitBltFill"><procedure>BitBltFill</procedure></A> (hdc   : WinDef.HDC;
                      col   : WinDef.COLORREF;
                      rop   : WinDef.DWORD;
                      rect  : Rect.T;
                      comdc : WinDef.HDC) =
  VAR
    oldBrush: WinDef.HBRUSH;
    solBrush: WinDef.HBRUSH;
    status  : WinDef.BOOL;
  BEGIN
    IF rop # 0 THEN
      solBrush := WinGDI.CreateSolidBrush (col);
      &lt;* ASSERT solBrush # NIL *&gt;
      oldBrush := WinGDI.SelectObject (hdc, solBrush);
      &lt;* ASSERT oldBrush # NIL *&gt;

      status := WinGDI.BitBlt (hdc, rect.west, rect.north,
                               rect.east - rect.west,
                               rect.south - rect.north,
                               comdc, rect.west, rect.north, rop);
      &lt;* ASSERT status = True *&gt;

      oldBrush := WinGDI.SelectObject (hdc, oldBrush);
      &lt;* ASSERT oldBrush = solBrush *&gt;
      status := WinGDI.DeleteObject (solBrush);
      &lt;* ASSERT status = True *&gt;
    END;
  END BitBltFill;
</PRE>***************************************************************************
 Scrolling                                                                 
***************************************************************************

<P>
<P> So far, I only handle <CODE>cmdP.op = Paint.Copy</CODE>.  I'm not quite sure what
 * it means to apply general paint ops to a source whose depth is typically 
 * not 1. 
 

<P><PRE>PROCEDURE <A NAME="ScrollCom"><procedure>ScrollCom</procedure></A> (cmdP: PaintPrivate.CommandPtr;
                     hdc : WinDef.HDC;
                     st  : WinScreenType.T): PaintPrivate.CommandPtr =
  VAR
    trop := 16_00AA0029;  (* Ternary raster op code for NO-OP *)
  BEGIN
    WITH op = LOOPHOLE (cmdP, PaintPrivate.ScrollPtr)^ DO
      IF op.op &gt;= 0 AND st.optable # NIL AND op.op &lt; NUMBER (st.optable^) THEN
        WITH tbl = st.optable[op.op] DO
          IF tbl.bop.mode = WinScrnPaintOp.Mode.Copy THEN
            trop := tbl.brop3;
          END;
        END;
      END;

      INC (cmdP, ADRSIZE (op));
      IF CopyRectWithinDC (hdc, trop, op.clip, op.delta) THEN
</PRE><BLOCKQUOTE><EM><P>
 * At this point, the xvbt counterpart has the following code:
 *
 *      XScrollQueue.Insert (ur.scrollQ, op^);
 *      IF Region.OverlapRect (Rect.Sub (op.clip, op.delta), ur.badR)
 *           AND NOT Region.SubsetRect (op.clip, ur.badR) THEN
 *        ur.badR := Region.Join (Region.MeetRect (op.clip, 
 *                                                 Region.Add (ur.badR, 
 *                                                             op.delta)), 
 *                                ur.badR)
 *      END;
 </EM></BLOCKQUOTE><PRE>
      END;
    END;
    RETURN cmdP;
  END ScrollCom;

PROCEDURE <A NAME="CopyRectWithinDC"><procedure>CopyRectWithinDC</procedure></A> (         hdc  : WinDef.HDC;
                                     trop : WinDef.DWORD;
                            READONLY clip : Rect.T;
                            READONLY delta: Point.T): BOOLEAN =
  VAR
    status: WinDef.BOOL;
  BEGIN
    IF clip.west &lt; clip.east + 1 AND clip.north &lt; clip.south + 1 THEN
      status := WinGDI.BitBlt (hdc,
                               clip.west,
                               clip.north,
                               clip.east - clip.west,
                               clip.south - clip.north,
                               hdc,
                               clip.west - delta.h,

                               clip.north - delta.v,
                               trop);
      &lt;* ASSERT status = True *&gt;
      RETURN TRUE;
    ELSE
      RETURN FALSE;
    END;
  END CopyRectWithinDC;
</PRE>***************************************************************************
 Painting Trapezoids                                                       
***************************************************************************

<P>
<P><PRE>PROCEDURE <A NAME="TrapCom"><procedure>TrapCom</procedure></A> (cmdP, endP: PaintPrivate.CommandPtr;
                   hdc       : WinDef.HDC;
                   st        : WinScreenType.T): PaintPrivate.CommandPtr =
  BEGIN
    WITH op   = LOOPHOLE (cmdP, PaintPrivate.TrapPtr)^,
         ctxt = WinContext.PushTexture (hdc, st, op.op, op.pm, op.delta) DO

      IF op.m1.n &lt; 0 THEN
        op.m1.n := -op.m1.n;
        op.m1.d := -op.m1.d;
      ELSIF op.m1.n = 0 THEN
        INC (cmdP, ADRSIZE(op));
        RETURN cmdP;
      END;
      IF op.m2.n &lt; 0 THEN
        op.m2.n := -op.m2.n;
        op.m2.d := -op.m2.d;
      ELSIF op.m2.n = 0 THEN
        INC (cmdP, ADRSIZE(op));
        RETURN cmdP;
      END;

      Trap (hdc, op, op.clip);
      INC (cmdP, ADRSIZE(op));

      WHILE cmdP &lt; endP AND cmdP.command = PC.RepeatCom DO
        Trap (hdc, op, cmdP.clip);
        INC (cmdP, ComSize);
      END;

      WinContext.Pop (ctxt);
    END;
    RETURN cmdP;
  END TrapCom;

PROCEDURE <A NAME="Trap"><procedure>Trap</procedure></A> (         hdc : WinDef.HDC;
                READONLY tr  : PaintPrivate.TrapRec;
                READONLY clip: Rect.T) =

  PROCEDURE HW (READONLY m: Trapezoid.Rational;
                READONLY p: Point.T;
                         v: INTEGER): INTEGER =
    (* Return ceiling of the h-coordinate of the intersection of the
       trapezoid edge determined by (m, p) with the horizontal line at height
       v. *)
    BEGIN
      RETURN p.h + (m.d * (v - p.v) + m.n - 1) DIV m.n;
    END HW;

  PROCEDURE HF (READONLY m: Trapezoid.Rational;
                READONLY p: Point.T;
                         v: INTEGER): INTEGER =
    (* Return fractional part of (ceiling - actual) of intersection above *)
    BEGIN
      RETURN -m.d * (v - p.v) MOD m.n;
    END HF;

  VAR
    vlo, vhi, hw1, hw2, hf1, hf2, mw1, mw2, mf1, mf2, lft, rit: INTEGER;
    empty                                                     : BOOLEAN;
  BEGIN
    IF clip.west &gt;= clip.east THEN
      RETURN;
    END;
    vlo := clip.north;
    vhi := clip.south;
    IF tr.m1.d = 0 AND tr.m2.d = 0 THEN
      FillRect (hdc,
                Rect.Meet (clip, Rect.FromEdges (tr.p1.h, tr.p2.h, vlo, vhi)));
      RETURN;
    END;
    hw1 := HW (tr.m1, tr.p1, vlo);
    IF hw1 &gt;= clip.east AND HW (tr.m1, tr.p1, vhi - 1) &gt;= clip.east THEN
      RETURN;
    END;
    hw2 := HW (tr.m2, tr.p2, vlo);
    IF hw2 &lt;= clip.west AND HW (tr.m2, tr.p2, vhi - 1) &lt;= clip.west THEN
      RETURN;
    END;
    hf1 := HF (tr.m1, tr.p1, vlo);
    hf2 := HF (tr.m2, tr.p2, vlo);
    mw1 := tr.m1.d DIV tr.m1.n;
    mf1 := tr.m1.d MOD tr.m1.n;
    mw2 := tr.m2.d DIV tr.m2.n;
    mf2 := tr.m2.d MOD tr.m2.n;
    empty := TRUE;           (* set to false as soon as something is painted *)
    WHILE vlo # vhi DO
      lft := MAX (hw1, clip.west);
      rit := MIN (hw2, clip.east);
      IF lft &lt; rit THEN
        FillRect (hdc, Rect.FromEdges (lft, rit, vlo, vlo + 1));
        empty := FALSE;
      ELSIF lft &gt; rit AND NOT empty THEN
        (* Generated some painting and then found [lft ..  rit) empty by more
           than one pixel; hence all the remaining lines will be empty, hence:
         *)
        RETURN;
      END;
      (* Advance to next scan line: *)
      INC (vlo);
      INC (hw1, mw1);
      DEC (hf1, mf1);
      IF hf1 &lt; 0 THEN
        INC (hf1, tr.m1.n);
        INC (hw1)
      END;
      INC (hw2, mw2);
      DEC (hf2, mf2);
      IF hf2 &lt; 0 THEN
        INC (hf2, tr.m2.n);
        INC (hw2);
      END;
    END;
  END Trap;
</PRE>***************************************************************************
 Painting Text                                                             
***************************************************************************

<P>
<P><PRE>PROCEDURE <A NAME="TextCom"><procedure>TextCom</procedure></A> (cmd       : PaintPrivate.CommandPtr;
                   pAdr, endP: PaintPrivate.CommandPtr;
                   hdc       : WinDef.HDC;
                   st        : WinScreenType.T): PaintPrivate.CommandPtr =
  TYPE
    Mode = {PaintBackground, LeaveBackground};
  VAR
    pr        : PolyRegion.T;
    brush, oldBrush : WinDef.HBRUSH;
    oldFont   : WinDef.HFONT;
    oldColor  : WinDef.COLORREF;
    oldBgColor: WinDef.COLORREF;
    oldBgMode : Ctypes.int;
    mode      : Mode;
    status    : WinDef.BOOL;
  BEGIN
    WITH op      = LOOPHOLE (cmd, PaintPrivate.TextPtr),
         clipped = PaintPrivate.Prop.Clipped IN op.props DO

      (* This chunk of code replaces XGC.ResolveTextGC.
       * Unresolved:
       *   - mode determination: In xvbt, the mode depends on the &quot;fill_style&quot;
       *     of the XScrnTpRep.OpRecord: &quot;X.FillOpaqueStippled&quot; sets the mode
       *     to &quot;UseImageString&quot; (ie &quot;PaintBackground&quot;), otherwise it is
       *     is &quot;UseDrawString&quot; (ie &quot;LeaveBackground&quot;).
       *   - raster operations for text
       *)
      oldFont := WinGDI.SelectObject (hdc, WinScrnFont.FromFont (op.fnt));
      &lt;* ASSERT oldFont # NIL *&gt;

      IF op.op &gt;= 0 AND st.optable # NIL AND op.op &lt; NUMBER(st.optable^) THEN
        WITH tbl = st.optable[op.op] DO
          (* The brush is used for erasing the background *)
          brush := WinGDI.CreateSolidBrush (tbl.bop.col);
          &lt;* ASSERT brush # NIL *&gt;
          oldBrush := WinGDI.SelectObject (hdc, brush);
          &lt;* ASSERT oldBrush # NIL *&gt;
          oldColor := WinGDI.SetTextColor (hdc, tbl.fop.col);
          &lt;* ASSERT oldColor # WinGDI.CLR_INVALID *&gt;

          IF FALSE THEN
            oldBgColor := WinGDI.SetBkColor (hdc, tbl.bop.col);
            &lt;* ASSERT oldBgColor # WinGDI.CLR_INVALID *&gt;
            oldBgMode := WinGDI.SetBkMode (hdc, WinGDI.OPAQUE);
            &lt;* ASSERT oldBgMode # 0 *&gt;
            mode := Mode.PaintBackground;
          ELSE
            oldBgMode := WinGDI.SetBkMode (hdc, WinGDI.TRANSPARENT);
            &lt;* ASSERT oldBgMode # 0 *&gt;
            mode := Mode.LeaveBackground;
          END;
        END;
      ELSE
        (* don't draw anything *)
      END;

      WITH subbed = (mode = Mode.PaintBackground)
           AND PaintPrivate.Prop.FontSub IN op.props DO
        INC (pAdr, op.szOfRec * ADRSIZE(Word.T));
        IF NOT clipped THEN
          IF op.clip.west &lt; op.clip.east THEN
            IF subbed THEN
              FillRect (hdc, op.clip)
            END;
            PaintString(hdc, st, op)
          END
        ELSE
          pr := PolyRegion.Empty;
          PolyRegion.JoinRect (pr, op.clip);
          WHILE  pAdr &lt; endP AND pAdr.command = PC.RepeatCom DO
            IF PolyRegion.OverlapRect (pr, pAdr.clip) THEN
              WITH rgn = PolyRegion.ToRegion (pr) DO
                IF NOT Region.IsEmpty (rgn) THEN
                  SetClipRegion (hdc, rgn);
                  IF subbed THEN
                    FillRect (hdc, rgn.r)
                  END;
                  PaintString (hdc, st, op);
                  UnsetClipRegion (hdc);
                END
              END;
              pr := PolyRegion.Empty
            END;
            PolyRegion.JoinRect (pr, pAdr.clip);
            INC (pAdr, ComSize);
          END;
          WITH rgn = PolyRegion.ToRegion (pr) DO
            IF NOT Region.IsEmpty (rgn) THEN
              SetClipRegion (hdc, rgn);
              IF subbed THEN
                FillRect (hdc, rgn.r)
              END;
              PaintString (hdc, st, op);
              UnsetClipRegion (hdc);
            END;
          END;
        END;
      END;
    END;

    (* Free up things *)
    IF brush # NIL THEN
      oldBrush := WinGDI.SelectObject (hdc, oldBrush);
      &lt;* ASSERT oldBrush = brush *&gt;
      status := WinGDI.DeleteObject (brush);
      &lt;* ASSERT status = True *&gt;
    END;

    oldFont := WinGDI.SelectObject (hdc, oldFont);
    &lt;* ASSERT oldFont # NIL *&gt;

    RETURN pAdr;
  END TextCom;

CONST
  ValidRect = Rect.T{west := -32768, east := 32768, north := -32768,
                     south := 32768};

PROCEDURE <A NAME="PaintString"><procedure>PaintString</procedure></A> (hdc: WinDef.HDC;
                       st : WinScreenType.T;
                       op : PaintPrivate.TextPtr) =

  PROCEDURE FontIdToScrnFont (st: WinScreenType.T; id: INTEGER): ScrnFont.T =
    BEGIN
      FOR i := FIRST(st.fonts^) TO LAST(st.fonts^) DO
        IF st.fonts[i].id = id THEN
          RETURN st.fonts[i];
        END;
      END;
      &lt;* ASSERT FALSE *&gt;
    END FontIdToScrnFont;

  VAR
    i     := 0;
    newi  : INTEGER;
    dlp   : UNTRACED REF VBT.Displacement :=
                                     op + ADRSIZE(PaintPrivate.TextRec);
    endp  : UNTRACED REF VBT.Displacement :=
                                     dlp + ADRSIZE(VBT.Displacement) * op.dlsz;
    txtp  := LOOPHOLE (endp, Ctypes.char_star);
    blank := M3toC.TtoS(&quot; &quot;);
    delta : Ctypes.int;
    status: Ctypes.int;
  BEGIN
    WITH sz = op.txtsz,
         ascent = FontIdToScrnFont (st, op.fnt).metrics.ascent,
         pt = Point.T {op.refpt.h, op.refpt.v - ascent} DO

      (* If the string is empty, or the text is of-screen, exit *)
      IF sz = 0 OR NOT Rect.Member (pt, ValidRect) THEN
        RETURN;
      END;

      (* Set the current position, and tell windows to move the current
         position upon each call to &quot;TextOut&quot; and &quot;ExtTextOut&quot;. *)
      status := WinGDI.SetTextAlign (hdc, WinGDI.TA_UPDATECP);
      &lt;* ASSERT status # WinGDI.GDI_ERROR *&gt;
      status := WinGDI.MoveToEx (hdc, pt.h, pt.v, NIL);
      &lt;* ASSERT status = True *&gt;

      WHILE i &lt; sz DO

        delta := 0;
        WHILE dlp # endp AND dlp.index = i DO
          INC (delta, dlp.dh);
          dlp := dlp + ADRSIZE (VBT.Displacement);
        END;

        (* Emit a blank character of width &quot;delta&quot; *)
        IF delta &gt; 0 THEN
          status := WinGDI.ExtTextOut(hdc, 0, 0, 0, NIL, blank, 1, ADR(delta));
          &lt;* ASSERT status = True *&gt;
        END;

        IF dlp = endp OR dlp.index &gt;= sz THEN
          newi := sz;
        ELSE
          newi := dlp.index
        END;

        (* Draw characters &quot;i&quot; to &quot;newi&quot; - 1 *)
        status := WinGDI.TextOut (hdc, 0, 0, txtp + i, newi - i);
        &lt;* ASSERT status = True *&gt;
        i := newi;
      END;
    END;
  END PaintString;
</PRE>***************************************************************************
 Extensions: Stroking and filling polygons; drawing simple lines.          
                                                                           
 The xvbt version also handles pictures                                    
***************************************************************************

<P>
<P><PRE>PROCEDURE <A NAME="ExtensionCom"><procedure>ExtensionCom</procedure></A> (cmdP, endP: PaintPrivate.CommandPtr;
                        hdc       : WinDef.HDC;
                        trsl      : Trestle.T;
                        st        : WinScreenType.T): PaintPrivate.CommandPtr =
  &lt;* FATAL Path.Malformed *&gt;
  VAR
    op := LOOPHOLE (cmdP, PaintPrivate.ExtensionPtr);
  BEGIN
    INC (cmdP, op.szOfRec * ADRSIZE(Word.T));
    CASE op.subCommand OF
    | PaintExt.FillCommand, PaintExt.StrokeCommand, PaintExt.LineCommand =&gt;
      VAR
        fillP   := LOOPHOLE (op, PaintExt.FillPtr);
        strokeP := LOOPHOLE (op, PaintExt.StrokePtr);
        lineP   := LOOPHOLE (op, PaintExt.LinePtr);
        pathP   : PaintExt.PathPtr;
        path    : Path.T;
        pr      : PolyRegion.T;
        ctxt    : WinContext.T;
      BEGIN
        IF op.subCommand = PaintExt.LineCommand THEN
          ctxt := WinContext.PushStroke (
                      hdc, st, op.op, op.pm,
                      Point.Add(op.delta, lineP.delta),
                      lineP.width, lineP.end, VBT.JoinStyle.Round);
          IF op.delta # Point.Origin THEN
            lineP.p := Point.Add(lineP.p, op.delta);
            lineP.q := Point.Add(lineP.q, op.delta)
          END
        ELSE
          IF op.subCommand = PaintExt.FillCommand THEN
            pathP := ADR(fillP.path);
            ctxt := WinContext.PushFill (
                        hdc, st, op.op, op.pm,
                        Point.Add(op.delta, fillP.delta),
                        fillP.wind);
          ELSIF op.subCommand = PaintExt.StrokeCommand THEN
            pathP := ADR(strokeP.path);
            ctxt := WinContext.PushStroke (
                        hdc, st, op.op, op.pm,
                        Point.Add(op.delta, strokeP.delta),
                        strokeP.width, strokeP.end, strokeP.join);
          END;
          path := NEW(Path.T);
          path.curveCount := pathP.curveCount;
          path.start := pathP + ADRSIZE(pathP^);
          path.next := cmdP;
          path.end := cmdP;
          path.current := cmdP;
          IF op.delta # Point.Origin THEN
            path := Path.Translate(path, op.delta);
          END;
          IF path.curveCount # 0 THEN
            path := Path.Flatten(path);
          END;
        END;
        pr := PolyRegion.Empty;
        PolyRegion.JoinRect(pr, op.clip);
        WHILE cmdP &lt; endP AND cmdP.command = PC.RepeatCom DO
          IF PolyRegion.OverlapRect(pr, cmdP.clip) THEN
            WITH rgn = PolyRegion.ToRegion(pr) DO
              IF NOT Region.IsEmpty(rgn) THEN
                SetClipRegion (hdc, rgn);
                IF op.subCommand = PaintExt.LineCommand THEN
                  DrawLine (hdc, lineP.p, lineP.q);
                ELSIF op.subCommand = PaintExt.FillCommand THEN
                  FillPath(trsl, hdc, path)
                ELSE
                  StrokePath(trsl, hdc, path)
                END;
                UnsetClipRegion (hdc);
              END
            END;
            pr := PolyRegion.Empty
          END;
          PolyRegion.JoinRect(pr, cmdP.clip);
          INC (cmdP, ComSize);
        END;
        WITH rgn = PolyRegion.ToRegion(pr) DO
          IF NOT Region.IsEmpty(rgn) THEN
            SetClipRegion (hdc, rgn);
            IF op.subCommand = PaintExt.LineCommand THEN
              DrawLine (hdc, lineP.p, lineP.q);
            ELSIF op.subCommand = PaintExt.FillCommand THEN
              FillPath(trsl, hdc, path)
            ELSE
              StrokePath(trsl, hdc, path)
            END;
            UnsetClipRegion (hdc);
          END
        END;

        WinContext.Pop (ctxt);
      END;
    | PaintExt.PictureCommand =&gt;
      &lt;* ASSERT FALSE *&gt;  (* pictures are not implemented in WinTrestle *)
    ELSE
      (* skip all &quot;repeat&quot; commands *)
      WHILE cmdP &lt; endP AND cmdP.command = PC.RepeatCom DO
        INC(cmdP, ComSize);
      END;
    END;

    RETURN cmdP;
  END ExtensionCom;
</PRE> This function could move into a module <CODE>WinWrap</CODE> 

<P><PRE>PROCEDURE <A NAME="DrawLine"><procedure>DrawLine</procedure></A> (hdc: WinDef.HDC; a, b: Point.T) =
  VAR
    points := ARRAY [0..1] OF WinDef.POINT {
                                  WinDef.POINT {a.h, a.v},
                                  WinDef.POINT {b.h, b.v}};
    status: WinDef.BOOL;
  BEGIN
    status := WinGDI.Polyline (hdc, ADR(points[0]), 2);
    &lt;* ASSERT status = True *&gt;
  END DrawLine;

TYPE
  StrokeMap = Path.MapObject OBJECT
    trsl: Trestle.T;
    hdc : WinDef.HDC;
    a   : Points;
    n   : CARDINAL := 0;
  OVERRIDES
    line  := StrokeLine;
    move  := StrokeMove;
    close := StrokeLine
  END;
  Points = UNTRACED REF ARRAY OF WinDef.POINT;

PROCEDURE <A NAME="StrokePath"><procedure>StrokePath</procedure></A> (trsl: Trestle.T; hdc: WinDef.HDC; path: Path.T) =
  VAR
    sm := NEW(StrokeMap, trsl := trsl, hdc := hdc, a := NEW (Points, 50));
    &lt;*FATAL Path.Malformed*&gt;
  BEGIN
    Path.Map (path, sm);
    IF sm.n # 0 THEN
      EmitStroke (sm)
    END;
    DISPOSE (sm.a);
  END StrokePath;

PROCEDURE <A NAME="StrokeMove"><procedure>StrokeMove</procedure></A> (self: StrokeMap; READONLY p: Point.T) =
  BEGIN
    IF self.n # 0 THEN
      EmitStroke (self)
    END;
    self.a[0].x := p.h;
    self.a[0].y := p.v;
    self.n := 1
  END StrokeMove;

PROCEDURE <A NAME="StrokeLine"><procedure>StrokeLine</procedure></A> (                    self: StrokeMap;
                      &lt;*UNUSED*&gt; READONLY p   : Point.T;
                                 READONLY q   : Point.T    ) =
  VAR
    m := NUMBER(self.a^);
  BEGIN
    IF self.n = m THEN
      VAR
        newa := NEW(Points, 2 * m);
      BEGIN
        SUBARRAY (newa^, 0, m) := self.a^;
        DISPOSE (self.a);
        self.a := newa;
      END;
    END;
    self.a[self.n].x := q.h;
    self.a[self.n].y := q.v;
    INC (self.n)
  END StrokeLine;

PROCEDURE <A NAME="EmitStroke"><procedure>EmitStroke</procedure></A> (sm: StrokeMap) =
  VAR
    status: WinDef.BOOL;
  BEGIN
    IF sm.n = 1 THEN
      sm.a[1] := sm.a[0];
      sm.n := 2
    END;
    status := WinGDI.Polyline (sm.hdc, ADR(sm.a[0]), sm.n);
    &lt;* ASSERT status = True *&gt;
    sm.n := 0;
  END EmitStroke;

TYPE
  FillMap = Path.MapObject OBJECT
    trsl         : Trestle.T;
    a            : Points;
    n            : CARDINAL := 0;
    origin, start: Point.T;
  OVERRIDES
    line  := FillLine;
    move  := FillMove;
    close := FillLine
  END;

PROCEDURE <A NAME="FillPath"><procedure>FillPath</procedure></A> (trsl: Trestle.T; hdc: WinDef.HDC; path: Path.T) =
  &lt;*FATAL Path.Malformed*&gt;
  VAR
    sm := NEW(FillMap, trsl := trsl, a := NEW(Points, 50));
    status: WinDef.BOOL;
  BEGIN
    TRY
      Path.Map (path, sm);
      IF sm.n # 0 THEN
        FillMove (sm, sm.start);
        (* We leave the &quot;polygon fill mode&quot; at its default value of &quot;WINDING&quot;.
           This means that complex polygons can contain &quot;islands&quot;. *)
        status := WinGDI.Polygon (hdc, ADR(sm.a[0]), sm.n);
        &lt;* ASSERT status = True *&gt;
      END;
    FINALLY
      DISPOSE (sm.a);
    END;
  END FillPath;

PROCEDURE <A NAME="FillMove"><procedure>FillMove</procedure></A> (self: FillMap; READONLY p: Point.T) =
  BEGIN
    IF self.n = 0 THEN
      self.origin := p
    ELSE
      FillLine (self, Point.Origin, self.start);
      FillLine (self, self.start, self.origin)
    END;
    FillLine (self, self.origin, p);
    self.start := p
  END FillMove;

PROCEDURE <A NAME="FillLine"><procedure>FillLine</procedure></A> (                    self: FillMap;
                    &lt;*UNUSED*&gt; READONLY p   : Point.T;
                               READONLY q   : Point.T  ) =
  VAR
    m := NUMBER(self.a^);
  BEGIN
    IF self.n = m THEN
      VAR
        newa := NEW (Points, 2 * m);
      BEGIN
        SUBARRAY (newa^, 0, m) := self.a^;
        DISPOSE (self.a);
        self.a := newa
      END
    END;
    self.a[self.n].x := q.h;
    self.a[self.n].y := q.v;
    INC(self.n)
  END FillLine;
</PRE>***************************************************************************
 Auxiliary procedures                                                      
***************************************************************************

<P>
<P><PRE>PROCEDURE <A NAME="FromRect"><procedure>FromRect</procedure></A> (READONLY r: Rect.T): WinDef.RECT =
  BEGIN
    RETURN WinDef.RECT {left   := r.west,
                        right  := r.east,
                        top    := r.north,
                        bottom := r.south};
  END FromRect;

PROCEDURE <A NAME="EmptyRegion"><procedure>EmptyRegion</procedure></A> (): WinDef.HRGN =
  VAR
    rgn := WinGDI.CreateRectRgn (1,1,1,1);
  BEGIN
    &lt;* ASSERT rgn # NIL *&gt;
    RETURN rgn;
  END EmptyRegion;

PROCEDURE <A NAME="FromRegion"><procedure>FromRegion</procedure></A> (READONLY rgn: Region.T): WinDef.HRGN =
  VAR
    hrgn := EmptyRegion();
    rr   := EmptyRegion();
    status: Ctypes.int;
  BEGIN
    WITH rects = Region.ToRects (rgn) DO
      FOR i := FIRST(rects^) TO LAST (rects^) DO
        WITH r  = rects[i] DO
          status := WinGDI.SetRectRgn (rr, r.west, r.north, r.east, r.south);
          &lt;* ASSERT status = True *&gt;
          status := WinGDI.CombineRgn (hrgn, hrgn, rr, WinGDI.RGN_OR);
          &lt;* ASSERT status # WinGDI.ERROR *&gt;
        END;
      END;
      status := WinGDI.DeleteObject (rr);
      &lt;* ASSERT status = True *&gt;
    END;
    RETURN hrgn;
  END FromRegion;

PROCEDURE <A NAME="SetClipRegion"><procedure>SetClipRegion</procedure></A> (hdc: WinDef.HDC; rgn: Region.T) =
  VAR
    hrgn := FromRegion(rgn);
    status: Ctypes.int;
  BEGIN
    status := WinGDI.SelectClipRgn (hdc, hrgn);
    &lt;* ASSERT status # WinGDI.ERROR *&gt;
    status := WinGDI.DeleteObject (hrgn);
    &lt;* ASSERT status = True *&gt;
  END SetClipRegion;

PROCEDURE <A NAME="UnsetClipRegion"><procedure>UnsetClipRegion</procedure></A> (hdc: WinDef.HDC) =
  VAR
    status: Ctypes.int;
  BEGIN
    status := WinGDI.SelectClipRgn (hdc, NIL);
    &lt;* ASSERT status # WinGDI.ERROR *&gt;
  END UnsetClipRegion;

PROCEDURE <A NAME="IsChicago"><procedure>IsChicago</procedure></A> (): BOOLEAN =
  VAR
    os_version : WinBase.OSVERSIONINFO;
    status : WinDef.BOOL;
  BEGIN
    os_version.dwOSVersionInfoSize := BYTESIZE (os_version);
    status := WinBase.GetVersionEx (ADR (os_version));
    &lt;* ASSERT status = True *&gt;
    RETURN os_version.dwPlatformId = WinBase.VER_PLATFORM_WIN32_WINDOWS;
  END IsChicago;

BEGIN
END WinPaint.
</PRE>
</inModule>
<HR>
<A NAME="x1">interface PathPrivate is in:
</A><UL>
<LI><A HREF="../../../geometry/src/PathPrivate.i3.html#0TOP0">geometry/src/PathPrivate.i3</A>
<LI><A HREF="../../../mg/src/PathPrivate.i3.html#0TOP0">mg/src/PathPrivate.i3</A>
</UL>
<P>
<PRE>























</PRE>
</BODY>
</HTML>
