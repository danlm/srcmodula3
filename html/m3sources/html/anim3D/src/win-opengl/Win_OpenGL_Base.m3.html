<HTML>
<HEAD>
<TITLE>SRC Modula-3: anim3D/src/win-opengl/Win_OpenGL_Base.m3</TITLE>
</HEAD>
<BODY>
<A NAME="0TOP0">
<H2>anim3D/src/win-opengl/Win_OpenGL_Base.m3</H2></A><HR>
<inModule>
<PRE><A HREF="../../../COPYRIGHT.html">Copyright (C) 1994, Digital Equipment Corp.</A>
</PRE><BLOCKQUOTE><EM> Digital Internal Use Only                                                 </EM></BLOCKQUOTE><PRE>
</PRE>                                                                           
       Created on Tue Jul 11 22:37:39 PDT 1995 by najork                   

<P> Limitations:
<P>
     drawPolygon, drawQuadMesh, drawColoredQuadMesh methods: 
         surface edges have slight artifacts
<P>
     drawMarker method: 
         marker types are ignored; markers are drawn as dots
<P>
     setDistinguishFacetsFlag method:
         not implemented
<P>
     pushMatrix, popMatrix methods: 
         I use the native OpenGL matrix stack, which allows only for a fixed 
         number of matrices to be pushed. This number is guaranteed to be at 
         least 32. 
<P>
     setDepthCueing method: 
         The arguments <CODE>frontScale</CODE> and <CODE>backScale</CODE> are ignored, since OpenGL 
         does not have the concept of a fog scaling factor. 
<P>
   Bugs:
<P>
     SRC 129 program 18 (page 35) does not work properly!
<P>


<P>
<P><PRE>UNSAFE MODULE <module>Win_OpenGL_Base</module> EXPORTS <A HREF="../Win_OpenGL_Base.i3.html"><implements>Win_OpenGL_Base</A></implements>, <A HREF="../Win_OpenGL_BaseProxy.i3.html"><implements>Win_OpenGL_BaseProxy</A></implements>;

IMPORT <A HREF="../AuxG.i3.html">AuxG</A>, <A HREF="../AnimServer.i3.html">AnimServer</A>, <A HREF="../../../color/src/Color.i3.html">Color</A>, <A HREF="../ColorPropPrivate.i3.html">ColorPropPrivate</A>, <A HREF="../../../C/src/Common/Ctypes.i3.html">Ctypes</A>, GL, GLu, <A HREF="../GO.i3.html">GO</A>,
       <A HREF="../GOPrivate.i3.html">GOPrivate</A>, <A HREF="../GraphicsBase.i3.html">GraphicsBase</A>, <A HREF="../GraphicsBasePrivate.i3.html">GraphicsBasePrivate</A>, <A HREF="../../../libm3/DS/IntIntTbl.i3.html">IntIntTbl</A>, <A HREF="../../../libm3/DS/IntRefTbl.i3.html">IntRefTbl</A>,
       <A HREF="../KeyCB.i3.html">KeyCB</A>, <A HREF="../../../ui/src/vbt/KeyboardKey.i3.html">KeyboardKey</A>, <A HREF="../../../ui/src/vbt/Latin1Key.i3.html">Latin1Key</A>, <A HREF="../LineTypeProp.i3.html">LineTypeProp</A>, <A HREF="../../../C/src/Common/M3toC.i3.html">M3toC</A>, <A HREF="../MarkerGO.i3.html">MarkerGO</A>,
       <A HREF="../MarkerTypeProp.i3.html">MarkerTypeProp</A>, <A HREF="../MarkerTypePropPrivate.i3.html">MarkerTypePropPrivate</A>, <A HREF="#x1">Math</A>, <A HREF="../Matrix4.i3.html">Matrix4</A>, <A HREF="../MouseCB.i3.html">MouseCB</A>, <A HREF="../Mth.i3.html">Mth</A>,
       <A HREF="../../../parseparams/src/ParseParams.i3.html">ParseParams</A>, <A HREF="../../../geometry/src/Point.i3.html">Point</A>, <A HREF="../Point3.i3.html">Point3</A>, <A HREF="../PositionCB.i3.html">PositionCB</A>, <A HREF="../PropPrivate.i3.html">PropPrivate</A>, <A HREF="../../../runtime/src/common/RTLinker.i3.html">RTLinker</A>,
       <A HREF="../RasterModeProp.i3.html">RasterModeProp</A>, <A HREF="../RealPropPrivate.i3.html">RealPropPrivate</A>, <A HREF="../RootGOPrivate.i3.html">RootGOPrivate</A>, <A HREF="../ShadingProp.i3.html">ShadingProp</A>, <A HREF="../../../rw/src/Common/Stdio.i3.html">Stdio</A>,
       <A HREF="../SurfaceGO.i3.html">SurfaceGO</A>, <A HREF="../../../thread/src/Common/Thread.i3.html">Thread</A>, <A HREF="../../../ui/src/vbt/VBT.i3.html">VBT</A>, <A HREF="../../../win32/src/WinDef.i3.html">WinDef</A>, <A HREF="../../../win32/src/WinGDI.i3.html">WinGDI</A>, <A HREF="../../../win32/src/WinUser.i3.html">WinUser</A>, <A HREF="../../../word/src/Word.i3.html">Word</A>;

IMPORT <A HREF="../../../rw/src/Common/IO.i3.html">IO</A>, <A HREF="../../../fmtlex/src/Fmt.i3.html">Fmt</A>;

REVEAL
  <A NAME="T">T</A> = Public BRANDED OBJECT
    hwnd                : WinDef.HWND;
    hdc                 : WinDef.HDC;   (* a private device context! *)
    hglrc               : WinDef.HGLRC;
    title               : TEXT;
    origin              : Point.T;      (* NW corner of the window *)
    dimen               : Point.T;      (* width and height of drawing area *)
    eventQueue          : EventQueue;
    windowThreadCV      : Thread.Condition;

    drawBuffer          : GL.GLenum;
    winWidth            : INTEGER;
    winHeight           : INTEGER;

    near                : REAL;         (* Used by glOrtho, gluPerspective, *)
    far                 : REAL;         (* and for fog calculation.         *)

    phase               : INTEGER;           (* current drawing phase       *)
    transflag           : BOOLEAN;           (* transparent parts in scene? *)
    modifiers           : VBT.Modifiers;     (* what modifiers are pressed  *)
    buttonDownCount     : INTEGER;           (* how many buttons are down   *)
    awaitDeleteMu       : Thread.Mutex;      (* Mutex used by Thread.Wait   *)
    awaitDeleteCV       : Thread.Condition;  (* CV for awaitDelete method   *)
    stateSize           : INTEGER;
    dlTable             : IntIntTbl.T;

    from                : Point3.T;
    to                  : Point3.T;
    up                  : Point3.T;
    projType            : ProjType;
    aspect              : REAL;
    fovy                : REAL;
    height              : REAL;
  (*** light management ***)
    lighting         : BOOLEAN := TRUE;
    lightCount       : INTEGER;
    lightList        : GL.GLuint;
    ambientLight     : GLrgba;
  (*** markers ***)
    markerColor      : Color.T;                    (* Initialized by &quot;Init&quot; *)
    markerScale      : REAL;                       (* Initialized by &quot;Init&quot; *)
    markerType       : MarkerTypeProp.Kind;        (* Initialized by &quot;Init&quot; *)
  (*** lines ***)
    lineType         : GL.GLint := Solid;
    lineWidth        : REAL     := 1.0;
    lineColor        : Color.T  := Color.White;
  (*** surfaces ***)
    frontColor       : Color.T := Color.White;
    backColor        : Color.T := Color.White;
    transmission     : REAL    := 1.0;

    ambientReflCoeff : REAL    := 0.5;
    diffuseReflCoeff : REAL    := 1.0;
    specularReflCoeff: REAL    := 0.0;
    specularReflColor: Color.T := Color.White;
    specularReflConc : REAL;                       (* Initialized by &quot;Init&quot; *)

    rasterMode                 := RasterModeProp.Kind.Solid;
  (*** surface edges ***)
    edgeFlag         : BOOLEAN  := FALSE;
    edgeType         : GL.GLint := Solid;
    edgeWidth        : REAL     := 1.0;
    edgeColor        : Color.T  := Color.White;
  (*** caching of OpenGL display lists for prototypical objects ***)
    sphereStructures   : StructureList := NIL;
    coneStructures     : StructureList := NIL;
    cylinderStructures : StructureList := NIL;
    diskStructures     : StructureList := NIL;
  OVERRIDES
  (*** Methods that may be called by any thread ***)
    init               := Init;
    changeTitle        := ChangeTitle; (* should be called only by server *)
    awaitDelete        := AwaitDelete;
    destroy            := Destroy;
  (*** Methods that may be called only by animation server thread ***)
    processEvents      := ProcessEvents;
    repair             := Repair;
    unmap              := Unmap;

    push             := Push;
    pop              := Pop;

    addAmbientLight  := AddAmbientLight;
    addVectorLight   := AddVectorLight;
    addPointLight    := AddPointLight;
    addSpotLight     := AddSpotLight;

    openDisplayList  := OpenDisplayList;
    closeDisplayList := CloseDisplayList;
    callDisplayList  := CallDisplayList;
    freeDisplayList  := FreeDisplayList;

    pushMatrix       := PushMatrix;
    popMatrix        := PopMatrix;

    setLookAt                := SetLookAt;
    setOrthoProj             := SetOrthoProj;
    setPerspProj             := SetPerspProj;
    setupCamera              := SetupCamera;
    screenToWorld            := ScreenToWorld;

    setBackgroundColor       := SetBackgroundColor;
    setDepthcueing           := SetDepthcueing;
    setMarkerColor           := SetMarkerColor;
    setMarkerScale           := SetMarkerScale;
    setMarkerType            := SetMarkerType;
    setLineColor             := SetLineColor;
    setLineWidth             := SetLineWidth;
    setLineType              := SetLineType;
    setSurfaceColor          := SetSurfaceColor;
    setSurfaceBackColor      := SetSurfaceBackColor;
    setRasterMode            := SetRasterMode;
    setDistinguishFacetsFlag := SetDistinguishFacetsFlag;
    setLighting              := SetLighting;
    setShading               := SetShading;
    setSurfaceEdgeFlag       := SetSurfaceEdgeFlag;
    setSurfaceEdgeColor      := SetSurfaceEdgeColor;
    setSurfaceEdgeType       := SetSurfaceEdgeType;
    setSurfaceEdgeWidth      := SetSurfaceEdgeWidth;
    setAmbientReflCoeff      := SetAmbientReflCoeff;
    setDiffuseReflCoeff      := SetDiffuseReflCoeff;
    setSpecularReflCoeff     := SetSpecularReflCoeff;
    setSpecularReflConc      := SetSpecularReflConc;
    setSpecularReflColor     := SetSpecularReflColor;
    setTransmissionCoeff     := SetTransmissionCoeff;
    drawMarker               := DrawMarker;
    drawLine                 := DrawLine;
    drawPolygon              := DrawPolygon;
    drawQuadMesh             := DrawQuadMesh;
    drawColoredQuadMesh      := DrawColoredQuadMesh;
    drawProtoSphere          := DrawProtoSphere;
    drawProtoCone            := DrawProtoCone;
    drawProtoCylinder        := DrawProtoCylinder;
    drawProtoDisk            := DrawProtoDisk;
    drawProtoTorus           := DrawProtoTorus;
  END;

TYPE
  ProjType = {Persp, Ortho};

  GLrgba = RECORD
    r, g, b, a: REAL;
  END;

  GLpoint3d = ARRAY [1 .. 3] OF GL.GLdouble;
</PRE><BLOCKQUOTE><EM><P>
  GLpoint3d = RECORD
    x, y, z: LONGREAL;
  END;
</EM></BLOCKQUOTE><PRE>

  GLpoint4f = RECORD
    x, y, z, w: REAL;
  END;

  GLmatrixf = ARRAY [0 .. 15] OF GL.GLfloat;

CONST
  False = 0;  &lt;*NOWARN*&gt;
  True  = 1;

CONST
  Solid   = 2_1111111111111111;
  Dashed  = 2_1111000011110000;
  Dotted  = 2_1010101010101010;
  DashDot = 2_1110010011100100;

PROCEDURE <A NAME="Init"><procedure>Init</procedure></A> (self: T; title: TEXT; x, y, w, h: INTEGER): T
    RAISES {GraphicsBase.Failure} =
  VAR
  BEGIN
    (*** Initialize windowThreadCV ***)
    self.windowThreadCV := NEW (Thread.Condition);

    (*** Initialize awaitDeleteCV ***)
    self.awaitDeleteMu := NEW (Thread.Mutex);
    self.awaitDeleteCV := NEW (Thread.Condition);

    (*** Initialize the display list table ***)
    self.dlTable := NEW (IntIntTbl.Default).init ();

    self.stacks := PropPrivate.NewStacks ();
    self.stateSize := NUMBER (self.stacks^);

    (* The rest of this function is copied straight from X_PEX_Base. *)

    self.modifiers := VBT.Modifiers {};
    self.buttonDownCount := 0;

    self.status := GraphicsBasePrivate.Status.Mapped;

    self.winWidth  := w;
    self.winHeight := h;

    (* Initialize the state variables *)
    self.setSpecularReflConc (
        SurfaceGO.SpecularReflectionConc.getState (self));

    self.setMarkerColor (MarkerGO.Colour.getState (self));
    self.setMarkerScale (MarkerGO.Scale.getState (self));
    self.setMarkerType  (MarkerGO.Type.getState (self));

    (* save title, position, and dimensions of the window to be created *)
    self.title := title;
    self.origin := Point.T {x, y};
    self.dimen  := Point.T {w, h};

    (* Set hwnd, hdc, hglrc to NIL *)
    self.hwnd := NIL;
    self.hdc := NIL;
    self.hglrc := NIL;

    (* Create an event queue for buffering Windows messages *)
    self.eventQueue := NEW (EventQueue).init ();

    IF MkProxyT # NIL THEN
      MkProxyT (self);
    END;

    RETURN self;
  END Init;
</PRE>***************************************************************************
 The following procedures are copied pretty much directly from X_PEX_Base  
***************************************************************************

<P>
<P><PRE>PROCEDURE <A NAME="ChangeTitle"><procedure>ChangeTitle</procedure></A> (self: T; title : TEXT) =
  VAR
    status : WinDef.BOOL;
  BEGIN
    LOCK conn DO
      status := WinUser.SetWindowText (self.hwnd, M3toC.TtoS (title));
      &lt;* ASSERT status = True *&gt;
    END;
  END ChangeTitle;

PROCEDURE <A NAME="AwaitDelete"><procedure>AwaitDelete</procedure></A> (self : T) =
  BEGIN
    LOCK self.awaitDeleteMu DO
      Thread.Wait (self.awaitDeleteMu, self.awaitDeleteCV);
    END;
  END AwaitDelete;

PROCEDURE <A NAME="Destroy"><procedure>Destroy</procedure></A> (self : T) =
  BEGIN
    LOCK AnimServer.internalLock DO
      self.status := GraphicsBasePrivate.Status.Destroyed;
    END;
  END Destroy;

PROCEDURE <A NAME="Unmap"><procedure>Unmap</procedure></A> (self : T) =
  VAR
    status : WinDef.BOOL;
  BEGIN
    &lt;* ASSERT AnimServer.IsServer() *&gt;

    (* Delete the OpenGL rendering context.  Since the device context is
       &quot;private&quot;, there is no need to release or delete it. *)
    status := WinGDI.wglDeleteContext (self.hglrc);
    &lt;* ASSERT status = True *&gt;

    (* Windows can be destroyed only by the thread that created them.
       So, ask the &quot;window thread&quot; to destroy &quot;self.hwnd&quot;. *)
    EVAL WinUser.SendMessage(self.hwnd, WM_INITIATE_DESTROY, 0, 0);

    self.status := GraphicsBasePrivate.Status.Unmapped;

    (*** signal all threads that are blocked ***)
    Thread.Broadcast (self.awaitDeleteCV);
  END Unmap;

PROCEDURE <A NAME="Available"><procedure>Available</procedure></A> () : BOOLEAN =
  BEGIN
    (* This procedure is supposed to determine whether OpenGL is available.
       This is straightforward under X (use &quot;glXQueryExtension&quot;), but it's not
       clear how it should be done under Windows.  The Microsoft documentation
       suggests to use &quot;GetVersion&quot;, but does not say which versions of Windows
       support OpenGL.  I assume that OpenGL is supported if OPENGL32.DLL is
       around. If OPENGL32.DLL is not around, the application will fail upon
       startup. So, I simply cross my fingers and return TRUE. *)

    RETURN TRUE;
  END Available;
</PRE>***************************************************************************
 End of replicated code                                                    
***************************************************************************

<P>
<P><PRE>PROCEDURE <A NAME="Push"><procedure>Push</procedure></A> (self : T; caller : GO.T) =
  VAR
    props := caller.props;
  BEGIN
    &lt;* ASSERT AnimServer.IsServer() *&gt;

    WHILE props # NIL DO
      WITH prop = props.head DO
        prop.n.push (self, prop.v);
      END;
      props := props.tail;
    END;
  END Push;

PROCEDURE <A NAME="Pop"><procedure>Pop</procedure></A> (self : T; caller : GO.T) =
  VAR
    props := caller.props;
  BEGIN
    &lt;* ASSERT AnimServer.IsServer() *&gt;

    WHILE props # NIL DO
      props.head.n.pop (self);
      props := props.tail;
    END;
  END Pop;
</PRE>***************************************************************************
 Phase 1 methods: Camera and light source management                       
***************************************************************************

<P>
<P><PRE>PROCEDURE <A NAME="AddAmbientLight"><procedure>AddAmbientLight</procedure></A> (self: T; color: Color.T) =
  BEGIN
    IF self.phase = 1 THEN
      self.ambientLight := GLrgba {self.ambientLight.r + color.r,
                                   self.ambientLight.g + color.g,
                                   self.ambientLight.b + color.b,
                                   self.ambientLight.a};
    END;
  END AddAmbientLight;

PROCEDURE <A NAME="AddVectorLight"><procedure>AddVectorLight</procedure></A> (self: T; color: Color.T; d: Point3.T) =
  VAR
    pos := GLpoint4f {-d.x, -d.y, -d.z, 0.0};
    black := GLrgba {0.0, 0.0, 0.0, 1.0};
    col := GLrgba {color.r, color.g, color.b, 1.0};
  BEGIN
    IF self.phase = 1 THEN
      WITH l = GL.GL_LIGHT0 + self.lightCount DO
        &lt;* ASSERT l &lt; GL.GL_LIGHT0 + GL.GL_MAX_LIGHTS *&gt;
        GL.glLightfv (l, GL.GL_AMBIENT, ADR (black));
        GL.glLightfv (l, GL.GL_DIFFUSE, ADR (col));
        GL.glLightfv (l, GL.GL_SPECULAR, ADR (col));
        GL.glLightfv (l, GL.GL_POSITION, ADR (pos));

        (* Since this is a directional light source, attenuation is disabled,
           so we don't need to specify &quot;GL_CONSTANT_ATTENUATION&quot;,
           &quot;GL_LINEAR_ATTENUATION&quot;, and &quot;GL_QUADRATIC_ATTENUATION&quot;.  On the
           other hand, we have to specify &quot;GL_SPOT_CUTOFF&quot; and
           &quot;GL_SPOT_EXPONENT&quot;, since OpenGL allows for directional spotlights
           (with their effect being undefined). We initialize them for uniform
           light distribution. Since &quot;GL_SPOT_CUTOFF&quot; is 180 degrees, we don't
           need to specify &quot;GL_SPOT_DIRECTION&quot;. *)
        GL.glLightf (l, GL.GL_SPOT_EXPONENT, 0.0);
        GL.glLightf (l, GL.GL_SPOT_CUTOFF, 180.0);

        GL.glEnable (l);
        INC (self.lightCount);
      END;
    END;
  END AddVectorLight;

PROCEDURE <A NAME="AddPointLight"><procedure>AddPointLight</procedure></A> (self      : T;
                         color     : Color.T;
                         p         : Point3.T;
                         att0, att1: REAL) =
  VAR
    pos := GLpoint4f {p.x, p.y, p.z, 1.0};
    black := GLrgba {0.0, 0.0, 0.0, 1.0};
    col := GLrgba {color.r, color.g, color.b, 1.0};
  BEGIN
    IF self.phase = 1 THEN
      WITH l = GL.GL_LIGHT0 + self.lightCount DO
        &lt;* ASSERT l &lt; GL.GL_LIGHT0 + GL.GL_MAX_LIGHTS *&gt;

        GL.glLightfv (l, GL.GL_AMBIENT, ADR (black));
        GL.glLightfv (l, GL.GL_DIFFUSE, ADR (col));
        GL.glLightfv (l, GL.GL_SPECULAR, ADR (col));
        GL.glLightfv (l, GL.GL_POSITION, ADR (pos));

        GL.glLightf (l, GL.GL_SPOT_EXPONENT, 0.0);
        GL.glLightf (l, GL.GL_SPOT_CUTOFF, 180.0);

        GL.glLightf (l, GL.GL_CONSTANT_ATTENUATION,  att0);
        GL.glLightf (l, GL.GL_LINEAR_ATTENUATION,    att1);
        GL.glLightf (l, GL.GL_QUADRATIC_ATTENUATION, 0.0);

        GL.glEnable (l);
        INC (self.lightCount);
      END;
    END;
  END AddPointLight;

PROCEDURE <A NAME="AddSpotLight"><procedure>AddSpotLight</procedure></A> (self: T; color: Color.T; p, d: Point3.T;
                        conc, spread, att0, att1: REAL) =
  VAR
    pos := GLpoint4f {p.x, p.y, p.z, 1.0};
    black := GLrgba {0.0, 0.0, 0.0, 1.0};
    col := GLrgba {color.r, color.g, color.b, 1.0};
  BEGIN
    IF self.phase = 1 THEN
      WITH l = GL.GL_LIGHT0 + self.lightCount DO
        &lt;* ASSERT l &lt; GL.GL_LIGHT0 + GL.GL_MAX_LIGHTS *&gt;

        GL.glLightfv (l, GL.GL_AMBIENT, ADR (black));
        GL.glLightfv (l, GL.GL_DIFFUSE, ADR (col));
        GL.glLightfv (l, GL.GL_SPECULAR, ADR (col));
        GL.glLightfv (l, GL.GL_POSITION, ADR (pos));

        GL.glLightfv (l, GL.GL_SPOT_DIRECTION, ADR (d));
        GL.glLightf (l, GL.GL_SPOT_EXPONENT, conc);
        GL.glLightf (l, GL.GL_SPOT_CUTOFF, 180.0 * spread / Math.Pi);

        GL.glLightf (l, GL.GL_CONSTANT_ATTENUATION,  att0);
        GL.glLightf (l, GL.GL_LINEAR_ATTENUATION,    att1);
        GL.glLightf (l, GL.GL_QUADRATIC_ATTENUATION, 0.0);

        GL.glEnable (l);
        INC (self.lightCount);
      END;
    END;
  END AddSpotLight;

PROCEDURE <A NAME="SetLookAt"><procedure>SetLookAt</procedure></A> (self: T; from, to, up: Point3.T) =
  BEGIN
    IF self.phase = 1 THEN
      self.from := from;
      self.to   := to;
      self.up   := up;
    END;
  END SetLookAt;

PROCEDURE <A NAME="SetPerspProj"><procedure>SetPerspProj</procedure></A> (self: T; fovy, aspect: REAL) =
  BEGIN
    IF self.phase = 1 THEN
      self.projType := ProjType.Persp;
      self.fovy     := fovy;
      self.aspect   := aspect;
    END;
  END SetPerspProj;

PROCEDURE <A NAME="SetOrthoProj"><procedure>SetOrthoProj</procedure></A> (self: T; height, aspect: REAL) =
  BEGIN
    IF self.phase = 1 THEN
      self.projType := ProjType.Ortho;
      self.height   := height;
      self.aspect   := aspect;
    END;
  END SetOrthoProj;
</PRE>***************************************************************************
 Display-List management                                                   
***************************************************************************

<P>
<P><PRE>PROCEDURE <A NAME="OpenDisplayList"><procedure>OpenDisplayList</procedure></A> (self : T; go : GO.T) =
  VAR
    dl : INTEGER;
  BEGIN
    &lt;* ASSERT AnimServer.IsServer() *&gt;

    IF self.phase = 2 THEN
      (*** Extract the display list associated with the GO. ***)
      IF go.dl = 0 THEN
        go.dl := AnimServer.NewDisplayList (go);
      END;
      IF NOT self.dlTable.get (go.dl, dl) THEN
        dl := GL.glGenLists (1);
        &lt;* ASSERT dl # 0 *&gt;
        EVAL self.dlTable.put (go.dl, dl);
      END;

      (*** Open the OpenGL display list ***)
      GL.glNewList (dl, GL.GL_COMPILE);
    END;
  END OpenDisplayList;

PROCEDURE <A NAME="CloseDisplayList"><procedure>CloseDisplayList</procedure></A> (self : T) =
  BEGIN
    IF self.phase = 2 THEN
      GL.glEndList ();
    END;
  END CloseDisplayList;

PROCEDURE <A NAME="CallDisplayList"><procedure>CallDisplayList</procedure></A> (self : T; go : GO.T) =
  VAR
    dl: INTEGER;
  BEGIN
    &lt;* ASSERT AnimServer.IsServer() *&gt;

    IF self.phase = 2 THEN
      (*** Extract the display list associated with the GO. ***)
      IF NOT self.dlTable.get (go.dl, dl) THEN
        &lt;* ASSERT FALSE *&gt;
      END;

      GL.glCallList (dl);
    END;
  END CallDisplayList;

PROCEDURE <A NAME="FreeDisplayList"><procedure>FreeDisplayList</procedure></A> (self: T; go: GO.T) =
  VAR
    dl : INTEGER;
  BEGIN
    IF self.dlTable.delete (go.dl, dl) THEN
      GL.glDeleteLists (dl, 1);
    END;
  END FreeDisplayList;
</PRE>***************************************************************************
 Matrix Stack management                                                   
***************************************************************************

<P>
<P><PRE>PROCEDURE <A NAME="PushMatrix"><procedure>PushMatrix</procedure></A> (&lt;*UNUSED*&gt; self : T; READONLY matrix : Matrix4.T) =
  VAR
    V := FromMatrix4 (matrix);
  BEGIN
    GL.glPushMatrix ();
    GL.glMultMatrixf (ADR (V[0]));
  END PushMatrix;

PROCEDURE <A NAME="PopMatrix"><procedure>PopMatrix</procedure></A> (&lt;*UNUSED*&gt; self : T) =
  BEGIN
    GL.glPopMatrix ();
  END PopMatrix;
</PRE>***************************************************************************
 Changing the state of the abstract graphics machine                       
***************************************************************************

<P>
<P><PRE>PROCEDURE <A NAME="FromMatrix4"><procedure>FromMatrix4</procedure></A> (READONLY M: Matrix4.T): GLmatrixf =
  BEGIN
    RETURN GLmatrixf {M[0][0], M[1][0], M[2][0], M[3][0],
                      M[0][1], M[1][1], M[2][1], M[3][1],
                      M[0][2], M[1][2], M[2][2], M[3][2],
                      M[0][3], M[1][3], M[2][3], M[3][3]};
  END FromMatrix4;

PROCEDURE <A NAME="ToMatrix4"><procedure>ToMatrix4</procedure></A> (READONLY M: GLmatrixf): Matrix4.T =
  BEGIN
    RETURN Matrix4.T {Matrix4.Row {M[0], M[4], M[ 8], M[12]},
                      Matrix4.Row {M[1], M[5], M[ 9], M[13]},
                      Matrix4.Row {M[2], M[6], M[10], M[14]},
                      Matrix4.Row {M[3], M[7], M[11], M[15]}};
  END ToMatrix4;

PROCEDURE <A NAME="SetupCamera"><procedure>SetupCamera</procedure></A> (self: T) =
  CONST
    epsilon = 0.1;
    min_far = 0.01;
  VAR
    V   : GLmatrixf;
  BEGIN
    GL.glMatrixMode (GL.GL_MODELVIEW);
    GL.glLoadIdentity ();
    GLu.gluLookAt (FLOAT (self.from.x, LONGREAL),
                   FLOAT (self.from.y, LONGREAL),
                   FLOAT (self.from.z, LONGREAL),
                   FLOAT (self.to.x,   LONGREAL),
                   FLOAT (self.to.y,   LONGREAL),
                   FLOAT (self.to.z,   LONGREAL),
                   FLOAT (self.up.x,   LONGREAL),
                   FLOAT (self.up.y,   LONGREAL),
                   FLOAT (self.up.z,   LONGREAL));

    GL.glGetFloatv (GL.GL_MODELVIEW_MATRIX, ADR (V[0]));

    WITH bs = self.getBoundingVolume(),
         M = ToMatrix4 (V),
         center = Point3.T {
                      M[0][0] * bs.center.x + M[0][1] * bs.center.y +
                      M[0][2] * bs.center.z + M[0][3],
                      M[1][0] * bs.center.x + M[1][1] * bs.center.y +
                      M[1][2] * bs.center.z + M[1][3],
                      M[2][0] * bs.center.x + M[2][1] * bs.center.y +
                      M[2][2] * bs.center.z + M[2][3]},
         radius = bs.radius * Mth.sqrt (M[0][0] * M[0][0] +
                                        M[1][0] * M[1][0] +
                                        M[2][0] * M[2][0]) DO
      self.far  := MAX (ABS (center.z) - radius - epsilon, min_far);
      self.near := MAX (ABS (center.z) + radius + epsilon, min_far);
    END;

    GL.glMatrixMode (GL.GL_PROJECTION);
    GL.glLoadIdentity ();

    WITH aspect = self.aspect * FLOAT(self.winWidth) / FLOAT(self.winHeight) DO
      CASE self.projType OF
      | ProjType.Persp =&gt;
        GLu.gluPerspective (FLOAT (self.fovy / Math.Pi * 180.0, LONGREAL),
                            FLOAT (aspect, LONGREAL),
                            FLOAT (self.near, LONGREAL),
                            FLOAT (self.far, LONGREAL));
      | ProjType.Ortho =&gt;
        GL.glOrtho (FLOAT (-self.height * aspect * 0.5, LONGREAL),
                    FLOAT ( self.height * aspect * 0.5, LONGREAL),
                    FLOAT (-self.height          * 0.5, LONGREAL),
                    FLOAT ( self.height          * 0.5, LONGREAL),
                    FLOAT (self.near, LONGREAL),
                    FLOAT (self.far, LONGREAL));
      END;
    END;

    (*** Switch back to model/view matrix ***)
    GL.glMatrixMode (GL.GL_MODELVIEW);
  END SetupCamera;

PROCEDURE <A NAME="ScreenToWorld"><procedure>ScreenToWorld</procedure></A> (self: T; pos: Point.T; zpos: REAL): Point3.T =
  VAR
    modelMatrix: ARRAY [0 .. 15] OF GL.GLdouble;
    projMatrix : ARRAY [0 .. 15] OF GL.GLdouble;
    viewPort   : ARRAY [0 .. 3]  OF GL.GLint;
    rx, ry, rz : GL.GLdouble;
    status     : GL.GLint;
  BEGIN
    (*** Retrieve the modelview and the projection matrix ***)
    GL.glGetDoublev (GL.GL_MODELVIEW_MATRIX, ADR (modelMatrix[0]));
    GL.glGetDoublev (GL.GL_PROJECTION_MATRIX, ADR (projMatrix[0]));
    GL.glGetIntegerv(GL.GL_VIEWPORT, ADR (viewPort[0]));

    (*** Call &quot;UnProject&quot; ***)
    WITH x = FLOAT (pos.h, LONGREAL),
         y = FLOAT (self.winHeight - 1 - pos.v, LONGREAL),
         z = FLOAT (zpos, LONGREAL) DO
      status := GLu.gluUnProject (x, y, z,
                                  ADR (modelMatrix[0]),
                                  ADR (projMatrix[0]),
                                  ADR (viewPort[0]),
                                  ADR (rx), ADR (ry), ADR (rz));
    END;

    &lt;* ASSERT status = GL.GL_TRUE *&gt;

    (*** Return the result ***)
    RETURN Point3.T {FLOAT (rx), FLOAT (ry), FLOAT (rz)};
  END ScreenToWorld;

PROCEDURE <A NAME="SetBackgroundColor"><procedure>SetBackgroundColor</procedure></A> (&lt;* UNUSED *&gt; self : T; color : Color.T) =
  BEGIN
    GL.glClearColor (color.r, color.g, color.b, 1.0);
  END SetBackgroundColor;

PROCEDURE <A NAME="SetDepthcueing"><procedure>SetDepthcueing</procedure></A> (           self       : T;
                                     switch     : BOOLEAN;
                                     frontPlane : REAL;
                                     backPlane  : REAL;
                          &lt;*UNUSED*&gt; frontScale : REAL;
                          &lt;*UNUSED*&gt; backScale  : REAL;
                                     color      : Color.T) =
  VAR
    rgba := GLrgba {color.r, color.g, color.b, 1.0};
  BEGIN
    IF self.phase = 2 THEN
      IF switch THEN
        WITH start = self.far - frontPlane * (self.far - self.near),
             end   = self.far - backPlane  * (self.far - self.near) DO
          GL.glEnable (GL.GL_FOG);
          GL.glFogi (GL.GL_FOG_MODE, GL.GL_LINEAR);
          GL.glFogf (GL.GL_FOG_START, start);
          GL.glFogf (GL.GL_FOG_END, end);
          GL.glFogfv (GL.GL_FOG_COLOR, ADR (rgba));
          (* OpenGL does not have the concept of fog scaling factors. Hence,
             we have to ignore &quot;frontScale&quot; and &quot;backScale&quot;. Conversely,
             we don't need to specify values for &quot;GL.GL_FOG_INDEX&quot;, as we are
             in RGBA mode, and for &quot;GL.GL_FOG_DENSITY&quot;, since we use the
             linear fog equation. *)
        END;
      ELSE
        GL.glDisable (GL.GL_FOG);
      END;
    END;
  END SetDepthcueing;

PROCEDURE <A NAME="SetMarkerColor"><procedure>SetMarkerColor</procedure></A> (self: T; col: Color.T) =
  BEGIN
    self.markerColor := col;
  END SetMarkerColor;

PROCEDURE <A NAME="SetMarkerScale"><procedure>SetMarkerScale</procedure></A> (self : T; scale : REAL) =
  BEGIN
    self.markerScale := scale;
  END SetMarkerScale;

PROCEDURE <A NAME="SetMarkerType"><procedure>SetMarkerType</procedure></A> (self : T; type : MarkerTypeProp.Kind) =
  BEGIN
    self.markerType := type;
  END SetMarkerType;

PROCEDURE <A NAME="SetLineColor"><procedure>SetLineColor</procedure></A> (self: T; col: Color.T) =
  BEGIN
    self.lineColor := col;
  END SetLineColor;

PROCEDURE <A NAME="SetLineWidth"><procedure>SetLineWidth</procedure></A> (self: T; width: REAL) =
  BEGIN
    self.lineWidth := width;
  END SetLineWidth;

PROCEDURE <A NAME="SetLineType"><procedure>SetLineType</procedure></A> (self : T; type : LineTypeProp.Kind) =
  BEGIN
    CASE type OF
    | LineTypeProp.Kind.Solid   =&gt; self.lineType := Solid;
    | LineTypeProp.Kind.Dashed  =&gt; self.lineType := Dashed;
    | LineTypeProp.Kind.Dotted  =&gt; self.lineType := Dotted;
    | LineTypeProp.Kind.DashDot =&gt; self.lineType := DashDot;
    END;
  END SetLineType;

PROCEDURE <A NAME="SetSurfaceColor"><procedure>SetSurfaceColor</procedure></A> (self : T; col : Color.T) =
  BEGIN
    self.frontColor := col;
  END SetSurfaceColor;

PROCEDURE <A NAME="SetSurfaceBackColor"><procedure>SetSurfaceBackColor</procedure></A> (self : T; col : Color.T) =
  BEGIN
    self.backColor := col;
  END SetSurfaceBackColor;

PROCEDURE <A NAME="SetRasterMode"><procedure>SetRasterMode</procedure></A> (self : T; val : RasterModeProp.Kind) =
  BEGIN
    self.rasterMode := val;
  END SetRasterMode;

PROCEDURE <A NAME="SetDistinguishFacetsFlag"><procedure>SetDistinguishFacetsFlag</procedure></A> (&lt;*UNUSED*&gt; self : T;
                                    &lt;*UNUSED*&gt; val : BOOLEAN) =
  BEGIN
    IO.Put (&quot;### SetDistinguishFacetsFlag not implemented \n&quot;);
  END SetDistinguishFacetsFlag;

PROCEDURE <A NAME="SetLighting"><procedure>SetLighting</procedure></A> (self : T; val : BOOLEAN) =
  BEGIN
    self.lighting := val;
    IF val THEN
      GL.glEnable (GL.GL_LIGHTING);
    ELSE
      GL.glDisable (GL.GL_LIGHTING);
    END;
  END SetLighting;

PROCEDURE <A NAME="SetShading"><procedure>SetShading</procedure></A> (&lt;*UNUSED*&gt; self : T; val : ShadingProp.Kind) =
  BEGIN
    CASE val OF
    | ShadingProp.Kind.Flat    =&gt; GL.glShadeModel (GL.GL_FLAT);
    | ShadingProp.Kind.Gouraud =&gt; GL.glShadeModel (GL.GL_SMOOTH);
    END;
  END SetShading;

PROCEDURE <A NAME="SetSurfaceEdgeFlag"><procedure>SetSurfaceEdgeFlag</procedure></A> (self : T; val : BOOLEAN) =
  BEGIN
    self.edgeFlag := val;
  END SetSurfaceEdgeFlag;

PROCEDURE <A NAME="SetSurfaceEdgeColor"><procedure>SetSurfaceEdgeColor</procedure></A> (self: T; col: Color.T) =
  BEGIN
    self.edgeColor := col;
  END SetSurfaceEdgeColor;

PROCEDURE <A NAME="SetSurfaceEdgeType"><procedure>SetSurfaceEdgeType</procedure></A> (self : T; val : LineTypeProp.Kind) =
  BEGIN
    CASE val OF
    | LineTypeProp.Kind.Solid   =&gt; self.edgeType := Solid;
    | LineTypeProp.Kind.Dashed  =&gt; self.edgeType := Dashed;
    | LineTypeProp.Kind.Dotted  =&gt; self.edgeType := Dotted;
    | LineTypeProp.Kind.DashDot =&gt; self.edgeType := DashDot;
    END;
  END SetSurfaceEdgeType;

PROCEDURE <A NAME="SetSurfaceEdgeWidth"><procedure>SetSurfaceEdgeWidth</procedure></A> (self: T; width: REAL) =
  BEGIN
    self.edgeWidth := width;
  END SetSurfaceEdgeWidth;

PROCEDURE <A NAME="SetAmbientReflCoeff"><procedure>SetAmbientReflCoeff</procedure></A> (self : T; val : REAL) =
  BEGIN
    self.ambientReflCoeff := val;
  END SetAmbientReflCoeff;

PROCEDURE <A NAME="SetDiffuseReflCoeff"><procedure>SetDiffuseReflCoeff</procedure></A> (self : T; val : REAL) =
  BEGIN
    self.diffuseReflCoeff := val;
  END SetDiffuseReflCoeff;

PROCEDURE <A NAME="SetSpecularReflCoeff"><procedure>SetSpecularReflCoeff</procedure></A> (self : T; val : REAL) =
  BEGIN
    self.specularReflCoeff := val;
  END SetSpecularReflCoeff;

PROCEDURE <A NAME="SetSpecularReflConc"><procedure>SetSpecularReflConc</procedure></A> (self : T; val : REAL) =
  BEGIN
    (* I try to make the &quot;GL_SHININESS&quot; value to look as much as possible like
       the &quot;specularConc&quot; component for &quot;PEXSetReflectionAttributes&quot;.
       This formula is taken essentially out of thin air, but seems to produce
       reasonably similar images. *)
    self.specularReflConc := MIN (MAX (val * 2.0 + 4.0, 0.0), 128.0);
  END SetSpecularReflConc;

PROCEDURE <A NAME="SetSpecularReflColor"><procedure>SetSpecularReflColor</procedure></A> (self : T; val : Color.T) =
  BEGIN
    self.specularReflColor := val;
  END SetSpecularReflColor;

PROCEDURE <A NAME="SetTransmissionCoeff"><procedure>SetTransmissionCoeff</procedure></A> (self: T; val: REAL) =
  BEGIN
    self.transmission := 1.0 - val;
  END SetTransmissionCoeff;

PROCEDURE <A NAME="DrawMarker"><procedure>DrawMarker</procedure></A> (self : T; p : Point3.T) =
  BEGIN
    IF self.phase = 2 THEN
      (*** SRC 129 says that markers are not affected by lighting ... ***)
      GL.glDisable (GL.GL_LIGHTING);

      GL.glColor3fv (ADR (self.markerColor));
      GL.glPointSize (self.markerScale);

      GL.glBegin (GL.GL_POINTS);
      GL.glVertex3fv (ADR (p));
      GL.glEnd ();

      (*** Reset GL lighting to its previous state *)
      SetLighting (self, self.lighting);
    END;
  END DrawMarker;

PROCEDURE <A NAME="DrawLine"><procedure>DrawLine</procedure></A> (self: T; p1, p2: Point3.T) =
  BEGIN
    IF self.phase = 2 THEN
      (*** SRC 129 says that lines are not affected by lighting ... ***)
      GL.glDisable (GL.GL_LIGHTING);

      GL.glColor3fv (ADR (self.lineColor));
            (* ... strictly speaking wrong: Color.T # ARRAY [1..3] OF REAL *)

      GL.glLineWidth (self.lineWidth);
      GL.glLineStipple (ROUND (self.lineWidth), self.lineType);

      GL.glBegin (GL.GL_LINES);
      GL.glVertex3fv (ADR (p1));
      GL.glVertex3fv (ADR (p2));
      GL.glEnd ();

      (*** Reset GL lighting to its previous state *)
      SetLighting (self, self.lighting);
    END;
  END DrawLine;

PROCEDURE <A NAME="DrawPolygon"><procedure>DrawPolygon</procedure></A> (self         : T;
                       READONLY pts : ARRAY OF Point3.T;
                       shape        : GO.Shape) =

  PROCEDURE DrawHollowPolygon () =
    BEGIN
      (*** Draw a line-loop around the contour of the polygon ***)
      GL.glBegin (GL.GL_LINE_LOOP);
      FOR i := 0 TO LAST (pts) DO
        GL.glVertex3fv (ADR (pts[i]));
      END;
      GL.glEnd ();
    END DrawHollowPolygon;

  PROCEDURE DrawSolidConvexPolygon () =
    VAR
      n: Point3.T;
    BEGIN
      GL.glBegin (GL.GL_POLYGON);

      (* If the polygon is non-degenerate, take the first 3 vertices,
         compute the normal vector, and set it.  We don't scale the normal
         vector to unit length (presumably, OpenGL can do it more efficiently),
         and we cannot determine which side of the polygon is the &quot;front&quot;. *)

      IF NUMBER (pts) &gt;= 3 THEN
        n := Point3.CrossProduct (Point3.Minus (pts[1], pts[0]),
                                  Point3.Minus (pts[2], pts[0]));
        GL.glNormal3fv (ADR (n));
      END;

      FOR i := 0 TO LAST (pts) DO
        GL.glVertex3fv (ADR (pts[i]));
      END;
      GL.glEnd ();
    END DrawSolidConvexPolygon;

  PROCEDURE DrawSolidNonConvexPolygon () =
    BEGIN
      (** Note: We can get around with a single global tesselation object **)
      WITH tess = GLu.gluNewTess () DO
        &lt;* ASSERT tess # NIL *&gt;

        GLu.gluTessCallback (tess, GLu.GLU_BEGIN,
                             LOOPHOLE (GL.glBegin, GLu.GLUtessAnyProc));
        GLu.gluTessCallback (tess, GLu.GLU_VERTEX,
                             LOOPHOLE (GL.glVertex3dv, GLu.GLUtessAnyProc));
        GLu.gluTessCallback (tess, GLu.GLU_END,
                             LOOPHOLE (GL.glEnd, GLu.GLUtessAnyProc));

        GLu.gluBeginPolygon (tess);

        WITH verts = NEW (REF ARRAY OF GLpoint3d, NUMBER (pts)) DO
          FOR i := 0 TO LAST (pts) DO
            WITH v = verts[i], p = pts[i] DO
              v := GLpoint3d {FLOAT (p.x, LONGREAL),
                              FLOAT (p.y, LONGREAL),
                              FLOAT (p.z, LONGREAL)};
              GLu.gluTessVertex (tess, ADR (v), ADR (v));
            END;
          END;
        END;

        GLu.gluEndPolygon (tess);

        GLu.gluDeleteTess (tess);
      END;
    END DrawSolidNonConvexPolygon;

  PROCEDURE DrawSolidComplexPolygon () =
    (* This procedure uses a trick described in the &quot;Red Book&quot;
       (the OpenGL Programming Guide by the OpenGL Architecture Review Board)
       on page 398f. *)
    VAR
      n: Point3.T;
    BEGIN
      (*** Clear the stencil buffer ***)
      GL.glClearStencil (0);
      GL.glClear (GL.GL_STENCIL_BUFFER_BIT);

      (* If the polygon is non-degenerate, take the first 3 vertices, and
         compute the normal vector.  We don't scale the normal vector to unit
         length (presumably, OpenGL can do it more efficiently), and we cannot
         determine which side of the polygon is the &quot;front&quot;. *)

      IF NUMBER (pts) &gt;= 3 THEN
        n := Point3.CrossProduct (Point3.Minus (pts[1], pts[0]),
                                  Point3.Minus (pts[2], pts[0]));
      END;
      (* (p2 - p0) x (p1 - p0)  -&gt;  Lower side is dark *)
      (* (p1 - p0) x (p2 - p0)  -&gt;  Upper side is dark *)

      (*** Enable the stencil test. For each fragment of the triangles to
           come, invert the corresponding stencil buffer entry, but leave
           the frame buffer entry unchanged. ***)
      GL.glStencilFunc (GL.GL_NEVER, 0, 0);
      GL.glStencilOp (GL.GL_INVERT, GL.GL_KEEP, GL.GL_KEEP);
      GL.glEnable (GL.GL_STENCIL_TEST);

      (*** Draw series of triangles (affecting only stencil buffer) ***)
      GL.glBegin (GL.GL_TRIANGLE_FAN);
      FOR i := 0 TO LAST (pts) DO
        GL.glVertex3fv (ADR (pts[i]));
      END;
      GL.glEnd ();

      (*** For each fragment of the triangles to come, modify the corresponding
           frame buffer entry iff the stencil buffer entry is non-zero. Leave
           the stencil buffer entry unchanged. ***)
      GL.glStencilFunc (GL.GL_EQUAL, 1, 1);
      GL.glStencilOp (GL.GL_KEEP, GL.GL_KEEP, GL.GL_KEEP);

      (* Draw series of triangles (affecting frame buffer). Note that we have
         to specify a normal vector, and that OpenGL will invert the normal of
         polygons that are specified through clockwise vertices *)
      FOR i := 1 TO LAST (pts) - 1 DO
        GL.glBegin (GL.GL_TRIANGLES);
        n := Point3.CrossProduct (Point3.Minus (pts[i],   pts[0]),
                                  Point3.Minus (pts[i+1], pts[0]));
        GL.glNormal3fv (ADR (n));
        GL.glVertex3fv (ADR (pts[0]));
        GL.glVertex3fv (ADR (pts[i]));
        GL.glVertex3fv (ADR (pts[i+1]));
        GL.glEnd ();
      END;

      (*** Disable stencil test ***)
      GL.glDisable (GL.GL_STENCIL_TEST);
    END DrawSolidComplexPolygon;

  PROCEDURE DrawSolidPolygon () =
    BEGIN
      CASE shape OF
      | GO.Shape.Convex    =&gt; DrawSolidConvexPolygon();
      | GO.Shape.NonConvex =&gt; DrawSolidNonConvexPolygon();
      | GO.Shape.Complex   =&gt; DrawSolidComplexPolygon();
      | GO.Shape.Unknown   =&gt; DrawSolidComplexPolygon();
      END;
    END DrawSolidPolygon;

  BEGIN
    IF self.phase = 2 THEN
      SetSurfaceMaterial (self);
      CASE self.rasterMode OF
      | RasterModeProp.Kind.Solid  =&gt; DrawSolidPolygon ();
      | RasterModeProp.Kind.Hollow =&gt; DrawHollowPolygon ();
      | RasterModeProp.Kind.Empty  =&gt; (*** a no-op ***)
      END;
      UnsetSurfaceMaterial (self);
    END;

    IF self.edgeFlag THEN
      (*** SRC 129 says that lines are not affected by lighting ... ***)
      GL.glDisable (GL.GL_LIGHTING);

      GL.glColor3fv (ADR (self.edgeColor));
      GL.glLineWidth (self.edgeWidth);
      GL.glLineStipple (ROUND (self.edgeWidth), self.edgeType);

      DrawHollowPolygon ();

      (*** Reset GL lighting to its previous state *)
      SetLighting (self, self.lighting);
    END;
  END DrawPolygon;

PROCEDURE <A NAME="DrawQuadMesh"><procedure>DrawQuadMesh</procedure></A> (self         : T;
                        READONLY pts : ARRAY OF ARRAY OF Point3.T;
                        shape        : GO.Shape) =

  PROCEDURE DrawHollowQuadMesh () =
    BEGIN
      FOR i := 0 TO LAST (pts) DO
        GL.glBegin (GL.GL_LINE_STRIP);
        FOR j := 0 TO LAST(pts[i]) DO
          GL.glVertex3fv (ADR (pts[i][j]));
        END;
        GL.glEnd ();
      END;

      FOR j := 0 TO LAST(pts[0]) DO
        GL.glBegin (GL.GL_LINE_STRIP);
        FOR i := 0 TO LAST (pts) DO
          GL.glVertex3fv (ADR (pts[i][j]));
        END;
        GL.glEnd ();
      END;
    END DrawHollowQuadMesh;

  PROCEDURE DrawSolidQuadMesh () =
    BEGIN
      IF shape = GO.Shape.Convex THEN
        DrawSolidConvexQuadMesh ();
      ELSE
        DrawSolidGeneralQuadMesh ();
      END;
    END DrawSolidQuadMesh;

  PROCEDURE DrawSolidConvexQuadMesh () =
    BEGIN
      FOR i := 0 TO LAST (pts) - 1 DO
        WITH line1 = pts[i], line2 = pts[i+1] DO
          GL.glBegin (GL.GL_QUAD_STRIP);
          FOR j := 0 TO LAST(line1) DO
            (* We don't specify any normal vectors here. Probably we should! *)
            GL.glVertex3fv (ADR (line1[j]));
            GL.glVertex3fv (ADR (line2[j]));
          END;
          GL.glEnd ();
        END;
      END;

      IF self.edgeFlag THEN
        (*** SRC 129 says that lines are not affected by lighting ... ***)
        GL.glDisable (GL.GL_LIGHTING);

        GL.glColor3fv (ADR (self.edgeColor));
        GL.glLineWidth (self.edgeWidth);
        GL.glLineStipple (ROUND (self.edgeWidth), self.edgeType);

        DrawHollowQuadMesh ();

        (*** Reset GL lighting to its previous state *)
        SetLighting (self, self.lighting);
      END;

    END DrawSolidConvexQuadMesh;

  PROCEDURE DrawSolidGeneralQuadMesh () =
    BEGIN
      FOR i := 0 TO LAST (pts) - 1 DO
        WITH line1 = pts[i], line2 = pts[i+1] DO
          FOR j := 0 TO LAST(line1) - 1 DO
            WITH quad = ARRAY OF Point3.T {line1[j],
                                           line2[j],
                                           line2[j+1],
                                           line1[j+1]} DO
              DrawPolygon (self, quad, shape);
            END;
          END;
        END;
      END;
    END DrawSolidGeneralQuadMesh;

  BEGIN
    &lt;* ASSERT AnimServer.IsServer() *&gt;

    IF self.phase = 2 THEN
      SetSurfaceMaterial (self);
      CASE self.rasterMode OF
      | RasterModeProp.Kind.Solid  =&gt; DrawSolidQuadMesh ();
      | RasterModeProp.Kind.Hollow =&gt; DrawHollowQuadMesh ();
      | RasterModeProp.Kind.Empty  =&gt; (*** a no-op ***)
      END;
      UnsetSurfaceMaterial (self);
    END;
  END DrawQuadMesh;

PROCEDURE <A NAME="DrawColoredQuadMesh"><procedure>DrawColoredQuadMesh</procedure></A> (         self  : T;
                               READONLY points: ARRAY OF ARRAY OF Point3.T;
                               READONLY colors: ARRAY OF ARRAY OF Color.T;
                                        shape : GO.Shape) =

  PROCEDURE DrawHollowQuadMesh (lit: BOOLEAN) =

    PROCEDURE EmitColoredVertex (i, j: INTEGER) =
      VAR
        rgba : GLrgba;
        n    : Point3.T;
      BEGIN
        WITH x = MIN (i, LAST(colors)),
             y = MIN (j, LAST(colors[x])),
             c = colors [x][y] DO

          (*** Compute a normal vector ***)
          WITH a = points[x][y],
               b = points[x+1][y],
               c = points[x][y+1] DO
            n := Point3.CrossProduct (Point3.Minus(b, a), Point3.Minus(c, a));
            GL.glNormal3fv (ADR (n));
          END;

          (*** Set the color-related material properties ***)
          rgba := GLrgba {self.ambientReflCoeff * c.r,
                          self.ambientReflCoeff * c.g,
                          self.ambientReflCoeff * c.b,
                          self.transmission};
          GL.glMaterialfv (GL.GL_FRONT_AND_BACK, GL.GL_AMBIENT, ADR (rgba));

          rgba := GLrgba {self.diffuseReflCoeff * c.r,
                          self.diffuseReflCoeff * c.g,
                          self.diffuseReflCoeff * c.b,
                          self.transmission};
          GL.glMaterialfv (GL.GL_FRONT_AND_BACK, GL.GL_DIFFUSE, ADR (rgba));

          rgba := GLrgba {self.specularReflCoeff * self.specularReflColor.r,
                          self.specularReflCoeff * self.specularReflColor.g,
                          self.specularReflCoeff * self.specularReflColor.b,
                          self.transmission};
          GL.glMaterialfv (GL.GL_FRONT_AND_BACK, GL.GL_SPECULAR, ADR (rgba));

          (*** Set the color -- no idea why I have to do it ... ***)
          GL.glColor3fv (ADR (c));

          (*** Emit the vertex ***)
          GL.glVertex3fv (ADR (points[i][j]));
        END;
      END EmitColoredVertex;

    BEGIN
      FOR i := 0 TO LAST (points) DO
        GL.glBegin (GL.GL_LINE_STRIP);
        FOR j := 0 TO LAST(points[i]) DO
          IF lit THEN
            EmitColoredVertex (i, j);
          ELSE
            GL.glVertex3fv (ADR (points[i][j]));
          END;
        END;
        GL.glEnd ();
      END;

      FOR j := 0 TO LAST(points[0]) DO
        GL.glBegin (GL.GL_LINE_STRIP);
        FOR i := 0 TO LAST (points) DO
          IF lit THEN
            EmitColoredVertex (i, j);
          ELSE
            GL.glVertex3fv (ADR (points[i][j]));
          END;
        END;
        GL.glEnd ();
      END;
    END DrawHollowQuadMesh;

  PROCEDURE DrawSolidQuadMesh () =
    BEGIN
      IF shape = GO.Shape.Convex THEN
        DrawSolidConvexQuadMesh ();
      ELSE
        DrawSolidGeneralQuadMesh ();
      END;
    END DrawSolidQuadMesh;

  PROCEDURE DrawSolidConvexQuadMesh () =
    BEGIN
      FOR i := 0 TO LAST (points) - 1 DO
        WITH line1 = points[i], line2 = points[i+1] DO
          GL.glBegin (GL.GL_QUAD_STRIP);
          FOR j := 0 TO LAST(line1) DO
            (* We don't specify any normal vectors here. Probably we should! *)
            IF j &gt; 0 THEN
              GL.glColor3fv (ADR (colors[i][j-1]));
            END;
            GL.glVertex3fv (ADR (line1[j]));
            GL.glVertex3fv (ADR (line2[j]));
          END;
          GL.glEnd ();
        END;
      END;

      IF self.edgeFlag THEN
        (*** SRC 129 says that lines are not affected by lighting ... ***)
        GL.glDisable (GL.GL_LIGHTING);

        GL.glColor3fv (ADR (self.edgeColor));
        GL.glLineWidth (self.edgeWidth);
        GL.glLineStipple (ROUND (self.edgeWidth), self.edgeType);

        DrawHollowQuadMesh (FALSE);

        (*** Reset GL lighting to its previous state *)
        SetLighting (self, self.lighting);
      END;

    END DrawSolidConvexQuadMesh;

  PROCEDURE DrawSolidGeneralQuadMesh () =
    VAR
      fc, bc : Color.T;
    BEGIN
      FOR i := 0 TO LAST (points) - 1 DO
        WITH line1 = points[i], line2 = points[i+1] DO
          FOR j := 0 TO LAST(line1) - 1 DO
            WITH quad = ARRAY OF Point3.T {line1[j],
                                           line2[j],
                                           line2[j+1],
                                           line1[j+1]} DO
              fc := self.frontColor;
              bc := self.backColor;
              self.frontColor := colors[i][j];
              self.backColor := colors[i][j];
              DrawPolygon (self, quad, shape);
              self.frontColor := fc;
              self.backColor  := bc;
            END;
          END;
        END;
      END;
    END DrawSolidGeneralQuadMesh;

  BEGIN
    IF self.phase = 2 THEN
      SetSurfaceMaterial (self);
      CASE self.rasterMode OF
      | RasterModeProp.Kind.Solid  =&gt; DrawSolidQuadMesh ();
      | RasterModeProp.Kind.Hollow =&gt; DrawHollowQuadMesh (TRUE);
      | RasterModeProp.Kind.Empty  =&gt; (*** a no-op ***)
      END;
      UnsetSurfaceMaterial (self);
    END;
  END DrawColoredQuadMesh;

PROCEDURE <A NAME="SetSurfaceMaterial"><procedure>SetSurfaceMaterial</procedure></A> (self: T) =
  VAR
    rgba : GLrgba;
  BEGIN
    IF self.transmission &lt; 1.0 THEN
      (* If the sphere is transparent, disable depth buffer writing (so
         transparent fragments won't mask out opaque ones behind them),
         enable blending, and set up the blending function *)
      GL.glDepthMask (GL.GL_FALSE);
      GL.glEnable (GL.GL_BLEND);
      GL.glBlendFunc (GL.GL_SRC_ALPHA, GL.GL_ONE_MINUS_SRC_ALPHA);
    END;

    (* We could keep track of the color value set by the last call to
       &quot;glColor&quot;, and call it only if there is a change.  For now, I use
       the conservative (aka brute force) approach -- always call it! *)

    (* If &quot;GL_LIGHTING&quot; is disabled, the color of a polygon is set through
       &quot;glColor&quot;; otherwise, it is set through &quot;glMaterial&quot;. It seems that
       &quot;glColor&quot; does not distinguish between front faces and back faces. *)
    GL.glColor3fv (ADR (self.frontColor));

    rgba := GLrgba {self.ambientReflCoeff * self.frontColor.r,
                    self.ambientReflCoeff * self.frontColor.g,
                    self.ambientReflCoeff * self.frontColor.b,
                    self.transmission};
    GL.glMaterialfv (GL.GL_FRONT_AND_BACK, GL.GL_AMBIENT, ADR (rgba));

    rgba := GLrgba {self.diffuseReflCoeff * self.frontColor.r,
                    self.diffuseReflCoeff * self.frontColor.g,
                    self.diffuseReflCoeff * self.frontColor.b,
                    self.transmission};
    GL.glMaterialfv (GL.GL_FRONT_AND_BACK, GL.GL_DIFFUSE, ADR (rgba));

    rgba := GLrgba {self.specularReflCoeff * self.specularReflColor.r,
                    self.specularReflCoeff * self.specularReflColor.g,
                    self.specularReflCoeff * self.specularReflColor.b,
                    self.transmission};
    GL.glMaterialfv (GL.GL_FRONT_AND_BACK, GL.GL_SPECULAR, ADR (rgba));

    GL.glMaterialf (GL.GL_FRONT_AND_BACK, GL.GL_SHININESS,
                    self.specularReflConc);
  END SetSurfaceMaterial;

PROCEDURE <A NAME="UnsetSurfaceMaterial"><procedure>UnsetSurfaceMaterial</procedure></A> (self: T) =
  BEGIN
    IF self.transmission &lt; 1.0 THEN
      GL.glDepthMask (GL.GL_TRUE);
      GL.glDisable (GL.GL_BLEND);
    END;
  END UnsetSurfaceMaterial;

CONST
  NoList = 0;
TYPE
  StructureList = REF RECORD
    prec   : INTEGER;
    fillId : GL.GLuint := NoList;
    lineId : GL.GLuint := NoList;
    next   : StructureList;
  END;

PROCEDURE <A NAME="DrawProtoSphere"><procedure>DrawProtoSphere</procedure></A> (self: T; prec: INTEGER) =

  TYPE Kind = {Line, Fill};

  PROCEDURE Draw (kind: Kind) =
    VAR
      list : StructureList := self.sphereStructures;
      prev : StructureList := NIL;
    BEGIN
      (* Iterate over &quot;list&quot; until we find a cell with the right precision,
         or fall off the back of the list. *)
      WHILE list # NIL AND list.prec # prec DO
        prev := list;
        list := list.next;
      END;
      (* At this point, &quot;list&quot; is either NIL, or points to a cell with the
         right precision. *)

      (* Move the cell to the front of &quot;self.sphereStructures&quot;. *)
      IF list = NIL THEN
        (* Not found in &quot;self.sphereStructures&quot; (which might be NIL).
           Create a new cell, and insert it at the head of the list. *)
        list := NEW (StructureList, prec := prec);
        list.next := self.sphereStructures;
        self.sphereStructures := list;
      ELSIF prev # NIL THEN
        (* Found in &quot;self.sphereStructures&quot; (not at head).
           Move cell to head. *)
        prev.next := list.next;
        list.next := self.sphereStructures;
        self.sphereStructures := list;
      END;
      (* At this point, &quot;list&quot; is non-NIL, and point to a cell &quot;c&quot; such that
         &quot;c.prec = prec&quot;. &quot;c.fillId&quot; and &quot;c.lineId&quot; contain either &quot;NoList&quot;
         or a valid display list. *)

      (* If we have the right display lists cached, call them and return. *)
      CASE kind OF
      | Kind.Fill =&gt;
        IF list.fillId # NoList THEN
          GL.glCallList (list.fillId);
          RETURN;
        END;
      | Kind.Line =&gt;
        IF list.lineId # NoList THEN
          GL.glCallList (list.lineId);
          RETURN;
        END;
      END;

      (* Did not find a matching sphere in the cache -- need to create one *)
      WITH dlid = GL.glGenLists (1) DO

        IF dlid # NoList THEN
          GL.glNewList (dlid, GL.GL_COMPILE_AND_EXECUTE);
        END;

        WITH quad = GLu.gluNewQuadric () DO
          &lt;* ASSERT quad # NIL *&gt;

          CASE kind OF
          | Kind.Fill =&gt;
            GLu.gluQuadricDrawStyle (quad, GLu.GLU_FILL);
            GLu.gluSphere (quad, 1.0d0, prec, prec);
            list.fillId := dlid;
          | Kind.Line =&gt;
            GLu.gluQuadricDrawStyle (quad, GLu.GLU_LINE);
            GLu.gluSphere (quad, 1.005d0, prec, prec);     (* 0.5 % larger *)
            list.lineId := dlid;
          END;

        END;

        IF dlid # NoList THEN
          GL.glEndList ();
        END;

      END;

    END Draw;

  BEGIN
    IF self.phase = 2 THEN

      SetSurfaceMaterial (self);
      CASE self.rasterMode OF
      | RasterModeProp.Kind.Solid  =&gt; Draw (Kind.Fill);
      | RasterModeProp.Kind.Hollow =&gt; Draw (Kind.Line);
      | RasterModeProp.Kind.Empty  =&gt; (*** no-op ***)
      END;
      UnsetSurfaceMaterial (self);

      IF self.edgeFlag THEN
        (*** SRC 129 says that lines are not affected by lighting ... ***)
        GL.glDisable (GL.GL_LIGHTING);

        GL.glColor3fv (ADR (self.edgeColor));
        GL.glLineWidth (self.edgeWidth);
        GL.glLineStipple (ROUND (self.edgeWidth), self.edgeType);

        Draw (Kind.Line);

        (*** Reset GL lighting to its previous state *)
        SetLighting (self, self.lighting);
      END;

    END;
  END DrawProtoSphere;

PROCEDURE <A NAME="DrawProtoCone"><procedure>DrawProtoCone</procedure></A> (self: T; prec: INTEGER) =

  TYPE Kind = {Line, Fill};

  PROCEDURE Draw (kind: Kind) =
    VAR
      list : StructureList := self.coneStructures;
      prev : StructureList := NIL;
    BEGIN
      (* Iterate over &quot;list&quot; until we find a cell with the right precision,
         or fall off the back of the list. *)
      WHILE list # NIL AND list.prec # prec DO
        prev := list;
        list := list.next;
      END;
      (* At this point, &quot;list&quot; is either NIL, or points to a cell with the
         right precision. *)

      (* Move the cell to the front of &quot;self.coneStructures&quot;. *)
      IF list = NIL THEN
        (* Not found in &quot;self.coneStructures&quot; (which might be NIL).
           Create a new cell, and insert it at the head of the list. *)
        list := NEW (StructureList, prec := prec);
        list.next := self.coneStructures;
        self.coneStructures := list;
      ELSIF prev # NIL THEN
        (* Found in &quot;self.coneStructures&quot; (not at head).
           Move cell to head. *)
        prev.next := list.next;
        list.next := self.coneStructures;
        self.coneStructures := list;
      END;
      (* At this point, &quot;list&quot; is non-NIL, and point to a cell &quot;c&quot; such that
         &quot;c.prec = prec&quot;. &quot;c.fillId&quot; and &quot;c.lineId&quot; contain either &quot;NoList&quot;
         or a valid display list. *)

      (* If we have the right display lists cached, call them and return. *)
      CASE kind OF
      | Kind.Fill =&gt;
        IF list.fillId # NoList THEN
          GL.glCallList (list.fillId);
          RETURN;
        END;
      | Kind.Line =&gt;
        IF list.lineId # NoList THEN
          GL.glCallList (list.lineId);
          RETURN;
        END;
      END;

      (* Did not find a matching cone in the cache -- need to create one *)
      WITH dlid = GL.glGenLists (1) DO

        IF dlid # NoList THEN
          GL.glNewList (dlid, GL.GL_COMPILE_AND_EXECUTE);
        END;

        WITH quad = GLu.gluNewQuadric () DO
          &lt;* ASSERT quad # NIL *&gt;

          CASE kind OF
          | Kind.Fill =&gt;
            GLu.gluQuadricDrawStyle (quad, GLu.GLU_FILL);
            GLu.gluCylinder (quad, 1.0d0, 0.0d0, 1.0d0, prec, prec);
            list.fillId := dlid;
          | Kind.Line =&gt;
            GLu.gluQuadricDrawStyle (quad, GLu.GLU_LINE);
            GLu.gluCylinder (quad, 1.005d0, 0.0d0, 1.005d0, prec, prec);
            list.lineId := dlid;
          END;

        END;

        IF dlid # NoList THEN
          GL.glEndList ();
        END;

      END;

    END Draw;

  BEGIN
    IF self.phase = 2 THEN

      SetSurfaceMaterial (self);
      CASE self.rasterMode OF
      | RasterModeProp.Kind.Solid  =&gt; Draw (Kind.Fill);
      | RasterModeProp.Kind.Hollow =&gt; Draw (Kind.Line);
      | RasterModeProp.Kind.Empty  =&gt; (*** no-op ***)
      END;
      UnsetSurfaceMaterial (self);

      IF self.edgeFlag THEN
        (*** SRC 129 says that lines are not affected by lighting ... ***)
        GL.glDisable (GL.GL_LIGHTING);

        GL.glColor3fv (ADR (self.edgeColor));
        GL.glLineWidth (self.edgeWidth);
        GL.glLineStipple (ROUND (self.edgeWidth), self.edgeType);
        Draw (Kind.Line);

        (*** Reset GL lighting to its previous state *)
        SetLighting (self, self.lighting);
      END;

    END;
  END DrawProtoCone;

PROCEDURE <A NAME="DrawProtoCylinder"><procedure>DrawProtoCylinder</procedure></A> (self: T; prec: INTEGER) =

  TYPE Kind = {Line, Fill};

  PROCEDURE Draw (kind: Kind) =
    VAR
      list : StructureList := self.cylinderStructures;
      prev : StructureList := NIL;
    BEGIN
      (* Iterate over &quot;list&quot; until we find a cell with the right precision,
         or fall off the back of the list. *)
      WHILE list # NIL AND list.prec # prec DO
        prev := list;
        list := list.next;
      END;
      (* At this point, &quot;list&quot; is either NIL, or points to a cell with the
         right precision. *)

      (* Move the cell to the front of &quot;self.cylinderStructures&quot;. *)
      IF list = NIL THEN
        (* Not found in &quot;self.cylinderStructures&quot; (which might be NIL).
           Create a new cell, and insert it at the head of the list. *)
        list := NEW (StructureList, prec := prec);
        list.next := self.cylinderStructures;
        self.cylinderStructures := list;
      ELSIF prev # NIL THEN
        (* Found in &quot;self.cylinderStructures&quot; (not at head).
           Move cell to head. *)
        prev.next := list.next;
        list.next := self.cylinderStructures;
        self.cylinderStructures := list;
      END;
      (* At this point, &quot;list&quot; is non-NIL, and point to a cell &quot;c&quot; such that
         &quot;c.prec = prec&quot;. &quot;c.fillId&quot; and &quot;c.lineId&quot; contain either &quot;NoList&quot;
         or a valid display list. *)

      (* If we have the right display lists cached, call them and return. *)
      CASE kind OF
      | Kind.Fill =&gt;
        IF list.fillId # NoList THEN
          GL.glCallList (list.fillId);
          RETURN;
        END;
      | Kind.Line =&gt;
        IF list.lineId # NoList THEN
          GL.glCallList (list.lineId);
          RETURN;
        END;
      END;

      (* Did not find a matching cylinder in the cache -- need to create one *)
      WITH dlid = GL.glGenLists (1) DO

        IF dlid # NoList THEN
          GL.glNewList (dlid, GL.GL_COMPILE_AND_EXECUTE);
        END;

        WITH quad = GLu.gluNewQuadric () DO
          &lt;* ASSERT quad # NIL *&gt;

          CASE kind OF
          | Kind.Fill =&gt;
            GLu.gluQuadricDrawStyle (quad, GLu.GLU_FILL);
            GLu.gluCylinder (quad, 1.0d0, 1.0d0, 1.0d0, prec, prec);
            list.fillId := dlid;
          | Kind.Line =&gt;
            GLu.gluQuadricDrawStyle (quad, GLu.GLU_LINE);
            GLu.gluCylinder (quad, 1.005d0, 1.005d0, 1.0d0, prec, prec);
            list.lineId := dlid;
          END;

        END;

        IF dlid # NoList THEN
          GL.glEndList ();
        END;

      END;

    END Draw;

  BEGIN
    IF self.phase = 2 THEN

      SetSurfaceMaterial (self);
      CASE self.rasterMode OF
      | RasterModeProp.Kind.Solid  =&gt; Draw (Kind.Fill);
      | RasterModeProp.Kind.Hollow =&gt; Draw (Kind.Line);
      | RasterModeProp.Kind.Empty  =&gt; (*** no-op ***)
      END;
      UnsetSurfaceMaterial (self);

      IF self.edgeFlag THEN
        (*** SRC 129 says that lines are not affected by lighting ... ***)
        GL.glDisable (GL.GL_LIGHTING);

        GL.glColor3fv (ADR (self.edgeColor));
        GL.glLineWidth (self.edgeWidth);
        GL.glLineStipple (ROUND (self.edgeWidth), self.edgeType);
        Draw (Kind.Line);

        (*** Reset GL lighting to its previous state *)
        SetLighting (self, self.lighting);
      END;

    END;
  END DrawProtoCylinder;

PROCEDURE <A NAME="DrawProtoDisk"><procedure>DrawProtoDisk</procedure></A> (self: T; prec: INTEGER) =

  TYPE Kind = {Line, Fill};

  PROCEDURE Draw (kind: Kind) =
    VAR
      list : StructureList := self.diskStructures;
      prev : StructureList := NIL;
    BEGIN
      (* Iterate over &quot;list&quot; until we find a cell with the right precision,
         or fall off the back of the list. *)
      WHILE list # NIL AND list.prec # prec DO
        prev := list;
        list := list.next;
      END;
      (* At this point, &quot;list&quot; is either NIL, or points to a cell with the
         right precision. *)

      (* Move the cell to the front of &quot;self.diskStructures&quot;. *)
      IF list = NIL THEN
        (* Not found in &quot;self.diskStructures&quot; (which might be NIL).
           Create a new cell, and insert it at the head of the list. *)
        list := NEW (StructureList, prec := prec);
        list.next := self.diskStructures;
        self.diskStructures := list;
      ELSIF prev # NIL THEN
        (* Found in &quot;self.diskStructures&quot; (not at head).
           Move cell to head. *)
        prev.next := list.next;
        list.next := self.diskStructures;
        self.diskStructures := list;
      END;
      (* At this point, &quot;list&quot; is non-NIL, and point to a cell &quot;c&quot; such that
         &quot;c.prec = prec&quot;. &quot;c.fillId&quot; and &quot;c.lineId&quot; contain either &quot;NoList&quot;
         or a valid display list. *)

      (* If we have the right display lists cached, call them and return. *)
      CASE kind OF
      | Kind.Fill =&gt;
        IF list.fillId # NoList THEN
          GL.glCallList (list.fillId);
          RETURN;
        END;
      | Kind.Line =&gt;
        IF list.lineId # NoList THEN
          GL.glCallList (list.lineId);
          RETURN;
        END;
      END;

      (* Did not find a matching disk in the cache -- need to create one *)
      WITH dlid = GL.glGenLists (1) DO

        IF dlid # NoList THEN
          GL.glNewList (dlid, GL.GL_COMPILE_AND_EXECUTE);
        END;

        WITH quad = GLu.gluNewQuadric () DO
          &lt;* ASSERT quad # NIL *&gt;

          CASE kind OF
          | Kind.Fill =&gt;
            GLu.gluQuadricDrawStyle (quad, GLu.GLU_FILL);
            GLu.gluDisk (quad, 0.0d0, 1.0d0, prec, prec);
            list.fillId := dlid;
          | Kind.Line =&gt;
            GLu.gluQuadricDrawStyle (quad, GLu.GLU_LINE);
            GLu.gluDisk (quad, 0.0d0, 1.0d0, prec, prec);
              (* lies in same plane ==&gt;  surface edges have slight artifacts *)
            list.lineId := dlid;
          END;

        END;

        IF dlid # NoList THEN
          GL.glEndList ();
        END;

      END;

    END Draw;

  BEGIN
    IF self.phase = 2 THEN

      IF self.edgeFlag THEN
        (*** SRC 129 says that lines are not affected by lighting ... ***)
        GL.glDisable (GL.GL_LIGHTING);

        (* Set up edge color, width, and type (&quot;stipple&quot; in OpenGL) *)
        GL.glColor3fv (ADR (self.edgeColor));
        GL.glLineWidth (self.edgeWidth);
        GL.glLineStipple (ROUND (self.edgeWidth), self.edgeType);

        (*** Clear the stencil buffer ***)
        GL.glClearStencil (0);
        GL.glClear (GL.GL_STENCIL_BUFFER_BIT);

        (* First, set all entries in the stencil buffer to 0.  Then, set up the
           stencil test: for each fragment of the surface edges that passes the
           Z-buffer test, set the stencil buffer entry to 1. *)
        GL.glStencilFunc (GL.GL_ALWAYS, 1, 1);
        GL.glStencilOp (GL.GL_KEEP, GL.GL_KEEP, GL.GL_REPLACE);
        GL.glEnable (GL.GL_STENCIL_TEST);

        Draw (Kind.Line);

        (*** Reset GL lighting to its previous state ***)
        SetLighting (self, self.lighting);

        (* Set up the stencil test: Draw any future fragment only if the
           corresponding stencil buffer entry is 0.  In other words, mask out
           the surface edges. *)
        GL.glStencilFunc (GL.GL_EQUAL, 0, 1);
      END;

      SetSurfaceMaterial (self);
      CASE self.rasterMode OF
      | RasterModeProp.Kind.Solid  =&gt; Draw (Kind.Fill);
      | RasterModeProp.Kind.Hollow =&gt; Draw (Kind.Line);
      | RasterModeProp.Kind.Empty  =&gt; (*** no-op ***)
      END;
      UnsetSurfaceMaterial (self);

      IF self.edgeFlag THEN
        GL.glDisable (GL.GL_STENCIL_TEST);
      END;
    END;
  END DrawProtoDisk;

TYPE
  VertexData  = RECORD
    pt   : Point3.T;
    norm : Point3.T;
  END;
  TorusVertices = REF ARRAY OF ARRAY OF VertexData;

PROCEDURE <A NAME="DrawProtoTorus"><procedure>DrawProtoTorus</procedure></A> (self : T; prec : INTEGER; radiusRatio : REAL ) =

  PROCEDURE DrawHollowTorus () =
    BEGIN
      WITH verts = ComputeUnitTorus (prec, radiusRatio * 1.005) DO
        FOR i := 0 TO LAST (verts^) DO
          GL.glBegin (GL.GL_LINE_STRIP);
          FOR j := 0 TO LAST(verts[i]) DO
            GL.glNormal3fv (ADR (verts[i][j].norm));
            GL.glVertex3fv (ADR (verts[i][j].pt));
          END;
          GL.glEnd ();
        END;
        FOR j := 0 TO LAST(verts[0]) DO
          GL.glBegin (GL.GL_LINE_STRIP);
          FOR i := 0 TO LAST (verts^) DO
            GL.glNormal3fv (ADR (verts[i][j].norm));
            GL.glVertex3fv (ADR (verts[i][j].pt));
          END;
          GL.glEnd ();
        END;
      END;
    END DrawHollowTorus;

  PROCEDURE DrawSolidTorus () =
    BEGIN
      WITH verts = ComputeUnitTorus (prec, radiusRatio) DO
        FOR i := 0 TO LAST (verts^) - 1 DO
          WITH line1 = verts[i], line2 = verts[i+1] DO
            GL.glBegin (GL.GL_QUAD_STRIP);
            FOR j := 0 TO LAST(line1) DO
              WITH point1 = line1[j], point2 = line2[j] DO
                GL.glNormal3fv (ADR (point1.norm));
                GL.glVertex3fv (ADR (point1.pt));
                GL.glNormal3fv (ADR (point2.norm));
                GL.glVertex3fv (ADR (point2.pt));
              END;
            END;
            GL.glEnd ();
          END;
        END;
      END;
    END DrawSolidTorus;

  BEGIN
    IF self.phase = 2 THEN

      SetSurfaceMaterial (self);
      CASE self.rasterMode OF
      | RasterModeProp.Kind.Solid  =&gt; DrawSolidTorus ();
      | RasterModeProp.Kind.Hollow =&gt; DrawHollowTorus ();
      | RasterModeProp.Kind.Empty  =&gt; (*** no-op ***)
      END;
      UnsetSurfaceMaterial (self);

      IF self.edgeFlag THEN
        (*** SRC 129 says that lines are not affected by lighting ... ***)
        GL.glDisable (GL.GL_LIGHTING);
        GL.glColor3fv (ADR (self.edgeColor));
        GL.glLineWidth (self.edgeWidth);
        GL.glLineStipple (ROUND (self.edgeWidth), self.edgeType);

        DrawHollowTorus ();

        (*** Reset GL lighting to its previous state *)
        SetLighting (self, self.lighting);
      END;

    END;
  END DrawProtoTorus;

PROCEDURE <A NAME="ComputeUnitTorus"><procedure>ComputeUnitTorus</procedure></A> (prec : INTEGER; radius2 : REAL) : TorusVertices =
  VAR
    verts : TorusVertices := NEW (TorusVertices, prec+1, prec+1);
  BEGIN
    WITH u = AuxG.GetUnitCirclePoints (prec),
             (* normal of unit circle is z-axis *)
         normal = Point3.T {0.0, 0.0, 1.0} DO
      FOR i := 0 TO prec DO
        WITH aux  = u[i],
             a2   = Point3.Plus (aux, Point3.ScaleToLen (normal, radius2)),
             b2   = Point3.Plus (aux, Point3.ScaleToLen (aux, radius2)),
             c2   = Point3.Plus (aux, Point3.CrossProduct(aux, normal)),
             N    = Matrix4.TransformUnitCube (aux, a2, b2, c2) DO
          FOR j := 0 TO prec DO
            WITH p = Matrix4.TransformPoint3 (N, u[j]),
                 n = Point3.Minus (aux, p) DO
              verts[i][j] := VertexData {p, n};
            END;
          END;
        END;
      END;
    END;
    RETURN verts;
  END ComputeUnitTorus;
</PRE>***************************************************************************
 Event handling                                                            
***************************************************************************

<P>
<P><PRE>PROCEDURE <A NAME="ProcessEvents"><procedure>ProcessEvents</procedure></A> (self : T) =
  BEGIN
    self.eventQueue.drain (self);
  END ProcessEvents;
</PRE>***************************************************************************
 The <CODE>window thread</CODE>.  There is one such thread per window / graphics base.
 Responsible for creating a window, and for moving messages from the       
 Windows message queue to a user-level event queue. The actual processing  
 of the buffered events is then done by the animation server thread.       
***************************************************************************

<P>
<P><PRE>TYPE
  Closure = Thread.Closure OBJECT
    base: T;
  OVERRIDES
    apply := Apply;
  END;

PROCEDURE <A NAME="Apply"><procedure>Apply</procedure></A> (self: Closure): REFANY =
  VAR
    base  := self.base;
    status: WinDef.BOOL;
    cs    : WinUser.CREATESTRUCT;
    pf    : Ctypes.int;
    pfd   : WinGDI.PIXELFORMATDESCRIPTOR;
    msg   : WinUser.MSG;
  BEGIN
    LOCK conn DO
      (* Create a window *)
      conn.currBase := base;
      base.hwnd := WinUser.CreateWindow (
                       conn.windowclassName,
                       M3toC.CopyTtoS (base.title),
                       WinUser.WS_OVERLAPPEDWINDOW
                         + WinUser.WS_CLIPSIBLINGS
                         + WinUser.WS_CLIPCHILDREN,
                       base.origin.h,
                       base.origin.v,
                       base.dimen.h + conn.nonclient.h,
                       base.dimen.v + conn.nonclient.v,
                       NIL, NIL, conn.hInst,
                       ADR (cs));
      &lt;* ASSERT base.hwnd # NIL *&gt;

      (* add the window handle to the map from handles to bases, and reset
         the &quot;currBase&quot; field. *)
      EVAL conn.hwndMap.put (LOOPHOLE (base.hwnd, INTEGER), base);
      conn.currBase := NIL;

      (* map the window *)
      EVAL WinUser.ShowWindow (base.hwnd, WinUser.SW_SHOWDEFAULT);

      (* update the window (repaint its client area) *)
      status := WinUser.UpdateWindow (base.hwnd);
      &lt;* ASSERT status = True *&gt;

      (* Cache the device context in &quot;base.hdc&quot;. Note that we can do this only
         because we declared the device context to be private (&quot;CS_OWNDC&quot;). *)
      base.hdc := WinUser.GetDC (base.hwnd);
      &lt;* ASSERT base.hdc # NIL *&gt;
</PRE><P>
      (* As a test, dump out the supported pixel formats 
      <PRE>DumpPixelFormats (base.hdc);
*)

      (* Choose the best pixel format.  This is the Windows equivalent of
         choosing the best visual in X. *)
      pfd.nSize        := BYTESIZE (WinGDI.PIXELFORMATDESCRIPTOR);
      pfd.nVersion     := 1;                     (* must be 1 *)
      pfd.dwFlags      := WinGDI.PFD_DRAW_TO_WINDOW +
                          WinGDI.PFD_SUPPORT_OPENGL +
                          WinGDI.PFD_DOUBLEBUFFER +
                          WinGDI.PFD_STEREO_DONTCARE;
      pfd.iPixelType   := WinGDI.PFD_TYPE_RGBA;  (* RGB vs index color *)
      pfd.cColorBits   := 24;
      pfd.cAlphaBits   := 8;
      pfd.cAccumBits   := 0;                     (* don't need Accum buffer  *)
      pfd.cDepthBits   := 32;
      pfd.cStencilBits := 1;                     (* need 1-bit stencil buffer*)
      pfd.cAuxBuffers  := 0;                     (* don't need aux. buffers  *)
      pfd.iLayerType   := WinGDI.PFD_MAIN_PLANE; (* only supported value ... *)

      pf := WinGDI.ChoosePixelFormat (base.hdc, ADR (pfd));
      &lt;* ASSERT pf &gt; 0 *&gt;
</PRE><BLOCKQUOTE><EM><P>
      IO.Put (<CODE>ChoosePixelformat suggests format </CODE> &amp; Fmt.Int (pf) &amp; <CODE>\n</CODE>);
</EM></BLOCKQUOTE><PRE>
</PRE>**
   1: white sphere, red and blue shadows, regular repaints (no DB)
   2: white sphere, red and blue shadows, regular repaints (no DB)
   3: white sphere, red and blue shadows
   4: white sphere, red and blue shadows
   5: red sphere, regular repaints (no DB)
   6: red sphere, regular repaints (no DB)
   7: red sphere
   8: red sphere
   9: breaks
  10: breaks
  11: breaks
  12: breaks
  13: breaks
  14:
  15:
  16:
  17:
  18:
  19:
  20:
  21:
  22:
  23:
  24: breaks
**
      <PRE>status := WinGDI.SetPixelFormat (base.hdc, pf, ADR (pfd));
      &lt;* ASSERT status = True *&gt;

      (* Create an OpenGL rendering context, and make it current. *)
      base.hglrc := WinGDI.wglCreateContext (base.hdc);
      &lt;* ASSERT base.hglrc # NIL *&gt;

      status := WinGDI.wglMakeCurrent (base.hdc, base.hglrc);
      &lt;* ASSERT status = True *&gt;
</PRE>****
      (* Create a color map 
      <PRE>cmap := X.XCreateColormap (dpy, X.XRootWindow (dpy, visual.screen),
                                 visual.visual, X.AllocNone);
****)

      (*** Determine the default frame buffer ***)
      GL.glGetIntegerv (GL.GL_DRAW_BUFFER, ADR (base.drawBuffer));

      (*** Enable depth buffering and set the depth buffer clear value ***)
      GL.glEnable (GL.GL_DEPTH_TEST);
      GL.glDepthFunc (GL.GL_GREATER);
      GL.glClearDepth (0.0d0);

      (*** Create the display list for light sources ***)
      GL.glEnable (GL.GL_LIGHTING);
      GL.glLightModeli(GL.GL_LIGHT_MODEL_TWO_SIDE, GL.GL_TRUE);
      base.lightList := GL.glGenLists (1);
      IF base.lightList = 0 THEN
        RAISE GraphicsBase.Failure;
      END;

      (* Select flat shading and auto-normalization of normal vectors *)
      GL.glShadeModel (GL.GL_FLAT);
      GL.glEnable (GL.GL_NORMALIZE);

      GL.glEnable (GL.GL_LINE_STIPPLE);
      GL.glLineStipple (1, Solid);

      (* In Windows, an OpenGL rendering context can be current to at most
         one thread at a time.  So, this thread (the window thread) must
         release &quot;base.hglrc&quot; for the animation server thread to make it
         current. *)
      status := WinGDI.wglMakeCurrent (base.hdc, NIL);
      &lt;* ASSERT status = True *&gt;

      WITH pp = NEW(ParseParams.T).init(Stdio.stderr) DO
        IF pp.keywordPresent(&quot;-largeCursor&quot;) THEN
          (*** LargeCursor(base); ***) (*** For now, We don't deal with it ***)
        END;
      END;

      (* Signal the animation server thread that window creation is complete *)
      Thread.Signal (base.windowThreadCV);
    END; (* release conn *)

    (* start the message loop for this window / graphics base *)
    WHILE WinUser.GetMessage (ADR (msg), NIL, 0, 0) = True DO
      EVAL WinUser.TranslateMessage (ADR (msg));
      EVAL WinUser.DispatchMessage (ADR (msg));
    END;

    (* terminate the thread *)
    RETURN NIL;
  END Apply;

&lt;*UNUSED*&gt;
PROCEDURE <A NAME="DumpPixelFormats"><procedure>DumpPixelFormats</procedure></A> (hdc: WinDef.HDC) =
  VAR
    pfd   : WinGDI.PIXELFORMATDESCRIPTOR;
    n     : Ctypes.int;
    status: Ctypes.int;
  BEGIN
    n := WinGDI.DescribePixelFormat (hdc, 1, BYTESIZE (pfd), ADR (pfd));
    &lt;* ASSERT n &gt; 0 *&gt;

    FOR i := 1 TO n DO
      status := WinGDI.DescribePixelFormat (hdc, i, BYTESIZE (pfd), ADR (pfd));
      &lt;* ASSERT status # 0 *&gt;
        IO.Put (&quot;PF &quot; &amp; Fmt.Int (i) &amp; &quot;\n&quot;);
        IO.Put (&quot;  flags : &quot; &amp; Fmt.Int (pfd.dwFlags) &amp; &quot; (&quot;);
        WITH f = pfd.dwFlags DO
          IF Word.And (f, WinGDI.PFD_DOUBLEBUFFER) # 0 THEN
            IO.Put (&quot; DOUBLEBUFFER &quot;);
          END;
          IF Word.And (f, WinGDI.PFD_STEREO) # 0 THEN
            IO.Put (&quot; STEREO &quot;);
          END;
          IF Word.And (f, WinGDI.PFD_DRAW_TO_WINDOW) # 0 THEN
            IO.Put (&quot; DRAW_TO_WINDOW &quot;);
          END;
          IF Word.And (f, WinGDI.PFD_DRAW_TO_BITMAP) # 0 THEN
            IO.Put (&quot; DRAW_TO_BITMAP &quot;);
          END;
          IF Word.And (f, WinGDI.PFD_SUPPORT_GDI) # 0 THEN
            IO.Put (&quot; SUPPORT_GDI &quot;);
          END;
          IF Word.And (f, WinGDI.PFD_SUPPORT_OPENGL) # 0 THEN
            IO.Put (&quot; SUPPORT_OPENGL &quot;);
          END;
          IF Word.And (f, WinGDI.PFD_GENERIC_FORMAT) # 0 THEN
            IO.Put (&quot; GENERIC_FORMAT &quot;);
          END;
          IF Word.And (f, WinGDI.PFD_NEED_PALETTE) # 0 THEN
            IO.Put (&quot; NEED_PALETTE &quot;);
          END;
          IF Word.And (f, WinGDI.PFD_NEED_SYSTEM_PALETTE) # 0 THEN
            IO.Put (&quot; NEED_SYSTEM_PALETTE &quot;);
          END;
        END;
        IO.Put (&quot;)\n&quot;);
        IO.Put (&quot;  type  : &quot;);
        IF pfd.iPixelType = WinGDI.PFD_TYPE_RGBA THEN
          IO.Put (&quot;RGBA&quot;);
        ELSIF pfd.iPixelType = WinGDI.PFD_TYPE_COLORINDEX THEN
          IO.Put (&quot;color index&quot;);
        ELSE
          IO.Put (&quot;unknown&quot;);
        END;
        IO.Put (&quot;\n&quot;);
        IO.Put (&quot;  color bits   : &quot; &amp; Fmt.Int (pfd.cColorBits) &amp; &quot;\n&quot;);
        IO.Put (&quot;  alpha bits   : &quot; &amp; Fmt.Int (pfd.cAlphaBits) &amp; &quot;\n&quot;);
        IO.Put (&quot;  depth bits   : &quot; &amp; Fmt.Int (pfd.cDepthBits) &amp; &quot;\n&quot;);
        IO.Put (&quot;  stencil bits : &quot; &amp; Fmt.Int (pfd.cStencilBits) &amp; &quot;\n&quot;);
    END;
  END DumpPixelFormats;
</PRE>***************************************************************************
 Transfer from Windows message queue to user-level event queue             
***************************************************************************

<P><PRE>PROCEDURE <A NAME="GetBase"><procedure>GetBase</procedure></A> (hwnd: WinDef.HWND): T =
    (* Find the graphics base that correspend to the window handle. Normally,
       this is done by looking up the handle in the table &quot;conn.hwndMap&quot;.
       However, the handle can be  entered into the table only after it is
       returned by &quot;CreateWindow&quot;.  So, if the window is currently being
       created, the handle will not be found.  In this case, we use the
       base that is cached in &quot;conn.currBase&quot;. *)
  VAR
    ref: REFANY;
  BEGIN
    IF conn.hwndMap.get (LOOPHOLE (hwnd, INTEGER),
                         LOOPHOLE (ref, REFANY)) THEN
      RETURN ref;
    ELSIF conn.currBase # NIL THEN
      RETURN conn.currBase;
    ELSE
      &lt;* ASSERT FALSE *&gt;
    END;
  END GetBase;

CONST
  WM_INITIATE_DESTROY = WinUser.WM_USER;

&lt;*CALLBACK*&gt; PROCEDURE <A NAME="WindowProc"><procedure>WindowProc</procedure></A> (hwnd   : WinDef.HWND;
                                   message: WinDef.UINT;
                                   wParam : WinDef.WPARAM;
                                   lParam : WinDef.LPARAM  ): WinDef.LRESULT =
  BEGIN
    CASE message OF
    | WM_INITIATE_DESTROY =&gt;
      VAR
        status: WinDef.BOOL;
      BEGIN
        WITH base = GetBase (hwnd) DO
          status := WinUser.DestroyWindow (base.hwnd);
          &lt;* ASSERT status = True *&gt;
        END;
      END;
      RETURN 0;
    | WinUser.WM_PAINT =&gt;
      WITH base = GetBase (hwnd) DO
        base.eventQueue.put (NEW (ExposeEvent));
      END;
      RETURN 0;
    | WinUser.WM_CLOSE =&gt;
      WITH base = GetBase (hwnd) DO
        base.eventQueue.put (NEW (DestroyEvent));
      END;
      RETURN 0;
    | WinUser.WM_SIZE =&gt;
      WITH base = GetBase (hwnd),
           w = WinDef.LOWORD (lParam),
           h = WinDef.HIWORD (lParam),
           e = NEW (ReshapeEvent, width := w, height := h) DO
        base.eventQueue.put (e);
      END;
      RETURN 0;
    | WinUser.WM_KEYDOWN =&gt;
      WITH base = GetBase (hwnd),
           key  = VirtualKeyToKeySym (wParam),
           e = NEW (KeyEvent, key := key, down := TRUE) DO
        base.eventQueue.put (e);
      END;
      RETURN 0;
    | WinUser.WM_KEYUP =&gt;
      WITH base = GetBase (hwnd),
           key  = VirtualKeyToKeySym (wParam),
           e = NEW (KeyEvent, key := key, down := FALSE) DO
        base.eventQueue.put (e);
      END;
      RETURN 0;
    | WinUser.WM_LBUTTONDOWN, WinUser.WM_MBUTTONDOWN, WinUser.WM_RBUTTONDOWN =&gt;
      VAR
        button: VBT.Button;
      BEGIN
        CASE message OF
        | WinUser.WM_LBUTTONDOWN =&gt; button := VBT.Modifier.MouseL;
        | WinUser.WM_MBUTTONDOWN =&gt; button := VBT.Modifier.MouseM;
        | WinUser.WM_RBUTTONDOWN =&gt; button := VBT.Modifier.MouseR;
        ELSE
        END;
        WITH base = GetBase (hwnd),
             pos  = Point.T {WinDef.LOWORD (lParam), WinDef.HIWORD (lParam)},
             e    = NEW (ButtonDownEvent, button := button, pos := pos) DO
           base.eventQueue.put (e);
        END;
      END;
      RETURN 0;
    | WinUser.WM_LBUTTONUP, WinUser.WM_MBUTTONUP, WinUser.WM_RBUTTONUP =&gt;
      VAR
        button: VBT.Button;
      BEGIN
        CASE message OF
        | WinUser.WM_LBUTTONUP =&gt; button := VBT.Modifier.MouseL;
        | WinUser.WM_MBUTTONUP =&gt; button := VBT.Modifier.MouseM;
        | WinUser.WM_RBUTTONUP =&gt; button := VBT.Modifier.MouseR;
        ELSE
        END;
        WITH base = GetBase (hwnd),
             pos  = Point.T {WinDef.LOWORD (lParam), WinDef.HIWORD (lParam)},
             e    = NEW (ButtonUpEvent, button := button, pos := pos) DO
           base.eventQueue.put (e);
        END;
      END;
      RETURN 0;
    | WinUser.WM_MOUSEMOVE =&gt;
      WITH base = GetBase (hwnd),
           pos  = Point.T {WinDef.LOWORD (lParam), WinDef.HIWORD (lParam)},
           e = NEW (MotionEvent, pos := pos) DO
        base.eventQueue.put (e);
      END;
      RETURN 0;
    ELSE
      RETURN WinUser.DefWindowProc (hwnd, message, wParam, lParam);
    END;
  END WindowProc;

PROCEDURE <A NAME="VirtualKeyToKeySym"><procedure>VirtualKeyToKeySym</procedure></A> (vk: [0 .. 255]): VBT.KeySym =
  VAR
    shifted := Word.And (WinUser.GetKeyState (WinUser.VK_SHIFT), 16_8000) # 0;
  BEGIN
    IF NOT shifted THEN
      CASE vk OF
      | (* 01 *) WinUser.VK_LBUTTON  =&gt; RETURN KeyboardKey.VoidSymbol;
      | (* 02 *) WinUser.VK_RBUTTON  =&gt; RETURN KeyboardKey.VoidSymbol;
      | (* 03 *) WinUser.VK_CANCEL   =&gt; RETURN KeyboardKey.Cancel;
      | (* 04 *) WinUser.VK_MBUTTON  =&gt; RETURN KeyboardKey.VoidSymbol;
      | (* 08 *) WinUser.VK_BACK     =&gt; RETURN KeyboardKey.BackSpace;
      | (* 09 *) WinUser.VK_TAB      =&gt; RETURN KeyboardKey.Tab;
      | (* 0C *) WinUser.VK_CLEAR    =&gt; RETURN KeyboardKey.Clear;
      | (* 0D *) WinUser.VK_RETURN   =&gt; RETURN KeyboardKey.Return;

      | (* 10 *) WinUser.VK_SHIFT    =&gt; RETURN KeyboardKey.Shift_L;   (* simplification *)
      | (* 11 *) WinUser.VK_CONTROL  =&gt; RETURN KeyboardKey.Control_L; (* simplification *)
      | (* 12 *) WinUser.VK_MENU     =&gt; RETURN KeyboardKey.Menu;
      | (* 13 *) WinUser.VK_PAUSE    =&gt; RETURN KeyboardKey.Pause;
      | (* 14 *) WinUser.VK_CAPITAL  =&gt; RETURN KeyboardKey.Caps_Lock;
      | (* 1B *) WinUser.VK_ESCAPE   =&gt; RETURN KeyboardKey.Escape;

      | (* 20 *) WinUser.VK_SPACE    =&gt; RETURN Latin1Key.space;
      | (* 21 *) WinUser.VK_PRIOR    =&gt; RETURN KeyboardKey.Prior;
      | (* 22 *) WinUser.VK_NEXT     =&gt; RETURN KeyboardKey.Next;
      | (* 23 *) WinUser.VK_END      =&gt; RETURN KeyboardKey.End;
      | (* 24 *) WinUser.VK_HOME     =&gt; RETURN KeyboardKey.Home;
      | (* 25 *) WinUser.VK_LEFT     =&gt; RETURN KeyboardKey.Left;
      | (* 26 *) WinUser.VK_UP       =&gt; RETURN KeyboardKey.Up;
      | (* 27 *) WinUser.VK_RIGHT    =&gt; RETURN KeyboardKey.Right;
      | (* 28 *) WinUser.VK_DOWN     =&gt; RETURN KeyboardKey.Down;
      | (* 29 *) WinUser.VK_SELECT   =&gt; RETURN KeyboardKey.Select;
      | (* 2A *) WinUser.VK_PRINT    =&gt; RETURN KeyboardKey.Print;
      | (* 2B *) WinUser.VK_EXECUTE  =&gt; RETURN KeyboardKey.Execute;
      | (* 2C *) WinUser.VK_SNAPSHOT =&gt; RETURN KeyboardKey.VoidSymbol;
      | (* 2D *) WinUser.VK_INSERT   =&gt; RETURN KeyboardKey.Insert;
      | (* 2E *) WinUser.VK_DELETE   =&gt; RETURN KeyboardKey.Delete;
      | (* 2F *) WinUser.VK_HELP     =&gt; RETURN KeyboardKey.Help;

      | 16_30 =&gt; RETURN Latin1Key.zero;
      | 16_31 =&gt; RETURN Latin1Key.one;
      | 16_32 =&gt; RETURN Latin1Key.two;
      | 16_33 =&gt; RETURN Latin1Key.three;
      | 16_34 =&gt; RETURN Latin1Key.four;
      | 16_35 =&gt; RETURN Latin1Key.five;
      | 16_36 =&gt; RETURN Latin1Key.six;
      | 16_37 =&gt; RETURN Latin1Key.seven;
      | 16_38 =&gt; RETURN Latin1Key.eight;
      | 16_39 =&gt; RETURN Latin1Key.nine;

      | 16_41 =&gt; RETURN Latin1Key.a;
      | 16_42 =&gt; RETURN Latin1Key.b;
      | 16_43 =&gt; RETURN Latin1Key.c;
      | 16_44 =&gt; RETURN Latin1Key.d;
      | 16_45 =&gt; RETURN Latin1Key.e;
      | 16_46 =&gt; RETURN Latin1Key.f;
      | 16_47 =&gt; RETURN Latin1Key.g;
      | 16_48 =&gt; RETURN Latin1Key.h;
      | 16_49 =&gt; RETURN Latin1Key.i;
      | 16_4A =&gt; RETURN Latin1Key.j;
      | 16_4B =&gt; RETURN Latin1Key.k;
      | 16_4C =&gt; RETURN Latin1Key.l;
      | 16_4D =&gt; RETURN Latin1Key.m;
      | 16_4E =&gt; RETURN Latin1Key.n;
      | 16_4F =&gt; RETURN Latin1Key.o;
      | 16_50 =&gt; RETURN Latin1Key.p;
      | 16_51 =&gt; RETURN Latin1Key.q;
      | 16_52 =&gt; RETURN Latin1Key.r;
      | 16_53 =&gt; RETURN Latin1Key.s;
      | 16_54 =&gt; RETURN Latin1Key.t;
      | 16_55 =&gt; RETURN Latin1Key.u;
      | 16_56 =&gt; RETURN Latin1Key.v;
      | 16_57 =&gt; RETURN Latin1Key.w;
      | 16_58 =&gt; RETURN Latin1Key.x;
      | 16_59 =&gt; RETURN Latin1Key.y;
      | 16_5A =&gt; RETURN Latin1Key.z;

      | (* 60 *) WinUser.VK_NUMPAD0   =&gt; RETURN KeyboardKey.KP_0;
      | (* 61 *) WinUser.VK_NUMPAD1   =&gt; RETURN KeyboardKey.KP_1;
      | (* 62 *) WinUser.VK_NUMPAD2   =&gt; RETURN KeyboardKey.KP_2;
      | (* 63 *) WinUser.VK_NUMPAD3   =&gt; RETURN KeyboardKey.KP_3;
      | (* 64 *) WinUser.VK_NUMPAD4   =&gt; RETURN KeyboardKey.KP_4;
      | (* 65 *) WinUser.VK_NUMPAD5   =&gt; RETURN KeyboardKey.KP_5;
      | (* 66 *) WinUser.VK_NUMPAD6   =&gt; RETURN KeyboardKey.KP_6;
      | (* 67 *) WinUser.VK_NUMPAD7   =&gt; RETURN KeyboardKey.KP_7;
      | (* 68 *) WinUser.VK_NUMPAD8   =&gt; RETURN KeyboardKey.KP_8;
      | (* 69 *) WinUser.VK_NUMPAD9   =&gt; RETURN KeyboardKey.KP_9;
      | (* 6A *) WinUser.VK_MULTIPLY  =&gt; RETURN KeyboardKey.KP_Multiply;
      | (* 6B *) WinUser.VK_ADD       =&gt; RETURN KeyboardKey.KP_Add;
      | (* 6C *) WinUser.VK_SEPARATOR =&gt; RETURN KeyboardKey.KP_Separator;
      | (* 6D *) WinUser.VK_SUBTRACT  =&gt; RETURN KeyboardKey.KP_Subtract;
      | (* 6E *) WinUser.VK_DECIMAL   =&gt; RETURN KeyboardKey.KP_Decimal;
      | (* 6F *) WinUser.VK_DIVIDE    =&gt; RETURN KeyboardKey.KP_Divide;

      | (* 70 *) WinUser.VK_F1        =&gt; RETURN KeyboardKey.F1;
      | (* 71 *) WinUser.VK_F2        =&gt; RETURN KeyboardKey.F2;
      | (* 72 *) WinUser.VK_F3        =&gt; RETURN KeyboardKey.F3;
      | (* 73 *) WinUser.VK_F4        =&gt; RETURN KeyboardKey.F4;
      | (* 74 *) WinUser.VK_F5        =&gt; RETURN KeyboardKey.F5;
      | (* 75 *) WinUser.VK_F6        =&gt; RETURN KeyboardKey.F6;
      | (* 76 *) WinUser.VK_F7        =&gt; RETURN KeyboardKey.F7;
      | (* 77 *) WinUser.VK_F8        =&gt; RETURN KeyboardKey.F8;
      | (* 78 *) WinUser.VK_F9        =&gt; RETURN KeyboardKey.F9;
      | (* 79 *) WinUser.VK_F10       =&gt; RETURN KeyboardKey.F10;
      | (* 7A *) WinUser.VK_F11       =&gt; RETURN KeyboardKey.F11;
      | (* 7B *) WinUser.VK_F12       =&gt; RETURN KeyboardKey.F12;
      | (* 7C *) WinUser.VK_F13       =&gt; RETURN KeyboardKey.F13;
      | (* 7D *) WinUser.VK_F14       =&gt; RETURN KeyboardKey.F14;
      | (* 7E *) WinUser.VK_F15       =&gt; RETURN KeyboardKey.F15;
      | (* 7F *) WinUser.VK_F16       =&gt; RETURN KeyboardKey.F16;
      | (* 80 *) WinUser.VK_F17       =&gt; RETURN KeyboardKey.F17;
      | (* 81 *) WinUser.VK_F18       =&gt; RETURN KeyboardKey.F18;
      | (* 82 *) WinUser.VK_F19       =&gt; RETURN KeyboardKey.F19;
      | (* 83 *) WinUser.VK_F20       =&gt; RETURN KeyboardKey.F20;
      | (* 84 *) WinUser.VK_F21       =&gt; RETURN KeyboardKey.F21;
      | (* 85 *) WinUser.VK_F22       =&gt; RETURN KeyboardKey.F22;
      | (* 86 *) WinUser.VK_F23       =&gt; RETURN KeyboardKey.F23;
      | (* 87 *) WinUser.VK_F24       =&gt; RETURN KeyboardKey.F24;

      | (* 90 *) WinUser.VK_NUMLOCK   =&gt; RETURN KeyboardKey.Num_Lock;
      | (* 91 *) WinUser.VK_SCROLL    =&gt; RETURN KeyboardKey.Scroll_Lock;

      | (* A0 *) WinUser.VK_LSHIFT    =&gt; RETURN KeyboardKey.Shift_L;
      | (* A1 *) WinUser.VK_RSHIFT    =&gt; RETURN KeyboardKey.Shift_R;
      | (* A2 *) WinUser.VK_LCONTROL  =&gt; RETURN KeyboardKey.Control_L;
      | (* A3 *) WinUser.VK_RCONTROL  =&gt; RETURN KeyboardKey.Control_R;
      | (* A4 *) WinUser.VK_LMENU     =&gt; RETURN KeyboardKey.Alt_L;
      | (* A5 *) WinUser.VK_RMENU     =&gt; RETURN KeyboardKey.Alt_R;

      (* The next few codes are device-specific ... *)

      | 16_BA =&gt; RETURN Latin1Key.semicolon;
      | 16_BB =&gt; RETURN Latin1Key.equal;
      | 16_BC =&gt; RETURN Latin1Key.comma;
      | 16_BD =&gt; RETURN Latin1Key.minus;
      | 16_BE =&gt; RETURN Latin1Key.period;
      | 16_BF =&gt; RETURN Latin1Key.slash;
      | 16_C0 =&gt; RETURN Latin1Key.grave;
      | 16_DB =&gt; RETURN Latin1Key.bracketleft;
      | 16_DC =&gt; RETURN Latin1Key.backslash;
      | 16_DD =&gt; RETURN Latin1Key.bracketright;
      | 16_DE =&gt; RETURN Latin1Key.apostrophe;

      | (* F6 *) WinUser.VK_ATTN      =&gt; RETURN KeyboardKey.VoidSymbol;
      | (* F7 *) WinUser.VK_CRSEL     =&gt; RETURN KeyboardKey.VoidSymbol;
      | (* F8 *) WinUser.VK_EXSEL     =&gt; RETURN KeyboardKey.VoidSymbol;
      | (* F9 *) WinUser.VK_EREOF     =&gt; RETURN KeyboardKey.VoidSymbol;
      | (* FA *) WinUser.VK_PLAY      =&gt; RETURN KeyboardKey.VoidSymbol;
      | (* FB *) WinUser.VK_ZOOM      =&gt; RETURN KeyboardKey.VoidSymbol;
      | (* FC *) WinUser.VK_NONAME    =&gt; RETURN KeyboardKey.VoidSymbol;
      | (* FD *) WinUser.VK_PA1       =&gt; RETURN KeyboardKey.VoidSymbol;
      | (* FE *) WinUser.VK_OEM_CLEAR =&gt; RETURN KeyboardKey.VoidSymbol;

      ELSE
        RETURN KeyboardKey.VoidSymbol;
      END;

    ELSE

      CASE vk OF
      | (* 01 *) WinUser.VK_LBUTTON  =&gt; RETURN KeyboardKey.VoidSymbol;
      | (* 02 *) WinUser.VK_RBUTTON  =&gt; RETURN KeyboardKey.VoidSymbol;
      | (* 03 *) WinUser.VK_CANCEL   =&gt; RETURN KeyboardKey.Cancel;
      | (* 04 *) WinUser.VK_MBUTTON  =&gt; RETURN KeyboardKey.VoidSymbol;
      | (* 08 *) WinUser.VK_BACK     =&gt; RETURN KeyboardKey.BackSpace;
      | (* 09 *) WinUser.VK_TAB      =&gt; RETURN KeyboardKey.Tab;
      | (* 0C *) WinUser.VK_CLEAR    =&gt; RETURN KeyboardKey.Clear;
      | (* 0D *) WinUser.VK_RETURN   =&gt; RETURN KeyboardKey.Return;

      | (* 10 *) WinUser.VK_SHIFT    =&gt; RETURN KeyboardKey.Shift_L;   (* simplification *)
      | (* 11 *) WinUser.VK_CONTROL  =&gt; RETURN KeyboardKey.Control_L; (* simplification *)
      | (* 12 *) WinUser.VK_MENU     =&gt; RETURN KeyboardKey.Menu;
      | (* 13 *) WinUser.VK_PAUSE    =&gt; RETURN KeyboardKey.Pause;
      | (* 14 *) WinUser.VK_CAPITAL  =&gt; RETURN KeyboardKey.Caps_Lock;
      | (* 1B *) WinUser.VK_ESCAPE   =&gt; RETURN KeyboardKey.Escape;

      | (* 20 *) WinUser.VK_SPACE    =&gt; RETURN Latin1Key.space;
      | (* 21 *) WinUser.VK_PRIOR    =&gt; RETURN KeyboardKey.Prior;
      | (* 22 *) WinUser.VK_NEXT     =&gt; RETURN KeyboardKey.Next;
      | (* 23 *) WinUser.VK_END      =&gt; RETURN KeyboardKey.End;
      | (* 24 *) WinUser.VK_HOME     =&gt; RETURN KeyboardKey.Home;
      | (* 25 *) WinUser.VK_LEFT     =&gt; RETURN KeyboardKey.Left;
      | (* 26 *) WinUser.VK_UP       =&gt; RETURN KeyboardKey.Up;
      | (* 27 *) WinUser.VK_RIGHT    =&gt; RETURN KeyboardKey.Right;
      | (* 28 *) WinUser.VK_DOWN     =&gt; RETURN KeyboardKey.Down;
      | (* 29 *) WinUser.VK_SELECT   =&gt; RETURN KeyboardKey.Select;
      | (* 2A *) WinUser.VK_PRINT    =&gt; RETURN KeyboardKey.Print;
      | (* 2B *) WinUser.VK_EXECUTE  =&gt; RETURN KeyboardKey.Execute;
      | (* 2C *) WinUser.VK_SNAPSHOT =&gt; RETURN KeyboardKey.VoidSymbol;
      | (* 2D *) WinUser.VK_INSERT   =&gt; RETURN KeyboardKey.Insert;
      | (* 2E *) WinUser.VK_DELETE   =&gt; RETURN KeyboardKey.Delete;
      | (* 2F *) WinUser.VK_HELP     =&gt; RETURN KeyboardKey.Help;

      | 16_30 =&gt; RETURN Latin1Key.parenright;
      | 16_31 =&gt; RETURN Latin1Key.exclam;
      | 16_32 =&gt; RETURN Latin1Key.at;
      | 16_33 =&gt; RETURN Latin1Key.numbersign;
      | 16_34 =&gt; RETURN Latin1Key.dollar;
      | 16_35 =&gt; RETURN Latin1Key.percent;
      | 16_36 =&gt; RETURN Latin1Key.asciicircum;
      | 16_37 =&gt; RETURN Latin1Key.ampersand;
      | 16_38 =&gt; RETURN Latin1Key.asterisk;
      | 16_39 =&gt; RETURN Latin1Key.parenleft;

      | 16_41 =&gt; RETURN Latin1Key.A;
      | 16_42 =&gt; RETURN Latin1Key.B;
      | 16_43 =&gt; RETURN Latin1Key.C;
      | 16_44 =&gt; RETURN Latin1Key.D;
      | 16_45 =&gt; RETURN Latin1Key.E;
      | 16_46 =&gt; RETURN Latin1Key.F;
      | 16_47 =&gt; RETURN Latin1Key.G;
      | 16_48 =&gt; RETURN Latin1Key.H;
      | 16_49 =&gt; RETURN Latin1Key.I;
      | 16_4A =&gt; RETURN Latin1Key.J;
      | 16_4B =&gt; RETURN Latin1Key.K;
      | 16_4C =&gt; RETURN Latin1Key.L;
      | 16_4D =&gt; RETURN Latin1Key.M;
      | 16_4E =&gt; RETURN Latin1Key.N;
      | 16_4F =&gt; RETURN Latin1Key.O;
      | 16_50 =&gt; RETURN Latin1Key.P;
      | 16_51 =&gt; RETURN Latin1Key.Q;
      | 16_52 =&gt; RETURN Latin1Key.R;
      | 16_53 =&gt; RETURN Latin1Key.S;
      | 16_54 =&gt; RETURN Latin1Key.T;
      | 16_55 =&gt; RETURN Latin1Key.U;
      | 16_56 =&gt; RETURN Latin1Key.V;
      | 16_57 =&gt; RETURN Latin1Key.W;
      | 16_58 =&gt; RETURN Latin1Key.X;
      | 16_59 =&gt; RETURN Latin1Key.Y;
      | 16_5A =&gt; RETURN Latin1Key.Z;

      | (* 60 *) WinUser.VK_NUMPAD0   =&gt; RETURN KeyboardKey.KP_0;
      | (* 61 *) WinUser.VK_NUMPAD1   =&gt; RETURN KeyboardKey.KP_1;
      | (* 62 *) WinUser.VK_NUMPAD2   =&gt; RETURN KeyboardKey.KP_2;
      | (* 63 *) WinUser.VK_NUMPAD3   =&gt; RETURN KeyboardKey.KP_3;
      | (* 64 *) WinUser.VK_NUMPAD4   =&gt; RETURN KeyboardKey.KP_4;
      | (* 65 *) WinUser.VK_NUMPAD5   =&gt; RETURN KeyboardKey.KP_5;
      | (* 66 *) WinUser.VK_NUMPAD6   =&gt; RETURN KeyboardKey.KP_6;
      | (* 67 *) WinUser.VK_NUMPAD7   =&gt; RETURN KeyboardKey.KP_7;
      | (* 68 *) WinUser.VK_NUMPAD8   =&gt; RETURN KeyboardKey.KP_8;
      | (* 69 *) WinUser.VK_NUMPAD9   =&gt; RETURN KeyboardKey.KP_9;
      | (* 6A *) WinUser.VK_MULTIPLY  =&gt; RETURN KeyboardKey.KP_Multiply;
      | (* 6B *) WinUser.VK_ADD       =&gt; RETURN KeyboardKey.KP_Add;
      | (* 6C *) WinUser.VK_SEPARATOR =&gt; RETURN KeyboardKey.KP_Separator;
      | (* 6D *) WinUser.VK_SUBTRACT  =&gt; RETURN KeyboardKey.KP_Subtract;
      | (* 6E *) WinUser.VK_DECIMAL   =&gt; RETURN KeyboardKey.KP_Decimal;
      | (* 6F *) WinUser.VK_DIVIDE    =&gt; RETURN KeyboardKey.KP_Divide;

      | (* 70 *) WinUser.VK_F1        =&gt; RETURN KeyboardKey.F1;
      | (* 71 *) WinUser.VK_F2        =&gt; RETURN KeyboardKey.F2;
      | (* 72 *) WinUser.VK_F3        =&gt; RETURN KeyboardKey.F3;
      | (* 73 *) WinUser.VK_F4        =&gt; RETURN KeyboardKey.F4;
      | (* 74 *) WinUser.VK_F5        =&gt; RETURN KeyboardKey.F5;
      | (* 75 *) WinUser.VK_F6        =&gt; RETURN KeyboardKey.F6;
      | (* 76 *) WinUser.VK_F7        =&gt; RETURN KeyboardKey.F7;
      | (* 77 *) WinUser.VK_F8        =&gt; RETURN KeyboardKey.F8;
      | (* 78 *) WinUser.VK_F9        =&gt; RETURN KeyboardKey.F9;
      | (* 79 *) WinUser.VK_F10       =&gt; RETURN KeyboardKey.F10;
      | (* 7A *) WinUser.VK_F11       =&gt; RETURN KeyboardKey.F11;
      | (* 7B *) WinUser.VK_F12       =&gt; RETURN KeyboardKey.F12;
      | (* 7C *) WinUser.VK_F13       =&gt; RETURN KeyboardKey.F13;
      | (* 7D *) WinUser.VK_F14       =&gt; RETURN KeyboardKey.F14;
      | (* 7E *) WinUser.VK_F15       =&gt; RETURN KeyboardKey.F15;
      | (* 7F *) WinUser.VK_F16       =&gt; RETURN KeyboardKey.F16;
      | (* 80 *) WinUser.VK_F17       =&gt; RETURN KeyboardKey.F17;
      | (* 81 *) WinUser.VK_F18       =&gt; RETURN KeyboardKey.F18;
      | (* 82 *) WinUser.VK_F19       =&gt; RETURN KeyboardKey.F19;
      | (* 83 *) WinUser.VK_F20       =&gt; RETURN KeyboardKey.F20;
      | (* 84 *) WinUser.VK_F21       =&gt; RETURN KeyboardKey.F21;
      | (* 85 *) WinUser.VK_F22       =&gt; RETURN KeyboardKey.F22;
      | (* 86 *) WinUser.VK_F23       =&gt; RETURN KeyboardKey.F23;
      | (* 87 *) WinUser.VK_F24       =&gt; RETURN KeyboardKey.F24;

      | (* 90 *) WinUser.VK_NUMLOCK   =&gt; RETURN KeyboardKey.Num_Lock;
      | (* 91 *) WinUser.VK_SCROLL    =&gt; RETURN KeyboardKey.Scroll_Lock;

      | (* A0 *) WinUser.VK_LSHIFT    =&gt; RETURN KeyboardKey.Shift_L;
      | (* A1 *) WinUser.VK_RSHIFT    =&gt; RETURN KeyboardKey.Shift_R;
      | (* A2 *) WinUser.VK_LCONTROL  =&gt; RETURN KeyboardKey.Control_L;
      | (* A3 *) WinUser.VK_RCONTROL  =&gt; RETURN KeyboardKey.Control_R;
      | (* A4 *) WinUser.VK_LMENU     =&gt; RETURN KeyboardKey.Alt_L;
      | (* A5 *) WinUser.VK_RMENU     =&gt; RETURN KeyboardKey.Alt_R;

      (* The next few codes are device-specific ... *)

      | 16_BA =&gt; RETURN Latin1Key.colon;
      | 16_BB =&gt; RETURN Latin1Key.plus;
      | 16_BC =&gt; RETURN Latin1Key.less;
      | 16_BD =&gt; RETURN Latin1Key.underscore;
      | 16_BE =&gt; RETURN Latin1Key.greater;
      | 16_BF =&gt; RETURN Latin1Key.question;
      | 16_C0 =&gt; RETURN Latin1Key.asciitilde;
      | 16_DB =&gt; RETURN Latin1Key.braceleft;
      | 16_DC =&gt; RETURN Latin1Key.bar;
      | 16_DD =&gt; RETURN Latin1Key.braceright;
      | 16_DE =&gt; RETURN Latin1Key.quotedbl;

      | (* F6 *) WinUser.VK_ATTN      =&gt; RETURN KeyboardKey.VoidSymbol;
      | (* F7 *) WinUser.VK_CRSEL     =&gt; RETURN KeyboardKey.VoidSymbol;
      | (* F8 *) WinUser.VK_EXSEL     =&gt; RETURN KeyboardKey.VoidSymbol;
      | (* F9 *) WinUser.VK_EREOF     =&gt; RETURN KeyboardKey.VoidSymbol;
      | (* FA *) WinUser.VK_PLAY      =&gt; RETURN KeyboardKey.VoidSymbol;
      | (* FB *) WinUser.VK_ZOOM      =&gt; RETURN KeyboardKey.VoidSymbol;
      | (* FC *) WinUser.VK_NONAME    =&gt; RETURN KeyboardKey.VoidSymbol;
      | (* FD *) WinUser.VK_PA1       =&gt; RETURN KeyboardKey.VoidSymbol;
      | (* FE *) WinUser.VK_OEM_CLEAR =&gt; RETURN KeyboardKey.VoidSymbol;
      ELSE
        RETURN KeyboardKey.VoidSymbol;
      END;
    END;
  END VirtualKeyToKeySym;

&lt;*UNUSED*&gt;
PROCEDURE <A NAME="PrintMessageType"><procedure>PrintMessageType</procedure></A> (message: WinDef.UINT) =
  BEGIN
    IO.Put(&quot;message &quot; &amp; Fmt.Int(message) &amp; &quot; = &quot;);
    CASE message OF
    | WinUser.WM_NULL =&gt; IO.Put(&quot;WM_NULL&quot;);
    | WinUser.WM_CREATE =&gt; IO.Put(&quot;WM_CREATE&quot;);
    | WinUser.WM_DESTROY =&gt; IO.Put(&quot;WM_DESTROY&quot;);
    | WinUser.WM_MOVE =&gt; IO.Put(&quot;WM_MOVE&quot;);
    | WinUser.WM_SIZE =&gt; IO.Put(&quot;WM_SIZE&quot;);
    | WinUser.WM_ACTIVATE =&gt; IO.Put(&quot;WM_ACTIVATE&quot;);
    | WinUser.WM_SETFOCUS =&gt; IO.Put(&quot;WM_SETFOCUS&quot;);
    | WinUser.WM_KILLFOCUS =&gt; IO.Put(&quot;WM_KILLFOCUS&quot;);
    | WinUser.WM_ENABLE =&gt; IO.Put(&quot;WM_ENABLE&quot;);
    | WinUser.WM_SETREDRAW =&gt; IO.Put(&quot;WM_SETREDRAW&quot;);
    | WinUser.WM_SETTEXT =&gt; IO.Put(&quot;WM_SETTEXT&quot;);
    | WinUser.WM_GETTEXT =&gt; IO.Put(&quot;WM_GETTEXT&quot;);
    | WinUser.WM_GETTEXTLENGTH =&gt; IO.Put(&quot;WM_GETTEXTLENGTH&quot;);
    | WinUser.WM_PAINT =&gt; IO.Put(&quot;WM_PAINT&quot;);
    | WinUser.WM_CLOSE =&gt; IO.Put(&quot;WM_CLOSE&quot;);
    | WinUser.WM_QUERYENDSESSION =&gt; IO.Put(&quot;WM_QUERYENDSESSION&quot;);
    | WinUser.WM_QUIT =&gt; IO.Put(&quot;WM_QUIT&quot;);
    | WinUser.WM_QUERYOPEN =&gt; IO.Put(&quot;WM_QUERYOPEN&quot;);
    | WinUser.WM_ERASEBKGND =&gt; IO.Put(&quot;WM_ERASEBKGND&quot;);
    | WinUser.WM_SYSCOLORCHANGE =&gt; IO.Put(&quot;WM_SYSCOLORCHANGE&quot;);
    | WinUser.WM_ENDSESSION =&gt; IO.Put(&quot;WM_ENDSESSION&quot;);
    | WinUser.WM_SHOWWINDOW =&gt; IO.Put(&quot;WM_SHOWWINDOW&quot;);
    | WinUser.WM_WININICHANGE =&gt; IO.Put(&quot;WM_WININICHANGE&quot;);
    | WinUser.WM_DEVMODECHANGE =&gt; IO.Put(&quot;WM_DEVMODECHANGE&quot;);
    | WinUser.WM_ACTIVATEAPP =&gt; IO.Put(&quot;WM_ACTIVATEAPP&quot;);
    | WinUser.WM_FONTCHANGE =&gt; IO.Put(&quot;WM_FONTCHANGE&quot;);
    | WinUser.WM_TIMECHANGE =&gt; IO.Put(&quot;WM_TIMECHANGE&quot;);
    | WinUser.WM_CANCELMODE =&gt; IO.Put(&quot;WM_CANCELMODE&quot;);
    | WinUser.WM_SETCURSOR =&gt; IO.Put(&quot;WM_SETCURSOR&quot;);
    | WinUser.WM_MOUSEACTIVATE =&gt; IO.Put(&quot;WM_MOUSEACTIVATE&quot;);
    | WinUser.WM_CHILDACTIVATE =&gt; IO.Put(&quot;WM_CHILDACTIVATE&quot;);
    | WinUser.WM_QUEUESYNC =&gt; IO.Put(&quot;WM_QUEUESYNC&quot;);
    | WinUser.WM_GETMINMAXINFO =&gt; IO.Put(&quot;WM_GETMINMAXINFO&quot;);
    | WinUser.WM_PAINTICON =&gt; IO.Put(&quot;WM_PAINTICON&quot;);
    | WinUser.WM_ICONERASEBKGND =&gt; IO.Put(&quot;WM_ICONERASEBKGND&quot;);
    | WinUser.WM_NEXTDLGCTL =&gt; IO.Put(&quot;WM_NEXTDLGCTL&quot;);
    | WinUser.WM_SPOOLERSTATUS =&gt; IO.Put(&quot;WM_SPOOLERSTATUS&quot;);
    | WinUser.WM_DRAWITEM =&gt; IO.Put(&quot;WM_DRAWITEM&quot;);
    | WinUser.WM_MEASUREITEM =&gt; IO.Put(&quot;WM_MEASUREITEM&quot;);
    | WinUser.WM_DELETEITEM =&gt; IO.Put(&quot;WM_DELETEITEM&quot;);
    | WinUser.WM_VKEYTOITEM =&gt; IO.Put(&quot;WM_VKEYTOITEM&quot;);
    | WinUser.WM_CHARTOITEM =&gt; IO.Put(&quot;WM_CHARTOITEM&quot;);
    | WinUser.WM_SETFONT =&gt; IO.Put(&quot;WM_SETFONT&quot;);
    | WinUser.WM_GETFONT =&gt; IO.Put(&quot;WM_GETFONT&quot;);
    | WinUser.WM_SETHOTKEY =&gt; IO.Put(&quot;WM_SETHOTKEY&quot;);
    | WinUser.WM_GETHOTKEY =&gt; IO.Put(&quot;WM_GETHOTKEY&quot;);
    | WinUser.WM_QUERYDRAGICON =&gt; IO.Put(&quot;WM_QUERYDRAGICON&quot;);
    | WinUser.WM_COMPAREITEM =&gt; IO.Put(&quot;WM_COMPAREITEM&quot;);
    | WinUser.WM_FULLSCREEN =&gt; IO.Put(&quot;WM_FULLSCREEN&quot;);
    | WinUser.WM_COMPACTING =&gt; IO.Put(&quot;WM_COMPACTING&quot;);
    | WinUser.WM_OTHERWINDOWCREATED =&gt; IO.Put(&quot;WM_OTHERWINDOWCREATED&quot;);
    | WinUser.WM_OTHERWINDOWDESTROYED =&gt; IO.Put(&quot;WM_OTHERWINDOWDESTROYED&quot;);
    | WinUser.WM_COMMNOTIFY =&gt; IO.Put(&quot;WM_COMMNOTIFY&quot;);
    | WinUser.WM_HOTKEYEVENT =&gt; IO.Put(&quot;WM_HOTKEYEVENT&quot;);
    | WinUser.WM_WINDOWPOSCHANGING =&gt; IO.Put(&quot;WM_WINDOWPOSCHANGING&quot;);
    | WinUser.WM_WINDOWPOSCHANGED =&gt; IO.Put(&quot;WM_WINDOWPOSCHANGED&quot;);
    | WinUser.WM_POWER =&gt; IO.Put(&quot;WM_POWER&quot;);
    | WinUser.WM_COPYDATA =&gt; IO.Put(&quot;WM_COPYDATA&quot;);
    | WinUser.WM_NCCREATE =&gt; IO.Put(&quot;WM_NCCREATE&quot;);
    | WinUser.WM_NCDESTROY =&gt; IO.Put(&quot;WM_NCDESTROY&quot;);
    | WinUser.WM_NCCALCSIZE =&gt; IO.Put(&quot;WM_NCCALCSIZE&quot;);
    | WinUser.WM_NCHITTEST =&gt; IO.Put(&quot;WM_NCHITTEST&quot;);
    | WinUser.WM_NCPAINT =&gt; IO.Put(&quot;WM_NCPAINT&quot;);
    | WinUser.WM_NCACTIVATE =&gt; IO.Put(&quot;WM_NCACTIVATE&quot;);
    | WinUser.WM_GETDLGCODE =&gt; IO.Put(&quot;WM_GETDLGCODE&quot;);
    | WinUser.WM_NCMOUSEMOVE =&gt; IO.Put(&quot;WM_NCMOUSEMOVE&quot;);
    | WinUser.WM_NCLBUTTONDOWN =&gt; IO.Put(&quot;WM_NCLBUTTONDOWN&quot;);
    | WinUser.WM_NCLBUTTONUP =&gt; IO.Put(&quot;WM_NCLBUTTONUP&quot;);
    | WinUser.WM_NCLBUTTONDBLCLK =&gt; IO.Put(&quot;WM_NCLBUTTONDBLCLK&quot;);
    | WinUser.WM_NCRBUTTONDOWN =&gt; IO.Put(&quot;WM_NCRBUTTONDOWN&quot;);
    | WinUser.WM_NCRBUTTONUP =&gt; IO.Put(&quot;WM_NCRBUTTONUP&quot;);
    | WinUser.WM_NCRBUTTONDBLCLK =&gt; IO.Put(&quot;WM_NCRBUTTONDBLCLK&quot;);
    | WinUser.WM_NCMBUTTONDOWN =&gt; IO.Put(&quot;WM_NCMBUTTONDOWN&quot;);
    | WinUser.WM_NCMBUTTONUP =&gt; IO.Put(&quot;WM_NCMBUTTONUP&quot;);
    | WinUser.WM_NCMBUTTONDBLCLK =&gt; IO.Put(&quot;WM_NCMBUTTONDBLCLK&quot;);
    | WinUser.WM_KEYDOWN =&gt; IO.Put(&quot;WM_KEYDOWN (aka WM_KEYFIRST)&quot;);
    | WinUser.WM_KEYUP =&gt; IO.Put(&quot;WM_KEYUP&quot;);
    | WinUser.WM_CHAR =&gt; IO.Put(&quot;WM_CHAR&quot;);
    | WinUser.WM_DEADCHAR =&gt; IO.Put(&quot;WM_DEADCHAR&quot;);
    | WinUser.WM_SYSKEYDOWN =&gt; IO.Put(&quot;WM_SYSKEYDOWN&quot;);
    | WinUser.WM_SYSKEYUP =&gt; IO.Put(&quot;WM_SYSKEYUP&quot;);
    | WinUser.WM_SYSCHAR =&gt; IO.Put(&quot;WM_SYSCHAR&quot;);
    | WinUser.WM_SYSDEADCHAR =&gt; IO.Put(&quot;WM_SYSDEADCHAR&quot;);
    | WinUser.WM_KEYLAST =&gt; IO.Put(&quot;WM_KEYLAST&quot;);
    | WinUser.WM_INITDIALOG =&gt; IO.Put(&quot;WM_INITDIALOG&quot;);
    | WinUser.WM_COMMAND =&gt; IO.Put(&quot;WM_COMMAND&quot;);
    | WinUser.WM_SYSCOMMAND =&gt; IO.Put(&quot;WM_SYSCOMMAND&quot;);
    | WinUser.WM_TIMER =&gt; IO.Put(&quot;WM_TIMER&quot;);
    | WinUser.WM_HSCROLL =&gt; IO.Put(&quot;WM_HSCROLL&quot;);
    | WinUser.WM_VSCROLL =&gt; IO.Put(&quot;WM_VSCROLL&quot;);
    | WinUser.WM_INITMENU =&gt; IO.Put(&quot;WM_INITMENU&quot;);
    | WinUser.WM_INITMENUPOPUP =&gt; IO.Put(&quot;WM_INITMENUPOPUP&quot;);
    | WinUser.WM_MENUSELECT =&gt; IO.Put(&quot;WM_MENUSELECT&quot;);
    | WinUser.WM_MENUCHAR =&gt; IO.Put(&quot;WM_MENUCHAR&quot;);
    | WinUser.WM_ENTERIDLE =&gt; IO.Put(&quot;WM_ENTERIDLE&quot;);
    | WinUser.WM_CTLCOLORMSGBOX =&gt; IO.Put(&quot;WM_CTLCOLORMSGBOX&quot;);
    | WinUser.WM_CTLCOLOREDIT =&gt; IO.Put(&quot;WM_CTLCOLOREDIT&quot;);
    | WinUser.WM_CTLCOLORLISTBOX =&gt; IO.Put(&quot;WM_CTLCOLORLISTBOX&quot;);
    | WinUser.WM_CTLCOLORBTN =&gt; IO.Put(&quot;WM_CTLCOLORBTN&quot;);
    | WinUser.WM_CTLCOLORDLG =&gt; IO.Put(&quot;WM_CTLCOLORDLG&quot;);
    | WinUser.WM_CTLCOLORSCROLLBAR =&gt; IO.Put(&quot;WM_CTLCOLORSCROLLBAR&quot;);
    | WinUser.WM_CTLCOLORSTATIC =&gt; IO.Put(&quot;WM_CTLCOLORSTATIC&quot;);
    | WinUser.WM_MOUSEMOVE =&gt; IO.Put(&quot;WM_MOUSEMOVE (aka WM_MOUSEFIRST)&quot;);
    | WinUser.WM_LBUTTONDOWN =&gt; IO.Put(&quot;WM_LBUTTONDOWN&quot;);
    | WinUser.WM_LBUTTONUP =&gt; IO.Put(&quot;WM_LBUTTONUP&quot;);
    | WinUser.WM_LBUTTONDBLCLK =&gt; IO.Put(&quot;WM_LBUTTONDBLCLK&quot;);
    | WinUser.WM_RBUTTONDOWN =&gt; IO.Put(&quot;WM_RBUTTONDOWN&quot;);
    | WinUser.WM_RBUTTONUP =&gt; IO.Put(&quot;WM_RBUTTONUP&quot;);
    | WinUser.WM_RBUTTONDBLCLK =&gt; IO.Put(&quot;WM_RBUTTONDBLCLK&quot;);
    | WinUser.WM_MBUTTONDOWN =&gt; IO.Put(&quot;WM_MBUTTONDOWN&quot;);
    | WinUser.WM_MBUTTONUP =&gt; IO.Put(&quot;WM_MBUTTONUP&quot;);
    | WinUser.WM_MBUTTONDBLCLK =&gt; IO.Put(&quot;WM_MBUTTONDBLCLK (aka MOUSELAST)&quot;);
    | WinUser.WM_PARENTNOTIFY =&gt; IO.Put(&quot;WM_PARENTNOTIFY&quot;);
    | WinUser.WM_ENTERMENULOOP =&gt; IO.Put(&quot;WM_ENTERMENULOOP&quot;);
    | WinUser.WM_EXITMENULOOP =&gt; IO.Put(&quot;WM_EXITMENULOOP&quot;);
    | WinUser.WM_MDICREATE =&gt; IO.Put(&quot;WM_MDICREATE&quot;);
    | WinUser.WM_MDIDESTROY =&gt; IO.Put(&quot;WM_MDIDESTROY&quot;);
    | WinUser.WM_MDIACTIVATE =&gt; IO.Put(&quot;WM_MDIACTIVATE&quot;);
    | WinUser.WM_MDIRESTORE =&gt; IO.Put(&quot;WM_MDIRESTORE&quot;);
    | WinUser.WM_MDINEXT =&gt; IO.Put(&quot;WM_MDINEXT&quot;);
    | WinUser.WM_MDIMAXIMIZE =&gt; IO.Put(&quot;WM_MDIMAXIMIZE&quot;);
    | WinUser.WM_MDITILE =&gt; IO.Put(&quot;WM_MDITILE&quot;);
    | WinUser.WM_MDICASCADE =&gt; IO.Put(&quot;WM_MDICASCADE&quot;);
    | WinUser.WM_MDIICONARRANGE =&gt; IO.Put(&quot;WM_MDIICONARRANGE&quot;);
    | WinUser.WM_MDIGETACTIVE =&gt; IO.Put(&quot;WM_MDIGETACTIVE&quot;);
    | WinUser.WM_MDISETMENU =&gt; IO.Put(&quot;WM_MDISETMENU&quot;);
    | WinUser.WM_ENTERSIZEMOVE_UNDOCUMENTED =&gt; IO.Put(&quot;WM_ENTERSIZEMOVE_UNDOCUMENTED&quot;);
    | WinUser.WM_EXITSIZEMOVE_UNDOCUMENTED =&gt; IO.Put(&quot;WM_EXITSIZEMOVE_UNDOCUMENTED&quot;);
    | WinUser.WM_DROPFILES =&gt; IO.Put(&quot;WM_DROPFILES&quot;);
    | WinUser.WM_MDIREFRESHMENU =&gt; IO.Put(&quot;WM_MDIREFRESHMENU&quot;);
    | WinUser.WM_CUT =&gt; IO.Put(&quot;WM_CUT&quot;);
    | WinUser.WM_COPY =&gt; IO.Put(&quot;WM_COPY&quot;);
    | WinUser.WM_PASTE =&gt; IO.Put(&quot;WM_PASTE&quot;);
    | WinUser.WM_CLEAR =&gt; IO.Put(&quot;WM_CLEAR&quot;);
    | WinUser.WM_UNDO =&gt; IO.Put(&quot;WM_UNDO&quot;);
    | WinUser.WM_RENDERFORMAT =&gt; IO.Put(&quot;WM_RENDERFORMAT&quot;);
    | WinUser.WM_RENDERALLFORMATS =&gt; IO.Put(&quot;WM_RENDERALLFORMATS&quot;);
    | WinUser.WM_DESTROYCLIPBOARD =&gt; IO.Put(&quot;WM_DESTROYCLIPBOARD&quot;);
    | WinUser.WM_DRAWCLIPBOARD =&gt; IO.Put(&quot;WM_DRAWCLIPBOARD&quot;);
    | WinUser.WM_PAINTCLIPBOARD =&gt; IO.Put(&quot;WM_PAINTCLIPBOARD&quot;);
    | WinUser.WM_VSCROLLCLIPBOARD =&gt; IO.Put(&quot;WM_VSCROLLCLIPBOARD&quot;);
    | WinUser.WM_SIZECLIPBOARD =&gt; IO.Put(&quot;WM_SIZECLIPBOARD&quot;);
    | WinUser.WM_ASKCBFORMATNAME =&gt; IO.Put(&quot;WM_ASKCBFORMATNAME&quot;);
    | WinUser.WM_CHANGECBCHAIN =&gt; IO.Put(&quot;WM_CHANGECBCHAIN&quot;);
    | WinUser.WM_HSCROLLCLIPBOARD =&gt; IO.Put(&quot;WM_HSCROLLCLIPBOARD&quot;);
    | WinUser.WM_QUERYNEWPALETTE =&gt; IO.Put(&quot;WM_QUERYNEWPALETTE&quot;);
    | WinUser.WM_PALETTEISCHANGING =&gt; IO.Put(&quot;WM_PALETTEISCHANGING&quot;);
    | WinUser.WM_PALETTECHANGED =&gt; IO.Put(&quot;WM_PALETTECHANGED&quot;);
    | WinUser.WM_HOTKEY =&gt; IO.Put(&quot;WM_HOTKEY&quot;);
    | WinUser.WM_PENWINFIRST =&gt; IO.Put(&quot;WM_PENWINFIRST&quot;);
    | WinUser.WM_PENWINLAST =&gt; IO.Put(&quot;WM_PENWINLAST&quot;);
    | WinUser.WM_MM_RESERVED_FIRST =&gt; IO.Put(&quot;WM_MM_RESERVED_FIRST&quot;);
    | WinUser.WM_MM_RESERVED_LAST =&gt; IO.Put(&quot;WM_MM_RESERVED_LAST&quot;);
    | WinUser.WM_USER =&gt; IO.Put(&quot;WM_USER&quot;);
    ELSE
      IO.Put(&quot;&lt;not in my incomplete table&gt;&quot;);
    END;
    IO.Put(&quot;\n&quot;);
  END PrintMessageType;
</PRE>***************************************************************************
 The event queue data structure. I chose a sentinel-based implementation.  
***************************************************************************

<P> The following invariant is maintained:             
 *  &lt;* ASSERT self.front # NIL AND self.end # NIL 
 *        AND self.end.head = NIL AND self.end.tail = NIL *&gt;
 

<P><PRE>TYPE
  EventList = REF RECORD
    head: Event;
    tail: EventList;
  END;

  EventQueue = MUTEX OBJECT
    front: EventList := NIL;  (* dequeue at front *)
    end  : EventList := NIL;  (* enqueue at end *)
  METHODS
    init (): EventQueue  := InitEQ;
    put (e: Event)       := PutEQ;
    drain (base: T)      := DrainEQ;
  END;

PROCEDURE <A NAME="InitEQ"><procedure>InitEQ</procedure></A> (self: EventQueue): EventQueue =
  BEGIN
    (* Enter sentinel element *)
    self.front := NEW (EventList, head := NIL, tail := NIL);
    self.end := self.front;
    &lt;* ASSERT self.front # NIL AND self.end # NIL
          AND self.end.head = NIL AND self.end.tail = NIL *&gt;
    RETURN self;
  END InitEQ;

PROCEDURE <A NAME="PutEQ"><procedure>PutEQ</procedure></A> (self: EventQueue; e: Event) =
  BEGIN
    LOCK self DO
      &lt;* ASSERT self.front # NIL AND self.end # NIL
            AND self.end.head = NIL AND self.end.tail = NIL *&gt;
      self.end.head := e;
      self.end.tail := NEW (EventList, head := NIL, tail := NIL);
      self.end := self.end.tail;
      &lt;* ASSERT self.front # NIL AND self.end # NIL
            AND self.end.head = NIL AND self.end.tail = NIL *&gt;
    END;
  END PutEQ;

PROCEDURE <A NAME="DrainEQ"><procedure>DrainEQ</procedure></A> (self: EventQueue; base: T) =
  BEGIN
    LOCK self DO
      &lt;* ASSERT self.front # NIL AND self.end # NIL
            AND self.end.head = NIL AND self.end.tail = NIL *&gt;
      WHILE self.front # self.end DO
        self.front.head.process (base);
        self.front := self.front.tail;
      END;
      &lt;* ASSERT self.front # NIL AND self.end # NIL
            AND self.end.head = NIL AND self.end.tail = NIL *&gt;
    END;
  END DrainEQ;
</PRE>***************************************************************************
 Event types                                                               
***************************************************************************

<P><PRE>TYPE
  Event = OBJECT
  METHODS
    process (base: T);
  END;

TYPE
  MotionEvent = Event BRANDED OBJECT
    pos: Point.T;
  OVERRIDES
    process := ProcessMotion;
  END;

PROCEDURE <A NAME="ProcessMotion"><procedure>ProcessMotion</procedure></A> (self: MotionEvent; base: T) =
  BEGIN
    WITH posrec = PositionCB.Rec {pos2D := self.pos,
                                  modifiers := base.modifiers} DO
      base.root.invokePositionCB (posrec);
    END;
  END ProcessMotion;

TYPE
  ButtonUpEvent = Event BRANDED OBJECT
    pos   : Point.T;
    button: VBT.Button;
  OVERRIDES
    process := ProcessButtonUp;
  END;

PROCEDURE <A NAME="ProcessButtonUp"><procedure>ProcessButtonUp</procedure></A> (self: ButtonUpEvent; base: T) =
  VAR
    clickType : VBT.ClickType;
  BEGIN
    DEC (base.buttonDownCount);
    IF base.buttonDownCount = 0 THEN
      clickType := VBT.ClickType.LastUp;
    ELSE
      clickType := VBT.ClickType.OtherUp;
    END;
    WITH mouserec = MouseCB.Rec {pos2D       := self.pos,
                                 whatChanged := self.button,
                                 modifiers   := base.modifiers,
                                 clickType   := clickType} DO
      base.root.invokeMouseCB (mouserec);
      base.modifiers := base.modifiers - VBT.Modifiers {self.button};
    END;
  END ProcessButtonUp;

TYPE
  ButtonDownEvent = Event BRANDED OBJECT
    pos   : Point.T;
    button: VBT.Button;
  OVERRIDES
    process := ProcessButtonDown;
  END;

PROCEDURE <A NAME="ProcessButtonDown"><procedure>ProcessButtonDown</procedure></A> (self: ButtonDownEvent; base: T) =
  VAR
    clickType : VBT.ClickType;
  BEGIN
    IF base.buttonDownCount = 0 THEN
      clickType := VBT.ClickType.FirstDown;
    ELSE
      clickType := VBT.ClickType.OtherDown;
    END;
    INC (base.buttonDownCount);
    WITH mouserec = MouseCB.Rec {pos2D       := self.pos,
                                 whatChanged := self.button,
                                 modifiers   := base.modifiers,
                                 clickType   := clickType} DO
      base.root.invokeMouseCB (mouserec);
      base.modifiers := base.modifiers + VBT.Modifiers {self.button};
    END;
  END ProcessButtonDown;

TYPE
  KeyEvent = Event BRANDED OBJECT
    key : VBT.KeySym;
    down: BOOLEAN;
  OVERRIDES
    process := ProcessKey;
  END;

PROCEDURE <A NAME="ProcessKey"><procedure>ProcessKey</procedure></A> (self: KeyEvent; base: T) =

  PROCEDURE KeySymToModifierSet (keysym : VBT.KeySym) : VBT.Modifiers =
    BEGIN
      CASE keysym OF
      | KeyboardKey.Shift_L, KeyboardKey.Shift_R =&gt;
        RETURN VBT.Modifiers {VBT.Modifier.Shift};
      | KeyboardKey.Shift_Lock =&gt;
        RETURN VBT.Modifiers {VBT.Modifier.Lock};
      | KeyboardKey.Control_L, KeyboardKey.Control_R =&gt;
        RETURN VBT.Modifiers {VBT.Modifier.Control};
      | KeyboardKey.Meta_L, KeyboardKey.Meta_R =&gt;
        RETURN VBT.Modifiers {VBT.Modifier.Option};
      ELSE
        RETURN VBT.Modifiers {};
      END;
    END KeySymToModifierSet;

  BEGIN
    WITH keyrec = KeyCB.Rec {whatChanged := self.key,
                             wentDown    := self.down,
                             modifiers   := base.modifiers} DO
      base.root.invokeKeyCB (keyrec);
      IF self.down THEN
        base.modifiers := base.modifiers + KeySymToModifierSet (self.key);
      ELSE
        base.modifiers := base.modifiers - KeySymToModifierSet (self.key);
      END;
    END;
  END ProcessKey;

TYPE
  ExposeEvent = Event BRANDED OBJECT
  OVERRIDES
    process := ProcessExpose;
  END;

PROCEDURE <A NAME="ProcessExpose"><procedure>ProcessExpose</procedure></A> (&lt;*UNUSED*&gt; self: ExposeEvent; base: T) =
  BEGIN
    (*** damage the root object to force a redraw ***)
    IF base.root # NIL THEN
      base.root.damaged := TRUE;
    END;
  END ProcessExpose;

TYPE
  ReshapeEvent = Event BRANDED OBJECT
    width, height: INTEGER;
  OVERRIDES
    process := ProcessReshape;
  END;

PROCEDURE <A NAME="ProcessReshape"><procedure>ProcessReshape</procedure></A> (self: ReshapeEvent; base: T) =
  BEGIN
    base.winWidth  := self.width;
    base.winHeight := self.height;
    GL.glViewport (0, 0, self.width, self.height);  (* adjust the viewport *)

    (*** damage the root object to force a redraw ***)
    IF base.root # NIL THEN
      base.root.damaged := TRUE;
    END;
  END ProcessReshape;

TYPE
  DestroyEvent = Event BRANDED OBJECT
  OVERRIDES
    process := ProcessDestroy;
  END;

PROCEDURE <A NAME="ProcessDestroy"><procedure>ProcessDestroy</procedure></A> (&lt;*UNUSED*&gt; self: DestroyEvent; base: T) =
  BEGIN
    base.destroy ();
  END ProcessDestroy;
</PRE>***************************************************************************
 Animation Server                                                          
***************************************************************************

<P>
<P><PRE>PROCEDURE <A NAME="Setup"><procedure>Setup</procedure></A> (self: T) =
  BEGIN
    &lt;* ASSERT AnimServer.IsServer() *&gt;
    WITH status = WinGDI.wglMakeCurrent (self.hdc, self.hglrc) DO
      &lt;* ASSERT status = True *&gt;
    END;

    (*** Clear the color and the depth buffer ***)
    GL.glClear (Word.Or (GL.GL_COLOR_BUFFER_BIT, GL.GL_DEPTH_BUFFER_BIT));
  END Setup;

PROCEDURE <A NAME="Repair"><procedure>Repair</procedure></A> (self : T; VAR damaged : BOOLEAN) =
  VAR
    status : WinDef.BOOL;
  BEGIN
    (*** Redraw the scene only if there is one and it was damaged ***)
    IF self.root # NIL AND self.root.damaged THEN
      damaged := TRUE;

      LOCK conn DO
        (*** first, make sure that all resources have been created ***)
        IF self.hwnd = NIL THEN
          EVAL Thread.Fork (NEW (Closure, base := self));
          Thread.Wait (conn, self.windowThreadCV);
        END;

        (*** determine the object's current transparency ***)
        self.transflag := self.root.needsTransparency(0.0);
                                   (* 0.0 is the default transmission coeff *)

        (*** set up the rendering pipeline for a new round ***)
        Setup (self);

        (*** reset the bounding volume and the light state ***)
        self.resetBoundingVolume();

        (*** switch off all GL lights ***)
        FOR i := 0 TO GL.GL_MAX_LIGHTS - 1 DO
          GL.glDisable (GL.GL_LIGHT0 + i);
        END;

        (*** reset &quot;self.lightCount&quot; and &quot;self.ambientLight&quot; ***)
        self.lightCount   := 0;
        self.ambientLight := GLrgba {0.0, 0.0, 0.0, 1.0};

        (*** Put all light sources into a display list. As a side effect,
             determine the relevant parameters of the current camera. ***)
        GL.glNewList (self.lightList, GL.GL_COMPILE);
        self.phase := 1;
        self.root.draw (self);
        GL.glEndList ();

        (*** Now set up the camera ***)
        SetupCamera (self);

        (*** Switch on the light sources by executing the display list ***)
        GL.glLightModelfv (GL.GL_LIGHT_MODEL_AMBIENT, ADR (self.ambientLight));
        GL.glCallList (self.lightList);

        (*** Then draw everything else ***)
        self.phase := 2;
        self.root.draw (self);

        (*** Finally, swap the buffers to update the display ***)
        status := WinGDI.SwapBuffers (self.hdc);
        &lt;* ASSERT status = True *&gt;
      END;
    END;
  END Repair;
</PRE>***************************************************************************
 Connection Management                                                     
***************************************************************************

<P>
<P><PRE>VAR conn := NEW (Connection).init ();

TYPE
  Connection = MUTEX OBJECT       (* mutex protects fields *)
    currBase        : T;
    hwndMap         : IntRefTbl.T;
    hInst           : WinDef.HINSTANCE;
    windowclassName : Ctypes.char_star;
    nonclient       : Point.T;
  METHODS
    init (): Connection := InitConnection;
  END;

PROCEDURE <A NAME="InitConnection"><procedure>InitConnection</procedure></A> (self : Connection) : Connection =
  VAR
    wc    : WinUser.WNDCLASS;
    status: WinDef.BOOL;
  BEGIN
    (* Initialize the various fields of &quot;self&quot; *)
    self.currBase := NIL;
    self.hwndMap := NEW (IntRefTbl.Default).init ();
    self.hInst := RTLinker.info.instance;
    self.windowclassName := M3toC.CopyTtoS(&quot;Anim3D Window&quot;);
    self.nonclient.h := 2 * WinUser.GetSystemMetrics (WinUser.SM_CXFRAME);
    self.nonclient.v := 2 * WinUser.GetSystemMetrics (WinUser.SM_CYFRAME) +
                        WinUser.GetSystemMetrics (WinUser.SM_CYSCREEN) -
                        WinUser.GetSystemMetrics (WinUser.SM_CYFULLSCREEN) - 1;

    (* Register the window class *)
    wc.style := WinUser.CS_HREDRAW + WinUser.CS_VREDRAW + WinUser.CS_OWNDC;
    wc.lpfnWndProc := WindowProc;
    wc.cbClsExtra := 0;
    wc.cbWndExtra := 0;
    wc.hInstance := self.hInst;
    wc.hIcon := WinUser.LoadIcon (NIL, WinUser.IDI_APPLICATION);
    wc.hCursor := WinUser.LoadCursor (NIL, WinUser.IDC_ARROW);
    wc.hbrBackground := NIL;
    wc.lpszMenuName := NIL;
    wc.lpszClassName := self.windowclassName;

    status := WinUser.RegisterClass (ADR (wc));
    &lt;* ASSERT status # 0 *&gt;

    RETURN self;
  END InitConnection;

BEGIN
END Win_OpenGL_Base.
</PRE>
</inModule>
<HR>
<A NAME="x1">interface Math is in:
</A><UL>
<LI><A HREF="../../../arith/src/POSIX/Math.i3.html#0TOP0">arith/src/POSIX/Math.i3</A>
<LI><A HREF="../../../arith/src/WIN32/Math.i3.html#0TOP0">arith/src/WIN32/Math.i3</A>
</UL>
<P>
<PRE>























</PRE>
</BODY>
</HTML>
