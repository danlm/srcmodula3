<HTML>
<HEAD>
<TITLE>SRC Modula-3: anim3D/src/Matrix4.i3</TITLE>
</HEAD>
<BODY>
<A NAME="0TOP0">
<H2>anim3D/src/Matrix4.i3</H2></A><HR>
<inInterface>
<PRE><A HREF="../../COPYRIGHT.html">Copyright (C) 1994, Digital Equipment Corp.</A>
</PRE><BLOCKQUOTE><EM> Digital Internal Use Only                                                 </EM></BLOCKQUOTE><PRE>
</PRE>                                                                           
       Created on Wed Mar 16 21:47:10 PST 1994 by najork                   

<P>
<P><PRE>INTERFACE <interface>Matrix4</interface>;

IMPORT <A HREF="Point3.i3.html">Point3</A>;

TYPE T   = ARRAY [0 .. 3] OF Row;
     Row = ARRAY [0 .. 3] OF REAL;

CONST Id = T {Row {1.0, 0.0, 0.0, 0.0},
              Row {0.0, 1.0, 0.0, 0.0},
              Row {0.0, 0.0, 1.0, 0.0},
              Row {0.0, 0.0, 0.0, 1.0}};

PROCEDURE Multiply (READONLY M, N : T) : T;

PROCEDURE Identity () : T;
PROCEDURE Translate (READONLY M : T; x, y, z : REAL) : T;
PROCEDURE Scale (READONLY M : T; x, y, z : REAL) : T;
PROCEDURE RotateX (READONLY M : T; theta : REAL) : T;
PROCEDURE RotateY (READONLY M : T; theta : REAL) : T;
PROCEDURE RotateZ (READONLY M : T; theta : REAL) : T;
PROCEDURE TransformPoint3 (READONLY M : T; READONLY p : Point3.T) : Point3.T;

PROCEDURE TransformUnitCube (p, a, b, c : Point3.T) : T;
</PRE> This function is useful to map prototypes of geometric objects
   (circles, spheres, disks, cylinders, etc) onto actual instances.
   <CODE>TransformUnitCube(p,a,b,c)</CODE> returns a matrix <CODE>M</CODE>, such that
\begin{verbatim}
   TransformPoint3(M,Point3.T{0.0,0.0,0.0}) = p
   TransformPoint3(M,Point3.T{1.0,0.0,0.0}) = a
   TransformPoint3(M,Point3.T{0.0,1.0,0.0}) = b
   TransformPoint3(M,Point3.T{0.0,0.0,1.0}) = c
\end{verbatim}
<P>
   The above 4 equations over points define a system of linear equations, 
   which can be solved statically (i.e.\ no gaussian elimination is needed 
   at run time). So, calls to <CODE>TransformUnitCube</CODE> are very cheap.


<P><PRE>PROCEDURE UnitSphereMaxSquishFactor (READONLY M : T) : REAL;

EXCEPTION Error;

PROCEDURE Decomp (M : T; VAR tx, ty, tz, s : REAL) : T RAISES {Error};
</PRE><BLOCKQUOTE><EM> <CODE>Decompose(M,tx,ty,tz,s,angX,angY,angZ)</CODE> takes a matrix <CODE>M</CODE>, which must 
   have been constructed by using only translations, rotations, and uniform(!)
   scalings, and returns values <CODE>tx</CODE>, <CODE>ty</CODE>, <CODE>tz</CODE>, <CODE>s</CODE>, and <CODE>R</CODE> such that 
   <CODE>M = T(tx,ty,tz) S(s) R</CODE> holds. If the initial matrix <CODE>M</CODE> was indeed 
   valid, then <CODE>R</CODE> is an orthogonal matrix. If <CODE>M</CODE> was not valid, then
   <CODE>Error</CODE> is raised. </EM></BLOCKQUOTE><PRE>

PROCEDURE Transpose (READONLY M : T) : T;
</PRE><BLOCKQUOTE><EM> <CODE>Transpose(M)</CODE> takes a matrix <CODE>M</CODE> and returns its transpose. Note that 
   for an orthonormal matrix, its transpose is also its inverse. </EM></BLOCKQUOTE><PRE>

PROCEDURE Invert (A : T) : T RAISES {Error};
</PRE><BLOCKQUOTE><EM> <CODE>Invert(M)</CODE> takes a matrix M and returns its inverse.  If M is singular,
   the exception <CODE>Error</CODE> is raised. </EM></BLOCKQUOTE><PRE>

PROCEDURE Equal (READONLY A, B : T) : BOOLEAN;

PROCEDURE Orthonormal (READONLY M : T) : BOOLEAN;
</PRE><BLOCKQUOTE><EM> <CODE>Orthonormal(M)</CODE> is true if the columns of <CODE>M</CODE> form an orthonormal basis. </EM></BLOCKQUOTE><PRE>

PROCEDURE OrthoProjMatrix (height, aspect, near, far: REAL): T;
</PRE><BLOCKQUOTE><EM> This procedure returns what PEX calls a <CODE>view mapping matrix</CODE>, and what
   OpenGL calls a <CODE>projection transformation matrix</CODE>. The projection is
   orthographic. </EM></BLOCKQUOTE><PRE>

PROCEDURE PerspProjMatrix (fovy, distance, aspect, near, far: REAL): T;
</PRE><BLOCKQUOTE><EM> Returns a projection matrix for a perspective projection. </EM></BLOCKQUOTE><PRE>

PROCEDURE LookatViewMatrix (from, to, up: Point3.T): T;
</PRE><BLOCKQUOTE><EM> Returns a viewing transformation matrix.  We place three 
   (pretty reasonable) restrictions on the arguments:
     (1) <CODE>from</CODE> differs from <CODE>to</CODE>
     (2) <CODE>up</CODE> is non-zero
     (3) <CODE>(from - to)</CODE> and <CODE>up</CODE> are not collinear
<P>
   <CODE>LookatViewMatrix</CODE> is similar to Digital PEXlib's <CODE>PEXLookatViewMatrix</CODE> 
   function and to OpenGL's <CODE>gluLookAt</CODE> function. </EM></BLOCKQUOTE><PRE>

END Matrix4.
</PRE>
</inInterface>
<PRE>























</PRE>
</BODY>
</HTML>
