(* Copyright 1992 Digital Equipment Corporation.               *)
(* Distributed only by permission.                             *)
(* Send.m3 *)
(* Last modified on Tue Mar  8 13:47:10 PST 1994 by wobber  *)
(*      modified on Fri Jul  3  7:40:52 GMT+2:00 1992 by prusker *)

MODULE Send;

IMPORT Text, TextList, RefList, Wr, NetPath, LockOps, Thread, Time, PackageObj,
    TextWr, Site, Siphon, Fmt, Subrepo, NetObj, Param,
    PackageLib, PSLib, PkgErr, Util, FmtTime;

FROM LockOps IMPORT SiteName, Version;
FROM PackageObj IMPORT PN;
FROM Siphon IMPORT SiteList;

TYPE
  Route = RECORD first, final: SiteName; END;

  Queue = Thread.Closure OBJECT
    site: SiteName;
    thread: Thread.T := NIL;
    head: QueueElem := NIL;
    sending: BOOLEAN := FALSE;
    aborted: BOOLEAN := FALSE;
    startTime: Time.T;
    linkStatus: PkgErr.TL := NIL;
    linkStatusChange: Time.T;
  OVERRIDES
    apply := Sender;
  END;

  QueueElem = REF RECORD
    next: QueueElem := NIL;
    package: PN;
    version: Version;
    managedBy: SiteName;
    fwd: SiteList;
    deferred: BOOLEAN := FALSE;
    try: CARDINAL := 0;
    time: Time.T;
  END;

VAR
  mutex: MUTEX := NEW(MUTEX);
  queueList: RefList.T := NIL  (* of Queue *);

(* exports to Send.i3 *)

PROCEDURE Enqueue(
    package: PN;
    version: Version;
    manager: SiteName;
    forSite: SiteName;
    urgent := FALSE) RAISES {PkgErr.E} =
  VAR
    remotes: REF ARRAY OF Site.Remote;
    route: Route;
    where: TEXT;
  BEGIN
    IF forSite = NIL THEN where := "all"; ELSE where := forSite; END;
    Util.LogText(Fmt.F("Send.EnQ of %s(%s) to %s\n",
            PSLib.PkgText(package), Fmt.Int(version.vn), where));
    IF forSite # NIL THEN
      EVAL ComputeRoute(
         package, CheckSite("Send.EnQ", forSite), FALSE, route);
      EnqueueIt(route, package, version, manager, urgent);
    ELSE
      remotes := Site.Get().foreignSites;
      FOR i := 0 TO LAST(remotes^) DO
        IF ComputeRoute(package, remotes[i], TRUE, route) THEN
          EnqueueIt(route, package, version, manager, urgent);
        END;
      END;
    END;
  END Enqueue;

PROCEDURE Dequeue(
    package: PN;
    forSite: SiteName;
    interruptSend: BOOLEAN) : BOOLEAN RAISES {PkgErr.E} =
  VAR
    ql: RefList.T;
    q: Queue;
    qe, qel: QueueElem;
    res: BOOLEAN := FALSE;
    where: TEXT;
  BEGIN
    IF forSite = NIL THEN where := "all"; ELSE where := forSite; END;
    Util.LogText(Fmt.F("Send.DeQ of %s for %s\n",
            PSLib.PkgText(package), where));
    IF forSite # NIL THEN EVAL CheckSite("Send.ShowQ", forSite); END;
    LOCK mutex DO
      ql := queueList;
      WHILE ql # NIL DO
        q := ql.head; ql := ql.tail;
        IF forSite = NIL OR Text.Equal(forSite, q.site) THEN
          qe := q.head;
          qel := NIL;
          WHILE qe # NIL DO
            IF NetPath.EqualPN(package, qe.package) THEN
              IF qe = q.head THEN
                IF q.sending AND interruptSend AND NOT q.aborted THEN
                  q.aborted := TRUE;
                  Thread.Alert(q.thread);
                  res := TRUE;
                END;
              ELSE
                IF qel = NIL THEN
                  q.head := qe.next;
                ELSE
                  qel.next := qe.next;
                END;
                Param.StatDecr(Param.StatQueued);
                res := TRUE;
                EXIT;
              END;
            END;
            qel := qe;
            qe := qe.next;
          END; (* WHILE *)
        END; (* IF*)
      END; (* WHILE *)
    END; (* LOCK *)
    RETURN res;
  END Dequeue;
  
PROCEDURE Showqueues(): TEXT  =
  VAR
    ql: RefList.T;
    q: Queue;
    qe: QueueElem;
    wr: Wr.T;
    <* FATAL Wr.Failure, Thread.Alerted *>
  PROCEDURE PrintElem(x: QueueElem) = 
    VAR what, interval: TEXT;
    BEGIN
      IF x = q.head AND q.sending THEN
        interval :=  FmtTime.Short(q.startTime) &
                        " (" & Util.IntervalSince(q.startTime) & ")";
        what := "try [" & Fmt.Int(x.try) & "] since";
      ELSE
        interval := FmtTime.Short(qe.time);
        IF x.deferred THEN
          what := "deferred";
        ELSE
          what := "enqueued";
        END;
      END;
      Wr.PutText(wr, 
        Fmt.F("   %s(%s) %s %s\n",
             PSLib.PkgText(x.package),
             Fmt.Int(x.version.vn), what, interval));
    END PrintElem;
  PROCEDURE PrintConnStatus() =
    BEGIN
      IF q.linkStatus = NIL THEN
        Wr.PutText(wr,
         Fmt.F("   Connection ok for %s\n",
             Util.IntervalSince(q.linkStatusChange)));
      ELSE
        Wr.PutText(wr,
         Fmt.F("   Connection down for %s\n",
             Util.IntervalSince(q.linkStatusChange)));
        Wr.PutText(wr,
           Fmt.F("   Reason: %s\n", PkgErr.Msg(q.linkStatus)));
      END;
    END PrintConnStatus;
  BEGIN
    wr := TextWr.New();
    LOCK mutex DO
      ql := queueList;
      WHILE ql # NIL DO
        q := ql.head; ql := ql.tail;
        Wr.PutText(wr, "Queue for " & q.site & ":");
        IF q.head = NIL THEN
          Wr.PutText(wr, " empty\n");
          PrintConnStatus();
        ELSE
          Wr.PutText(wr, "\n");
          PrintConnStatus();
          qe := q.head;
          WHILE qe # NIL DO PrintElem(qe); qe := qe.next; END;
        END;
      END;
    END;
    RETURN TextWr.ToText(wr);
  END Showqueues;

PROCEDURE EnqueueIt(
    route: Route; package: PN; v: Version;
    mgr: SiteName; urgent: BOOLEAN) =
  VAR
    ql: RefList.T;
    q, tq: Queue;
    qe, lastUndeferred: QueueElem;
  BEGIN
    LOCK mutex DO
      ql := queueList;
      WHILE ql # NIL DO
        tq := ql.head; ql := ql.tail;
        IF Text.Equal(route.first, tq.site) THEN q := tq; EXIT; END;
      END;
      IF q = NIL THEN
        q := NEW(Queue, site := route.first, linkStatusChange := Time.Now());
        q.thread := Thread.Fork(q);
        queueList := RefList.Cons(q, queueList);
      END;
      qe := q.head;
      lastUndeferred := NIL;
      WHILE qe # NIL DO
        IF NetPath.EqualPN(package, qe.package) AND
             v.t = qe.version.t AND NOT (qe = q.head AND q.sending) THEN
          IF v.vn > qe.version.vn THEN qe.version := v; END;
          MaybeAddRoute(qe, route);
          qe.time := Time.Now();
          RETURN;
        END;
        IF NOT qe.deferred THEN lastUndeferred := qe; END;
        qe := qe.next;
      END;
      qe := NEW(QueueElem, package := package,
                  version := v, managedBy := mgr, time := Time.Now());
      MaybeAddRoute(qe, route);
      IF q.head = NIL THEN
        q.head := qe;
      ELSE
        IF urgent OR lastUndeferred = NIL THEN
          IF q.sending THEN
            qe.next := q.head.next;
            q.head.next := qe;
          ELSE
            qe.next := q.head;
            q.head := qe;
          END;
        ELSE
          qe.next := lastUndeferred.next;
          lastUndeferred.next := qe;
        END;
      END;
      Param.StatIncr(Param.StatQueued);
    END;
  END EnqueueIt;

PROCEDURE MaybeAddRoute(qe: QueueElem; route: Route) =
  VAR l := qe.fwd;
  BEGIN
    IF route.first # route.final THEN
      WHILE l # NIL DO
        IF Text.Equal(route.final, l.head) THEN RETURN; END;
        l := l.tail;
      END;
      qe.fwd := TextList.Cons(route.final, qe.fwd);
    END;
  END MaybeAddRoute;

PROCEDURE ComputeRoute(
    package: PN; READONLY rem: Site.Remote;
    checkSubrep: BOOLEAN; VAR (*out*) route: Route) : BOOLEAN =
  BEGIN
    route.first := rem.name;
    route.final := rem.name;
    IF rem.route # NIL THEN
      FOR j := 0 TO LAST(rem.route^) DO
        IF NOT checkSubrep OR
               Subrepo.Has(rem.route[j], package) # Subrepo.R.No THEN
          route.first := rem.route[j];
          EXIT;
        END;
      END;
    END;
    IF checkSubrep AND Subrepo.Has(rem.name, package) = Subrepo.R.No THEN
      RETURN FALSE;
    END;
    RETURN TRUE;
  END ComputeRoute;

PROCEDURE CheckSite(op: TEXT; dest: SiteName) : Site.Remote
    RAISES {PkgErr.E} =
  VAR rem: Site.Remote;
  BEGIN
    IF NOT Site.FindRemote(dest, rem) THEN
      Util.LogText(Fmt.F("%s failed for %s: no such site\n", op, dest));
      PkgErr.Raise(PkgErr.NoSuchSite);
    END;
    RETURN rem;
  END CheckSite;

CONST
    SoonPause = 30;  (* seconds *)
    LongPause = 15 * 60;
    PollPause = 30;  (* seconds *)
    PollPauseCount = 20;  (* 20 * PollPause = 10 minutes *)

TYPE SendResult = {DequeueIt, DeferIt, RetryIt};

PROCEDURE Sender(q: Queue) : REFANY =
  VAR
    qe: QueueElem;
    siphonT: Siphon.T;
    res: SendResult;
    waitFor: CARDINAL := 0;
  BEGIN
    LOOP
      TRY
        siphonT := GetSiphonT(q);
        REPEAT
          LOCK mutex DO
            qe := q.head;
            IF qe = NIL THEN EXIT; END;
            q.sending := TRUE;
            q.aborted := FALSE;
            q.startTime := Time.Now();
            INC(qe.try);
          END;
          Param.StatIncr(Param.StatCurrSend);
          res := SendOne(siphonT, q, qe);
          Param.StatDecr(Param.StatCurrSend);
          LOCK mutex DO
            q.sending := FALSE;
            CASE res OF
            | SendResult.DeferIt => waitFor := LongPause;
                (* implement real deferrals here *)
            | SendResult.RetryIt => waitFor := SoonPause;
            ELSE
              Param.StatDecr(Param.StatQueued);
              q.head := q.head.next;
              waitFor := 0;
            END;
          END;
        UNTIL waitFor # 0;
        IF waitFor # 0 THEN
          Thread.Pause(FLOAT(waitFor, LONGREAL));
        ELSE
          FOR i := 1 TO PollPauseCount DO
            IF q.head # NIL THEN EXIT; END;
            Thread.Pause(FLOAT(PollPause, LONGREAL));
          END;
        END;
      EXCEPT
      | Thread.Alerted =>
      END;
    END;
    <*NOWARN*> RETURN NIL;
  END Sender;

PROCEDURE SendOne(sT: Siphon.T; q: Queue; qe: QueueElem) : SendResult
    RAISES {Thread.Alerted} =
  VAR
    replica: TEXT;
    source: PackageObj.Source;
    id := Util.Unique();
    res := SendResult.DequeueIt;
  BEGIN
    TRY
      Util.LogText(
        Fmt.FN("NewSend %s(%s.%s) [%s] to %s (try %s)\n",
          ARRAY OF TEXT {
            PSLib.PkgText(qe.package),
            Fmt.Int(qe.version.t), Fmt.Int(qe.version.vn), 
            Fmt.Int(id), q.site, Fmt.Int(qe.try)} ));
      CASE qe.version.vn OF
      | LockOps.InitialVN, LockOps.DeletedVN =>
          source := PackageLib.EmptySource();
      ELSE
          source := PickAServer(qe.package, qe.version, replica);
      END;
      sT.ship(
          qe.package, source, qe.version,
          Param.localSite, qe.managedBy, qe.fwd);
      Param.StatIncr(Param.StatSend);
      Util.LogText(Fmt.F("Send [%s] complete\n", Fmt.Int(id)));
    EXCEPT
    | Thread.Alerted =>
        Util.LogText(Fmt.F("Send [%s] aborted\n", Fmt.Int(id)));
    | NetObj.Error(ec) =>
        Util.LogText(
          Fmt.F("Send [%s] failed: %s\n", Fmt.Int(id), PkgErr.Msg(ec)));
        res := SendResult.RetryIt;
    | NoSource(none) =>
        IF none THEN
          Util.LogText(
            Fmt.F("Send [%s] failed: package version does not exist\n",
                   Fmt.Int(id)));
        ELSE
          Util.LogText(
            Fmt.F("Send [%s] failed: package version may not exist\n",
                     Fmt.Int(id)));
          res := SendResult.DeferIt;
        END;
    | PkgErr.E(ec) =>
        Util.LogText(
            Fmt.F("Send [%s] failed: %s\n", Fmt.Int(id), PkgErr.Msg(ec)));
        IF ec.head = PkgErr.NoSuchDir THEN
          WHILE qe.fwd # NIL DO
            TRY Enqueue(qe.package, qe.version,  qe.managedBy, qe.fwd.head);
            EXCEPT | PkgErr.E =>
            END;
            qe.fwd := qe.fwd.tail;
          END;
        ELSIF ec.head = PkgErr.NoRoomInFS THEN
          res := SendResult.DeferIt;
        ELSIF ec.head = PkgErr.LockServerDown OR
              ec.head = PkgErr.SourceFailed THEN
          res := SendResult.RetryIt;
        ELSE
          res := SendResult.DequeueIt;
        END;
    END;
    RETURN res;
  END SendOne;

PROCEDURE GetSiphonT(q: Queue) : Siphon.T RAISES {Thread.Alerted} =
  VAR  t: Siphon.T := NIL;
       e: PkgErr.TL;
  BEGIN
    LOOP
      e := NIL;
      TRY
        t := Siphon.New(q.site);
      EXCEPT
      | NetObj.Error(ec) => e := ec;
      | PkgErr.E(ec) => e := ec;
      END;
      LOCK mutex DO
        IF NOT PkgErrEq(e, q.linkStatus) THEN
          IF e = NIL THEN
            Util.LogText(Fmt.F("Site %s is now reachable\n", q.site));
          ELSE
            Util.LogText(Fmt.F("Site %s is unreachable: %s\n",
                                         q.site, PkgErr.Msg(e)));
          END;
          q.linkStatus := e;
          q.linkStatusChange := Time.Now();
        END;
      END;
      IF t # NIL THEN EXIT; END;
      Thread.Pause(FLOAT(SoonPause, LONGREAL));
    END;
    RETURN t;
  END GetSiphonT;

PROCEDURE PkgErrEq(a,b: PkgErr.TL) : BOOLEAN =
  BEGIN
    WHILE a # NIL DO
      IF b = NIL OR a.head # b.head THEN RETURN FALSE; END;
      a := a.tail; b := b.tail;
    END;
    RETURN (b=NIL);
  END PkgErrEq;

EXCEPTION NoSource((*conclusive*) BOOLEAN);

PROCEDURE PickAServer
    (pn: PN; v: Version; VAR (*OUT*) replica: TEXT): PackageObj.Source
    RAISES {NoSource, Thread.Alerted} =
    (* returns always the correct instance *)
  VAR
    start, i: CARDINAL;
    testV: LockOps.Version;
    source: PackageObj.Source;
    reps: REF ARRAY OF TEXT;
    pkgT: PackageObj.T;
    conclusive: BOOLEAN := TRUE;
  BEGIN
    reps := Site.Get().replicas;
    start := ROUND(Time.Now()) MOD NUMBER (reps^);
    i := start;
    REPEAT
      INC (i);
      IF i = NUMBER (reps^) THEN i := 0;  END;
      TRY
        pkgT := PackageObj.New (reps[i]);
        source := pkgT.newSource (Param.SystemAuth, pn, testV);
        IF (testV.t = v.t) AND (testV.vn = v.vn) THEN
          replica := reps[i];
          RETURN source;
        END;
      EXCEPT
      | Thread.Alerted, NetObj.Error =>
          conclusive := FALSE;
      | PkgErr.E(ec) =>
         IF ec.head # PkgErr.NoSuchPackage AND ec.head # PkgErr.NoSuchDir THEN
           conclusive := FALSE;
         END;
      END;
    UNTIL (i = start);
    RAISE NoSource(conclusive);
  END PickAServer;

BEGIN
END Send.

